# `_TokenizingPatcherMS_README.md`

## Overview
`TokenizingPatcherMS` is a deterministic, indentation‑aware patch‑application microservice built on the `_TokenizingPATCHER` engine. It applies structured JSON hunks to a target file, supports dry‑run validation, and can destructively overwrite files when requested.

Agents use this service to perform safe, auditable, non‑overlapping code transformations.

---

## Capabilities
- Deterministic hunk‑based patching  
- Indentation‑aware replacement  
- Collision detection  
- Dry‑run + destructive modes  
- Optional sandboxing  
- Fully declarative JSON schema  

This is the **canonical** way agents modify files.

---

## When Agents Should Use This Service
Use it whenever you need to:
- Insert, replace, or remove code  
- Perform multi‑file refactors  
- Apply transformations generated by analysis  
- Maintain architectural consistency  

Do **not** rewrite files manually.  
Do **not** bypass the patcher.

---

## Endpoint: `apply_patch_to_file`

### Inputs
| Field | Type | Description |
|-------|------|-------------|
| `target_path` | str | File to patch (relative if sandboxed). |
| `patch_schema` | str | JSON string containing `"hunks"`. |
| `force_indent` | bool | Use patch indentation exactly. |
| `dry_run` | bool | Validate without writing. |
| `return_preview` | bool | Include patched text in response. |

### Outputs
| Field | Type | Description |
|-------|------|-------------|
| `success` | bool | Patch applied cleanly. |
| `message` | str | Status. |
| `target_path` | str | Resolved path. |
| `dry_run` | bool | Whether this was a dry run. |
| `force_indent_used` | bool | Final indentation mode. |
| `written` | bool | True if file overwritten. |
| `patched_preview` | str | Optional preview. |

---

## Patch Schema Contract

```json
{
  "hunks": [
    {
      "description": "Short description",
      "search_block": "text to find\n(multi-line allowed)",
      "replace_block": "replacement text",
      "use_patch_indent": false
    }
  ]
}
```

### Rules
1. Hunks must not overlap.  
2. `search_block` must match exactly (strict → content‑only fallback).  
3. Indentation must be intentional.  
4. Hunks must be self‑contained.  
5. Validate with dry‑run before destructive writes.

---

## How the Refactor Engine Calls This Service

### 1. Import and instantiate
```python
from microservice.tokenizing_patcher_ms import TokenizingPatcherMS

patcher = TokenizingPatcherMS(
    config={
        "base_dir": "/sandbox/workspace",
        "default_force_indent": False,
        "allow_absolute_paths": False
    }
)
```

### 2. Build patch schema
```python
patch_obj = {
    "hunks": [
        {
            "description": "Replace header",
            "search_block": "def old():",
            "replace_block": "def new():",
            "use_patch_indent": False
        }
    ]
}
```

### 3. Convert to JSON string
```python
import json
schema_str = json.dumps(patch_obj)
```

### 4. Dry‑run
```python
result = patcher.apply_patch_to_file(
    target_path="src/module/example.py",
    patch_schema=schema_str,
    dry_run=True,
    return_preview=True
)
```

### 5. If correct → destructive overwrite
```python
patcher.apply_patch_to_file(
    target_path="src/module/example.py",
    patch_schema=schema_str,
    dry_run=False
)
```

### 6. Inspect results
```python
if not result["success"]:
    raise RuntimeError(result["message"])
```

This is the **standard refactor‑engine ritual**:
**analyze → generate patch → dry‑run → inspect → apply → recurse.**

---

## Sandbox Behavior
If configured with:

```python
{
  "base_dir": "/sandbox/workspace",
  "allow_absolute_paths": false
}
```

Then:
- All paths must be inside the sandbox  
- Escapes are rejected  
- Destructive writes are safe  

---

## Philosophy
This service enforces:
- determinism  
- clarity  
- explicit intent  
- safe automation  

Agents participate in the recursive ritual:  
**patch → validate → apply → recurse.**

---

