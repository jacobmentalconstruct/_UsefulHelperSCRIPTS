{
  "hunks": [
    {
      "description": "Add .gitignore parsing + matching helpers (robust, supports !negation and dir patterns)",
      "search_block": "def is_binary(file_path: Path) -> bool:\n    \"\"\"Check if a file is binary by reading the first chunk.\"\"\"",
      "replace_block": "def _parse_gitignore_lines(lines: List[str]) -> List[Tuple[bool, str, bool]]:\n    \"\"\"Parse .gitignore lines into ordered rules.\n\n    Returns: list of (negate, pattern, dir_only)\n    - negate: True if rule starts with '!'\n    - pattern: normalized POSIX-ish pattern (no trailing spaces)\n    - dir_only: True if pattern ends with '/'\n\n    Notes:\n    - This is intentionally a pragmatic implementation (fnmatch-based), not a full git spec engine,\n      but it correctly handles the common cases (including .venv/, *.pyc, /dist, !keep.txt).\n    \"\"\"\n    rules: List[Tuple[bool, str, bool]] = []\n    for raw in lines:\n        s = raw.strip(\"\\n\")\n        if not s or s.lstrip().startswith(\"#\"):\n            continue\n        s = s.strip()\n        negate = s.startswith(\"!\")\n        if negate:\n            s = s[1:].strip()\n            if not s:\n                continue\n        dir_only = s.endswith(\"/\")\n        if dir_only:\n            s = s[:-1]\n        # normalize separators\n        s = s.replace(\"\\\\\", \"/\")\n        rules.append((negate, s, dir_only))\n    return rules\n\n\ndef _load_gitignore_rules(root: Path) -> List[Tuple[bool, str, bool]]:\n    \"\"\"Load .gitignore rules from the project root (if present).\"\"\"\n    gi = root / \".gitignore\"\n    if not gi.exists() or not gi.is_file():\n        return []\n    try:\n        txt = gi.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    except Exception:\n        return []\n    return _parse_gitignore_lines(txt.splitlines())\n\n\ndef _gitignore_match(rel_posix: str, name: str, rule_pat: str) -> bool:\n    \"\"\"Match a gitignore-style pattern against a rel path.\n\n    Matching strategy:\n    - If pattern contains '/', match against rel_posix\n    - Else match against basename (name)\n    - If pattern starts with '/', anchor to root (strip leading '/').\n    \"\"\"\n    pat = rule_pat\n    if pat.startswith(\"/\"):\n        pat = pat[1:]\n        return fnmatch.fnmatch(rel_posix, pat)\n\n    if \"/\" in pat:\n        return fnmatch.fnmatch(rel_posix, pat)\n\n    return fnmatch.fnmatch(name, pat)\n\n\ndef _gitignore_is_ignored(rel_posix: str, name: str, is_dir: bool, rules: List[Tuple[bool, str, bool]]) -> bool:\n    \"\"\"Apply ordered gitignore rules. Later matches override earlier ones.\"\"\"\n    ignored = False\n    for negate, pat, dir_only in rules:\n        if dir_only and not is_dir:\n            continue\n        if _gitignore_match(rel_posix, name, pat):\n            ignored = (not negate)\n    return ignored\n\n\ndef is_binary(file_path: Path) -> bool:\n    \"\"\"Check if a file is binary by reading the first chunk.\"\"\"",
      "use_patch_indent": false
    },
    {
      "description": "Unify exclusions: add UI toggle + path-level exclusion function (default exclusions + dynamic patterns + .gitignore)",
      "search_block": "    def should_exclude_file(self, filename: str) -> bool:\n        with self.state_lock:\n            pats = PREDEFINED_EXCLUDED_FILENAMES.union(self.dynamic_global_excluded_filenames)\n        return any(fnmatch.fnmatch(filename, p) for p in pats)\n",
      "replace_block": "    def _respect_exclusions_enabled(self) -> bool:\n        \"\"\"UI/engine toggle: when False, we include everything (verbose mapping).\"\"\"\n        try:\n            var = self.widgets.get('respect_exclusions')\n            if var is None:\n                return True\n            return bool(var.get())\n        except Exception:\n            return True\n\n    def should_exclude_file(self, filename: str) -> bool:\n        \"\"\"Filename/pattern exclusions (predefined + dynamic).\"\"\"\n        if not self._respect_exclusions_enabled():\n            return False\n        with self.state_lock:\n            pats = PREDEFINED_EXCLUDED_FILENAMES.union(self.dynamic_global_excluded_filenames)\n        return any(fnmatch.fnmatch(filename, p) for p in pats)\n\n    def should_exclude_path(self, path: Path, project_root: Path) -> bool:\n        \"\"\"Unified exclusion check.\n\n        Applies:\n        - Default excluded folders (.venv, .git, node_modules, etc.)\n        - Pattern exclusions (predefined + dynamic)\n        - .gitignore (from project root)\n\n        When the UI toggle is OFF, returns False (include everything).\n        \"\"\"\n        if not self._respect_exclusions_enabled():\n            return False\n\n        try:\n            root = project_root.resolve()\n            p = path.resolve()\n        except Exception:\n            return False\n\n        # Ensure within project root\n        if p != root and not str(p).startswith(str(root)):\n            return False\n\n        name = p.name\n        is_dir = p.is_dir()\n\n        # 1) Hard folder exclusions\n        if name in EXCLUDED_FOLDERS:\n            return True\n\n        # 2) Pattern exclusions (apply to both dirs and files)\n        if self.should_exclude_file(name):\n            return True\n\n        # 3) .gitignore rules\n        try:\n            rel_posix = p.relative_to(root).as_posix()\n        except Exception:\n            rel_posix = name\n\n        rules = _load_gitignore_rules(root)\n        if rules and _gitignore_is_ignored(rel_posix, name, is_dir, rules):\n            return True\n\n        return False\n",
      "use_patch_indent": false
    },
    {
      "description": "Add UI checkbox to toggle respecting exclusions/.gitignore (default ON)",
      "search_block": "        # -- Timestamp Checkbox --\n        self.widgets['use_timestamps'] = tk.BooleanVar(value=False)\n        ts_chk = tk.Checkbutton(util_frame, text=\"Append Timestamps to Filenames\", variable=self.widgets['use_timestamps'],\n                                bg=\"#1e1e2f\", fg=\"white\", selectcolor=\"#252526\", activebackground=\"#1e1e2f\")\n        ts_chk.pack(side=tk.LEFT, padx=10)\n",
      "replace_block": "        # -- Timestamp Checkbox --\n        self.widgets['use_timestamps'] = tk.BooleanVar(value=False)\n        ts_chk = tk.Checkbutton(util_frame, text=\"Append Timestamps to Filenames\", variable=self.widgets['use_timestamps'],\n                                bg=\"#1e1e2f\", fg=\"white\", selectcolor=\"#252526\", activebackground=\"#1e1e2f\")\n        ts_chk.pack(side=tk.LEFT, padx=10)\n\n        # -- Exclusion / .gitignore Toggle (default ON) --\n        self.widgets['respect_exclusions'] = tk.BooleanVar(value=True)\n        excl_chk = tk.Checkbutton(\n            util_frame,\n            text=\"Respect .gitignore + exclusions\",\n            variable=self.widgets['respect_exclusions'],\n            bg=\"#1e1e2f\",\n            fg=\"white\",\n            selectcolor=\"#252526\",\n            activebackground=\"#1e1e2f\"\n        )\n        excl_chk.pack(side=tk.LEFT, padx=10)\n",
      "use_patch_indent": false
    },
    {
      "description": "Fix initial tree scan to use unified exclusion logic (ensures UI matches map/dump/backup behavior)",
      "search_block": "                    if p.name in EXCLUDED_FOLDERS: continue\n",
      "replace_block": "                    if self.should_exclude_path(p, root_path):\n                        continue\n",
      "use_patch_indent": false
    },
    {
      "description": "Fix Map Project Tree to exclude folders like .venv and respect .gitignore (and match UI toggle behavior)",
      "search_block": "        def _recurse(curr: Path, depth: int = 0):\n            if self.stop_event.is_set(): return\n\n            try: items = sorted(curr.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))\n            except: return\n\n            for item in items:\n                # Skip if not selected\n                if item.is_dir() and not self.is_selected(item, root):\n                    continue\n\n                indent = \"  \" * depth\n\n                if item.is_dir():\n                    lines.append(f\"{indent}üìÅ {item.name}/\")\n                    _recurse(item, depth + 1)\n                else:\n                    # Only include files inside selected folders\n                    if self.is_selected(item.parent, root):\n                        lines.append(f\"{indent}üìÑ {item.name}\")\n",
      "replace_block": "        def _recurse(curr: Path, depth: int = 0):\n            if self.stop_event.is_set():\n                return\n\n            try:\n                items = sorted(curr.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))\n            except Exception:\n                return\n\n            for item in items:\n                if self.stop_event.is_set():\n                    return\n\n                # 1) Unified exclusions (.gitignore + default + dynamic), unless user toggled it off\n                if self.should_exclude_path(item, root):\n                    continue\n\n                # 2) Selection gate\n                if item.is_dir() and not self.is_selected(item, root):\n                    continue\n\n                indent = \"  \" * depth\n\n                if item.is_dir():\n                    lines.append(f\"{indent}üìÅ {item.name}/\")\n                    _recurse(item, depth + 1)\n                else:\n                    # Only include files inside selected folders\n                    if self.is_selected(item.parent, root):\n                        lines.append(f\"{indent}üìÑ {item.name}\")\n",
      "use_patch_indent": false
    },
    {
      "description": "Make Dump Source Files respect .gitignore + exclusions (and match the same toggle as UI/map)",
      "search_block": "        for curr_dir, d, f in os.walk(root):\n            if self.stop_event.is_set(): break\n            d[:] = [x for x in d if x not in EXCLUDED_FOLDERS and self.is_selected(Path(curr_dir)/x, root)]\n\n            for fname in f:\n                if self.stop_event.is_set(): break\n                if self.should_exclude_file(fname): continue\n",
      "replace_block": "        for curr_dir, d, f in os.walk(root):\n            if self.stop_event.is_set():\n                break\n\n            curr_path = Path(curr_dir)\n\n            # Filter directories in-place so os.walk doesn't descend into excluded/ignored dirs\n            kept_dirs = []\n            for x in d:\n                p = curr_path / x\n                if not self.is_selected(p, root):\n                    continue\n                if self.should_exclude_path(p, root):\n                    continue\n                kept_dirs.append(x)\n            d[:] = kept_dirs\n\n            for fname in f:\n                if self.stop_event.is_set():\n                    break\n                p = curr_path / fname\n                if self.should_exclude_path(p, root):\n                    continue\n",
      "use_patch_indent": false
    },
    {
      "description": "Make Backup Project (Zip) respect .gitignore + exclusions (same toggle, same behavior)",
      "search_block": "        for curr_dir, d, f in os.walk(root):\n            if self.stop_event.is_set(): break\n            curr_path = Path(curr_dir)\n\n            # Prune traversal\n            d[:] = [x for x in d if self.is_selected(curr_path/x, root)]\n",
      "replace_block": "        for curr_dir, d, f in os.walk(root):\n            if self.stop_event.is_set():\n                break\n            curr_path = Path(curr_dir)\n\n            # Prune traversal (selection + unified exclusions)\n            kept_dirs = []\n            for x in d:\n                p = curr_path / x\n                if not self.is_selected(p, root):\n                    continue\n                if self.should_exclude_path(p, root):\n                    continue\n                kept_dirs.append(x)\n            d[:] = kept_dirs\n",
      "use_patch_indent": false
    },
    {
      "description": "Ensure Backup Project file loop also respects unified exclusions (.gitignore + default + dynamic)",
      "search_block": "            for fname in f:\n                if self.stop_event.is_set(): break\n                src = curr_path / fname\n\n                # Skip unselected\n                if not self.is_selected(curr_path, root):\n                    continue\n",
      "replace_block": "            for fname in f:\n                if self.stop_event.is_set():\n                    break\n                src = curr_path / fname\n\n                # Skip unselected\n                if not self.is_selected(curr_path, root):\n                    continue\n\n                # Skip excluded/ignored\n                if self.should_exclude_path(src, root):\n                    continue\n",
      "use_patch_indent": false
    }
  ]
}