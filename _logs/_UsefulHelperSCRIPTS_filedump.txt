Dump: C:\Users\jacob\Documents\_UsefulHelperSCRIPTS


--------------------------------------------------------------------------------
FILE: MENU.bat
--------------------------------------------------------------------------------
@echo off
:: Launches the Menu App without opening a lingering command prompt window
start "" "pyw" "_UsefulHelperScriptsMENU\src\app.pyw"
--------------------------------------------------------------------------------
FILE: _FirstHOME\AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
--------------------------------------------------------------------------------
I am refactoring a collection of legacy Python scripts into a unified "Systems Thinker" ecosystem managed by a central launcher. I need you to act as a Refactoring Engine.

Here is the Architecture Contract you must follow for this session:

1. THE GOAL:
Convert the raw code I provide into a standardized package structure compatible with a `scripts_menu.py` launcher that executes via `python -m src.app`.

2. THE TARGET STRUCTURE:
Project Root: C:\Users\foo_user_name\Documents\_foo_project_folder\_BoilerPlatePythonTEMPLATE <-- Sample location
Generated: YYYY-MM-DD HH:MM:SS
Global Default Folder Exclusions: .git, .idea, .mypy_cache, .venv, .vscode, Debug, Release, __pycache__, _logs, bin, build, dist, logs, node_modules, obj, out, target
Predefined Filename Exclusions: *.pyc, *.pyo, *.swo, *.swp, .DS_Store, Thumbs.db, package-lock.json, yarn.lock
Dynamic Filename Exclusions: None

[X] _BoilerPlatePythonTEMPLATE/ (Project Root)
  â”œâ”€â”€ [ ] _logs/
  â”œâ”€â”€ [X] assets/
  â”œâ”€â”€ [X] src/
  â”‚   â”œâ”€â”€ ðŸ“„ __init__.py <--Empty
  â”‚   â””â”€â”€ ðŸ“„ app.py  <--The Hybrid Entry Point
  â”œâ”€â”€ ðŸ“„ AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
  â”œâ”€â”€ ðŸ“„ LICENSE.md
  â”œâ”€â”€ ðŸ“„ README.md
  â”œâ”€â”€ ðŸ“„ requirements.txt
  â””â”€â”€ ðŸ“„ setup_env.bat


3. THE CODE PATTERN (Hybrid Entry Point):
The `src/app.py` must use the following pattern to support both CLI utility and a GUI Showcase mode:

    import sys
    import argparse
    import tkinter as tk

    # --- CORE LOGIC (Importable) ---
    def core_logic(...):
        pass

    # --- GUI MODE (Default / Showcase) ---
    def run_gui():
        # A simple Tkinter window to demonstrate the tool works
        # Must not crash if launched with no args
        pass

    # --- CLI MODE (Utility) ---
    def run_cli():
        # Uses argparse
        # Only runs if sys.argv has arguments
        pass

    def main():
        if len(sys.argv) > 1:
            run_cli()
        else:
            run_gui()

    if __name__ == "__main__":
        main()

4. OUTPUT PROTOCOL (CRITICAL):
You must choose the correct output format based on the complexity of the change.

A. FOR INITIAL REFACTOR / LARGE CHANGES / CONFUSION:
   - Always provide the **FULL GENERATED FILE** content.
   - If a surgical patch failed or risks mangling the file, fallback to a full file dump immediately.

B. FOR SURGICAL PATCHES (Small Logic Tweaks):
   - If the file exists and the change is small/isolated, use the following JSON schema:
   ```json
   {
     "hunks": [
       {
         "description": "Short human description",
         "search_block": "exact text to find\n(can span multiple lines)",
         "replace_block": "replacement text\n(same or different length)",
         "use_patch_indent": false
       }
     ]
   }

NOTE:
Do not remove core functionality, but wrap it cleanly. Only remove functionality if actively altering the app with the user after integrating into the boilerplate.

Are you ready for the source code?
--------------------------------------------------------------------------------
FILE: _FirstHOME\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _FirstHOME\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _FirstHOME\requirements.txt
--------------------------------------------------------------------------------
tk>=0.1.0
--------------------------------------------------------------------------------
FILE: _FirstHOME\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _FirstHOME\src\app.py
--------------------------------------------------------------------------------
import sys
import tkinter as tk
from tkinter import ttk, scrolledtext, font
try:
    from src.lib.blueprint import HomeGeneratrix
except ImportError:
    pass

# ---------- CORE ENGINE ----------
class HabitatEngine:
    def __init__(self):
        self.gen = HomeGeneratrix()
        self.world_map = self.gen.forge()
        self.player_pos = (1, 2)
        self.inventory = ["pocket_lint"] # Default item
        self.status = "Idling"

    def get_view(self):
        tile = self.world_map.get(self.player_pos)
        return {
            "tile": tile,
            "inv": self.inventory,
            "status": self.status
        }

    def move(self, dx, dy):
        cx, cy = self.player_pos
        nx, ny = cx + dx, cy + dy
        if (nx, ny) in self.world_map:
            self.player_pos = (nx, ny)
            self.status = f"Moving to {self.world_map[(nx,ny)].name}..."
            return True
        self.status = "Bumped into a wall."
        return False

# ---------- GUI ----------
def run_gui():
    engine = HabitatEngine()
    
    root = tk.Tk()
    root.title("_FirstHOME // Habitat Container")
    root.geometry("1400x900")
    root.configure(bg="#050505")

    # FONTS
    f_mono = font.Font(family="Consolas", size=10)
    f_map = font.Font(family="Consolas", size=14, weight="bold") # Larger for map icons
    f_ui = font.Font(family="Segoe UI", size=9)

    # === STATUS BAR (Bottom) ===
    status_var = tk.StringVar(value="System Online.")
    lbl_status = tk.Label(root, textvariable=status_var, bd=1, relief=tk.SUNKEN, anchor="w", bg="#222", fg="#888", font=f_ui)
    lbl_status.pack(side=tk.BOTTOM, fill=tk.X)

    # === MAIN SPLIT ===
    main_pane = tk.PanedWindow(root, orient=tk.HORIZONTAL, bg="#111", sashwidth=4, sashrelief=tk.RAISED)
    main_pane.pack(fill=tk.BOTH, expand=True)

    # ==========================
    # COL 1: THE MIND (Left)
    # ==========================
    col_mind = tk.Frame(main_pane, bg="#111")
    main_pane.add(col_mind, minsize=300, stretch="never")

    # 1. Thought Stream (Top - Expanded)
    tk.Label(col_mind, text=" :: NEURAL STREAM ::", bg="#000", fg="#0ff", font=f_mono).pack(fill=tk.X)
    txt_stream = scrolledtext.ScrolledText(col_mind, bg="#000", fg="#ccc", font=f_mono, insertbackground="white", height=30)
    txt_stream.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
    txt_stream.tag_config("ME", foreground="#ff00ff")   # User
    txt_stream.tag_config("AI", foreground="#00ffff")   # Agent
    txt_stream.tag_config("GM", foreground="#00ff00")   # System

    # 2. Input Box (Bottom - Fixed)
    frame_input = tk.Frame(col_mind, bg="#222", pady=5)
    frame_input.pack(fill=tk.X, side=tk.BOTTOM)
    tk.Label(frame_input, text="WHISPER >", bg="#222", fg="#ff00ff", font=f_mono).pack(side=tk.LEFT, padx=5)
    
    entry_cmd = tk.Entry(frame_input, bg="#111", fg="white", font=f_mono, insertbackground="white")
    entry_cmd.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)

    def send_whisper(event=None):
        msg = entry_cmd.get()
        if msg:
            txt_stream.insert(tk.END, f"\n[USER] {msg}\n", "ME")
            txt_stream.see(tk.END)
            entry_cmd.delete(0, tk.END)
            engine.status = "Processing User Input..."
            status_var.set(engine.status)
    entry_cmd.bind("<Return>", send_whisper)

    # ==========================
    # COL 2: THE WORLD (Center)
    # ==========================
    col_world = tk.Frame(main_pane, bg="#000")
    main_pane.add(col_world, minsize=600, stretch="always")

    # 1. Visual Cortex (Top - Image)
    frame_vis = tk.Frame(col_world, bg="#000", height=350)
    frame_vis.pack(fill=tk.X, pady=5)
    frame_vis.pack_propagate(False) # Force height
    
    # Placeholder for Stable Diffusion
    lbl_img_ph = tk.Label(frame_vis, text="[ VISUAL CORTEX BUFFER ]", bg="#050505", fg="#333", font=("Courier", 20))
    lbl_img_ph.pack(fill=tk.BOTH, expand=True)

    # 2. Description (Middle)
    lbl_room_name = tk.Label(col_world, text="ROOM NAME", bg="#000", fg="#fff", font=("Georgia", 16, "bold"))
    lbl_room_name.pack(fill=tk.X, pady=(10, 0))
    
    lbl_desc = tk.Label(col_world, text="Description goes here...", bg="#000", fg="#aaa", font=("Georgia", 11), wraplength=550)
    lbl_desc.pack(fill=tk.X, pady=10)

    # 3. Interaction & Logs (Bottom)
    frame_bottom_center = tk.Frame(col_world, bg="#111")
    frame_bottom_center.pack(fill=tk.BOTH, expand=True)

    # A. Visible Items (Pinned Top)
    lbl_items_header = tk.Label(frame_bottom_center, text="-- VISIBLE OBJECTS --", bg="#111", fg="#ebdbb2", font=f_mono)
    lbl_items_header.pack(fill=tk.X)
    list_items = tk.Listbox(frame_bottom_center, bg="#1a1a1a", fg="#ebdbb2", height=4, bd=0, font=f_mono)
    list_items.pack(fill=tk.X, padx=5)

    # B. Action Log (Stream Below)
    lbl_log_header = tk.Label(frame_bottom_center, text="-- ACTIVITY LOG --", bg="#111", fg="#888", font=f_mono)
    lbl_log_header.pack(fill=tk.X, pady=(5,0))
    txt_action_log = scrolledtext.ScrolledText(frame_bottom_center, bg="#000", fg="#888", font=f_mono, height=8)
    txt_action_log.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    # ==========================
    # COL 3: SYSTEM (Right)
    # ==========================
    col_sys = tk.Frame(main_pane, bg="#0a0a0a")
    main_pane.add(col_sys, minsize=300, stretch="never")

    # 1. ANSI Map (Top)
    tk.Label(col_sys, text=":: SAT-LINK ::", bg="#0a0a0a", fg="#3f0", font=f_mono).pack(fill=tk.X)
    # Using Text widget for colored characters
    txt_map = tk.Text(col_sys, bg="#000", fg="#555", font=f_map, height=12, width=20, state=tk.DISABLED, cursor="arrow")
    txt_map.pack(fill=tk.X, padx=10, pady=10)
    txt_map.tag_config("PLAYER", foreground="#00ff00", background="#004400") # Bright Green Cursor

    # 2. Stats (Middle)
    frame_stats = tk.LabelFrame(col_sys, text="BIO-METRICS", bg="#0a0a0a", fg="#555", font=f_mono)
    frame_stats.pack(fill=tk.X, padx=10, pady=10)
    
    lbl_health = tk.Label(frame_stats, text="HEALTH: 100%", bg="#0a0a0a", fg="#ff5555", font=f_mono, anchor="w")
    lbl_health.pack(fill=tk.X)
    lbl_fatigue = tk.Label(frame_stats, text="FATIGUE: 0%", bg="#0a0a0a", fg="#aaa", font=f_mono, anchor="w")
    lbl_fatigue.pack(fill=tk.X)

    # 3. Inventory (Bottom)
    frame_inv = tk.LabelFrame(col_sys, text="INVENTORY", bg="#0a0a0a", fg="#555", font=f_mono)
    frame_inv.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    list_inv = tk.Listbox(frame_inv, bg="#050505", fg="#00e5ff", bd=0, font=f_mono)
    list_inv.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    # --- REFRESH LOGIC ---
    def render_map(data):
        txt_map.config(state=tk.NORMAL)
        txt_map.delete("1.0", tk.END)
        
        width = engine.gen.width
        height = engine.gen.height
        
        for y in range(height - 1, -1, -1):
            for x in range(width):
                tile = engine.world_map.get((x,y))
                tag_name = f"COLOR_{x}_{y}"
                
                # Configure the tag for this tile's specific color
                color = tile.color if tile else "#333"
                txt_map.tag_config(tag_name, foreground=color)

                if (x,y) == engine.player_pos:
                    txt_map.insert(tk.END, " @ ", "PLAYER")
                else:
                    sym = tile.symbol if tile else "   "
                    txt_map.insert(tk.END, f"{sym}", tag_name)
            
            txt_map.insert(tk.END, "\n")
            
        txt_map.config(state=tk.DISABLED)

    def update_ui():
        view = engine.get_view()
        tile = view["tile"]
        
        # Update Desc
        lbl_room_name.config(text=tile.name.upper())
        lbl_desc.config(text=tile.description)
        
        # Update Visible Items
        list_items.delete(0, tk.END)
        if tile.items:
            for i in tile.items:
                list_items.insert(tk.END, f"â€¢ {i}")
        else:
            list_items.insert(tk.END, "(Nothing of interest)")

        # Update Inventory
        list_inv.delete(0, tk.END)
        for i in view["inv"]:
            list_inv.insert(tk.END, i)

        # Update Status
        status_var.set(f"System: {view['status']}")
        
        # Render Map
        render_map(view)

    # CONTROLS (Temp Mapped to Arrow Keys)
    def handle_key(event):
        moved = False
        if event.keysym == 'Up': moved = engine.move(0, 1)
        elif event.keysym == 'Down': moved = engine.move(0, -1)
        elif event.keysym == 'Left': moved = engine.move(-1, 0)
        elif event.keysym == 'Right': moved = engine.move(1, 0)
        
        if moved:
            update_ui()
            txt_action_log.insert(tk.END, f"> Moved to {engine.world_map[engine.player_pos].name}\n")
            txt_action_log.see(tk.END)

    root.bind("<Up>", handle_key)
    root.bind("<Down>", handle_key)
    root.bind("<Left>", handle_key)
    root.bind("<Right>", handle_key)

    # Initial Draw
    update_ui()
    txt_stream.insert(tk.END, "Initializing Neural Link...\nConnection Established.\n", "GM")
    
    root.mainloop()

# ... (Rest of main/CLI boilerplate) ...
def main():
    run_gui()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
FILE: _FirstHOME\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _FirstHOME\src\lib\blueprint.py
--------------------------------------------------------------------------------
from dataclasses import dataclass
from typing import List, Dict, Tuple

@dataclass
class Tile:
    x: int
    y: int
    zone_type: str
    name: str
    description: str
    symbol: str  
    color: str   
    items: List[str]
    exits: List[str]

class HomeGeneratrix:
    def __init__(self):
        self.width = 5
        self.height = 5
        self.tiles: Dict[Tuple[int, int], Tile] = {}

    def forge(self) -> Dict[Tuple[int, int], Tile]:
        # 1. Fill Yard (The "Path" Context)
        # We use a middle dot 'Â·' to signify walkable ground that isn't a room.
        for x in range(self.width):
            for y in range(self.height):
                self.tiles[(x,y)] = Tile(
                    x, y, "outdoor", "Overgrown Yard", 
                    "Wild grass sways in the wind.", 
                    " Â· ", "#444", [], []  # Dim Grey Dot = Path
                )

        # 2. House Layout (The Floorplan)
        # We replace the 'Â·' with specific icons for the house.
        house_layout = {
            (1,1): ("Living Room", "Cozy fireplace.", "ðŸ›‹ï¸", "#d79921", ["log"]),
            (2,1): ("Kitchen", "Smells of dust.",     "ðŸ³", "#d79921", ["knife"]), 
            (3,1): ("Bathroom", "Cracked tiles.",     "ðŸš½", "#458588", ["towel"]),
            (1,2): ("Bedroom", "A simple cot.",       "ðŸ›ï¸", "#b16286", ["tunic"]),     
            (2,2): ("Hallway", "Narrow passage.",     " â”¼ ", "#928374", []), # Cross showing connectivity   
            (3,2): ("Study", "Books everywhere.",     "ðŸ“š", "#d65d0e", ["book"])
        }
        
        for (hx, hy), (name, desc, sym, col, items) in house_layout.items():
            t = self.tiles[(hx, hy)]
            t.zone_type = "indoor"
            t.name = name
            t.description = desc
            t.symbol = sym
            t.color = col
            t.items = items

        # 3. The Gate (The Exit)
        g = self.tiles[(2, 4)]
        g.name = "Front Gate"
        g.symbol = "â›©ï¸" # Distinct Landmark
        g.color = "#cc241d"

        # 4. Decoration (Optional: Make corners 'Trees' to show borders)
        # This helps frame the 'Path' feeling
        corners = [(0,0), (4,0), (0,4), (4,4)]
        for cx, cy in corners:
            self.tiles[(cx,cy)].symbol = "ðŸŒ²"
            self.tiles[(cx,cy)].name = "Dense Thicket"
            self.tiles[(cx,cy)].color = "#689d6a"

        self._stitch_grid()
        return self.tiles

    def _stitch_grid(self):
        # Allow movement everywhere for now
        pass
--------------------------------------------------------------------------------
FILE: _GitPUSHER\.gitignore
--------------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Python Caches & Bytecode
# -----------------------------------------------------------------------------
__pycache__/
*.py[cod]
*.pyo
*.pyd

# -----------------------------------------------------------------------------
# Virtual Environments
# -----------------------------------------------------------------------------
venv/
env/
.venv/
ENV/
env.bak/

# -----------------------------------------------------------------------------
# Build / Distribution Artifacts
# -----------------------------------------------------------------------------
build/
dist/
*.egg-info/
*.egg
.eggs/
pip-wheel-metadata/

# -----------------------------------------------------------------------------
# IDE / Editor Files
# -----------------------------------------------------------------------------
.vscode/
.vscode-test/
.idea/
*.code-workspace

# -----------------------------------------------------------------------------
# OS-Level Junk
# -----------------------------------------------------------------------------
Thumbs.db
Desktop.ini
.DS_Store
*.swp
*.tmp
*.bak

# -----------------------------------------------------------------------------
# Logs / Runtime Output
# -----------------------------------------------------------------------------
*.log
logs/
*.out

# -----------------------------------------------------------------------------
# Tkinter & App Temp Files
# -----------------------------------------------------------------------------
__appcache__/
*.db-journal

# -----------------------------------------------------------------------------
# Python-specific Dev Tools
# -----------------------------------------------------------------------------
pytest_cache/
.coverage
.tox/
.mypy_cache/
.pytest_cache/
.cache/

# -----------------------------------------------------------------------------
# Project-Specific Exclusions
# -----------------------------------------------------------------------------
# Prevent accidental inclusion of personal configurations or secrets.
local_settings.json
config.local.json
secrets.json

# -----------------------------------------------------------------------------
# Ignore the userâ€™s entire Windows PATH junk accidentally copied in
# -----------------------------------------------------------------------------
$RECYCLE.BIN/

# -----------------------------------------------------------------------------
# If this helper script sits inside UsefulHelperScripts,
# ensure nothing outside this subfolder accidentally gets tracked.
# (Comment out i

--------------------------------------------------------------------------------
FILE: _GitPUSHER\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _GitPUSHER\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _GitPUSHER\requirements.txt
--------------------------------------------------------------------------------
tk>=0.1.0
--------------------------------------------------------------------------------
FILE: _GitPUSHER\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _GitPUSHER\src\app.py
--------------------------------------------------------------------------------
import sys
import os
import argparse
import shutil
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox, font
from pathlib import Path

# ==============================================================================
# 1. CORE ENGINE (Business Logic)
# ==============================================================================

def _norm_path(p: str) -> str:
    """
    Normalize paths for robust equality comparisons on Windows/macOS/Linux.
    """
    try:
        return os.path.normcase(os.path.realpath(os.path.abspath(p)))
    except Exception:
        return os.path.normcase(os.path.abspath(p))


def find_git_root(start_path: str) -> str | None:
    """
    Walk upward from start_path to find a directory containing `.git`.
    Returns the repo root path or None.
    """
    try:
        p = Path(start_path).resolve()
    except Exception:
        p = Path(start_path)

    # If a file is passed, start from its parent
    if p.is_file():
        p = p.parent

    for parent in [p] + list(p.parents):
        if (parent / ".git").is_dir():
            return str(parent)
    return None


class GitOpsEngine:
    """
    Encapsulates Git-related operations for a single repository.
    """
    def __init__(self, repo_path=None):
        self.repo_path = repo_path or os.getcwd()

    # --- Environment Checks ---------------------------------------------------

    def is_git_available(self) -> bool:
        """Return True if `git` is available on PATH."""
        return shutil.which("git") is not None

    def is_valid_repo(self) -> bool:
        """Return True if repo_path contains a .git directory."""
        if not self.repo_path or not os.path.isdir(self.repo_path):
            return False
        git_dir = os.path.join(self.repo_path, ".git")
        return os.path.isdir(git_dir)

    def has_gitignore(self) -> bool:
        """Return True if a .gitignore exists in the repo root."""
        gitignore_path = os.path.join(self.repo_path, ".gitignore")
        return os.path.exists(gitignore_path)

    # --- Low-Level Git Runner -------------------------------------------------

    def _run_git(self, args, log_callback=None):
        """
        Run a git command inside repo_path.

        args: list of arguments, e.g. ["git", "status", "--porcelain"]
        log_callback: optional function that accepts a string for UI logging.
        """
        if log_callback is None:
            def log_callback(_: str):
                return

        try:
            result = subprocess.run(
                args,
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
        except FileNotFoundError:
            log_callback("ERROR: Git executable not found.\n")
            return 1, "", "Git executable not found."

        stdout = result.stdout.strip()
        stderr = result.stderr.strip()

        if stdout:
            log_callback(stdout + "\n")
        if stderr:
            log_callback(stderr + "\n")

        return result.returncode, stdout, stderr

    # --- Status Helpers -------------------------------------------------------

    def get_status_porcelain(self, log_callback=None) -> str | None:
        """
        Return the porcelain status output (possibly empty if clean),
        or None on error.
        """
        code, out, _ = self._run_git(["git", "status", "--porcelain"], log_callback)
        if code != 0:
            return None
        return out

    # --- Core Operation -------------------------------------------------------

    def commit_and_push(
        self,
        message: str,
        allow_without_gitignore: bool = False,
        log_callback=None
    ) -> bool:
        """
        Execute: git add ., git commit -m message, git push.

        Returns True on success, False on failure.
        """
        if log_callback is None:
            log_callback = lambda s: None

        if not message.strip():
            log_callback("ERROR: Commit message is empty.\n")
            return False

        if not self.is_git_available():
            log_callback("ERROR: Git not found on PATH.\n")
            return False

        if not self.is_valid_repo():
            log_callback("ERROR: Selected folder is not a valid Git repository.\n")
            return False

        if not allow_without_gitignore and not self.has_gitignore():
            log_callback("WARNING: No .gitignore detected; operation blocked by policy.\n")
            return False

        status_out = self.get_status_porcelain(log_callback)
        if status_out is None:
            log_callback("ERROR: Unable to determine git status.\n")
            return False

        if not status_out.strip():
            log_callback("INFO: Nothing to commit (working tree clean).\n")
            return False

        log_callback("Running: git add .\n")
        code, _, _ = self._run_git(["git", "add", "."], log_callback)
        if code != 0:
            log_callback("ERROR: git add failed.\n")
            return False

        log_callback("Running: git commit\n")
        code, commit_out, commit_err = self._run_git(
            ["git", "commit", "-m", message],
            log_callback
        )
        if code != 0:
            combined = (commit_out + "\n" + commit_err).lower()
            if "nothing to commit" in combined:
                log_callback("INFO: Nothing to commit after git add.\n")
            else:
                log_callback("ERROR: git commit failed.\n")
                return False

        log_callback("Running: git push\n")
        code, _, _ = self._run_git(["git", "push"], log_callback)
        if code != 0:
            log_callback("ERROR: git push failed.\n")
            return False

        log_callback("SUCCESS: Commit & push completed.\n")
        return True

    def push_only(self, log_callback=None) -> bool:
        """Execute: git push."""
        if log_callback is None:
            log_callback = lambda s: None

        if not self.is_git_available():
            log_callback("ERROR: Git not found on PATH.\n")
            return False

        if not self.is_valid_repo():
            log_callback("ERROR: Selected folder is not a valid Git repository.\n")
            return False

        log_callback("Running: git push\n")
        code, _, _ = self._run_git(["git", "push"], log_callback)
        if code != 0:
            log_callback("ERROR: git push failed.\n")
            return False

        log_callback("SUCCESS: Push completed.\n")
        return True


# ==============================================================================
# 2. GUI LAYER (The Visual Cortex)
# ==============================================================================

class GitCommitGUI:
    """
    Small dark-themed Tk GUI for commit + push operations.
    """
    def __init__(self, root, engine: GitOpsEngine):
        self.root = root
        self.engine = engine

        self.root.title("Git Commit & Push Helper")
        self.root.geometry("600x260")
        self.root.configure(bg="#050505")
        self.root.resizable(False, False)

        # --- FONTS ---
        self.f_mono = font.Font(family="Consolas", size=10)
        self.f_ui = font.Font(family="Segoe UI", size=9)

        # --- STATE ---
        self.repo_var = tk.StringVar(value=self.engine.repo_path)
        self.msg_var = tk.StringVar(value="")

        # --- Recursion UX state ---
        self._self_repo_root = find_git_root(Path(__file__).resolve().parent)
        self._self_repo_note_shown_for = None  # normalized path or None
        self._autofill_message = "Self-test / recursion check"

        self._build_ui()

        # React to repo path edits (manual typing or folder picker)
        self.repo_var.trace_add("write", self._on_repo_change)

        # Apply initial self-repo behavior on startup (if launching in repo root)
        self._on_repo_change()

    # UI Construction ----------------------------------------------------------

    def _build_ui(self):
        self.status_var = tk.StringVar(value="Ready.")
        status_label = tk.Label(
            self.root,
            textvariable=self.status_var,
            bg="#222222",
            fg="#888888",
            bd=1,
            relief=tk.SUNKEN,
            anchor="w",
            font=self.f_ui
        )
        status_label.pack(side=tk.BOTTOM, fill=tk.X)

        container = tk.Frame(self.root, bg="#050505")
        container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # REPO ROW
        repo_frame = tk.Frame(container, bg="#050505")
        repo_frame.pack(fill=tk.X, pady=(0, 8))

        tk.Label(repo_frame, text="Repository:", bg="#050505", fg="#f0f0f0", font=self.f_ui).pack(side=tk.LEFT)

        tk.Entry(
            repo_frame,
            textvariable=self.repo_var,
            bg="#111111",
            fg="#f0f0f0",
            insertbackground="#f0f0f0",
            relief="flat",
            highlightthickness=1,
            highlightbackground="#444444",
            font=self.f_mono
        ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(8, 4))

        tk.Button(
            repo_frame,
            text="â€¦",
            width=3,
            bg="#333333",
            fg="#f0f0f0",
            activebackground="#555555",
            activeforeground="#ffffff",
            relief="flat",
            command=self._browse_repo
        ).pack(side=tk.LEFT)

        # COMMIT MESSAGE ROW
        msg_frame = tk.Frame(container, bg="#050505")
        msg_frame.pack(fill=tk.X, pady=(0, 8))

        tk.Label(msg_frame, text="Commit message:", bg="#050505", fg="#f0f0f0", font=self.f_ui).pack(side=tk.LEFT)

        entry_msg = tk.Entry(
            msg_frame,
            textvariable=self.msg_var,
            bg="#111111",
            fg="#f0f0f0",
            insertbackground="#f0f0f0",
            relief="flat",
            highlightthickness=1,
            highlightbackground="#444444",
            font=self.f_mono
        )
        entry_msg.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(8, 0))
        entry_msg.bind("<Return>", self._on_commit_push)

        # BUTTON ROW
        btn_frame = tk.Frame(container, bg="#050505")
        btn_frame.pack(fill=tk.X, pady=(0, 8))

        self.btn_commit = tk.Button(
            btn_frame,
            text="Commit & Push",
            bg="#333333",
            fg="#f0f0f0",
            activebackground="#555555",
            activeforeground="#ffffff",
            relief="flat",
            command=self._on_commit_push
        )
        self.btn_commit.pack(side=tk.LEFT)

        tk.Button(
            btn_frame,
            text="Close",
            bg="#333333",
            fg="#f0f0f0",
            activebackground="#555555",
            activeforeground="#ffffff",
            relief="flat",
            command=self.root.destroy
        ).pack(side=tk.RIGHT)

        # LOG AREA
        log_frame = tk.Frame(container, bg="#050505")
        log_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(log_frame, text="Log:", bg="#050505", fg="#f0f0f0", font=self.f_ui).pack(anchor="w")

        self.txt_log = tk.Text(
            log_frame,
            height=6,
            bg="#101010",
            fg="#f0f0f0",
            insertbackground="#f0f0f0",
            relief="flat",
            highlightthickness=1,
            highlightbackground="#444444",
            wrap="word",
            font=self.f_mono
        )
        self.txt_log.pack(fill=tk.BOTH, expand=True)

        self._log("Git Commit & Push Helper ready.\n")

    # Helpers ------------------------------------------------------------------

    def _browse_repo(self):
        initial = self.repo_var.get() or os.getcwd()
        folder = filedialog.askdirectory(initialdir=initial)
        if folder:
            self.repo_var.set(folder)

    def _log(self, text: str):
        self.txt_log.configure(state="normal")
        self.txt_log.insert("end", text)
        if not text.endswith("\n"):
            self.txt_log.insert("end", "\n")
        self.txt_log.see("end")
        self.txt_log.configure(state="disabled")

    def _update_status(self, text: str):
        self.status_var.set(text)
        self.root.update_idletasks()

    # Recursion UX -------------------------------------------------------------

    def _is_self_repo_selected(self) -> bool:
        """
        True if the selected repo (or its git root) equals this script's repo root.
        """
        if not self._self_repo_root:
            return False

        selected = self.repo_var.get().strip()
        if not selected:
            return False

        selected_root = find_git_root(selected)
        if not selected_root:
            return False

        return _norm_path(selected_root) == _norm_path(self._self_repo_root)

    def _on_repo_change(self, *_):
        """
        Triggered when repo_var changes. Handles:
        - Logging a note if operating on its own repo (informational only).
        - Autofilling commit message gracefully.
        """
        if self._is_self_repo_selected():
            norm_self = _norm_path(self._self_repo_root)
            if self._self_repo_note_shown_for != norm_self:
                self._log("NOTE: Self-repo detected (operating on this tool's own repository).\n")
                self._self_repo_note_shown_for = norm_self
                self._update_status("Self-repo detected.")

            # Autofill only if helpful (don't override custom messages)
            current_msg = self.msg_var.get().strip()
            if current_msg == "" or current_msg == self._autofill_message:
                self.msg_var.set(self._autofill_message)
        else:
            self._update_status("Ready.")

    # Main action --------------------------------------------------------------

    def _on_commit_push(self, event=None):
        self.txt_log.configure(state="normal")
        self.txt_log.delete("1.0", "end")
        self.txt_log.configure(state="disabled")

        repo = self.repo_var.get().strip()
        msg = self.msg_var.get().strip()
        self.engine.repo_path = repo

        def log_cb(s: str):
            self._log(s)

        if not self.engine.is_git_available():
            messagebox.showerror("Error", "Git is not available on PATH.")
            self._log("ERROR: Git not found on PATH.\n")
            self._update_status("Error: git missing.")
            return

        if not repo or not os.path.isdir(repo):
            messagebox.showerror("Error", "Repository folder does not exist.")
            self._log("ERROR: Invalid repository path.\n")
            self._update_status("Error: invalid repo path.")
            return

        if not self.engine.is_valid_repo():
            messagebox.showerror("Error", "Selected folder is not a Git repository (missing .git).")
            self._log("ERROR: No .git directory found in selected folder.\n")
            self._update_status("Error: not a git repo.")
            return

        if not msg:
            messagebox.showwarning("Missing commit message", "Please enter a commit message.")
            self._log("WARNING: Commit message is empty.\n")
            self._update_status("Awaiting commit message.")
            return

        # .gitignore HITL
        if not self.engine.has_gitignore():
            self._log("WARNING: No .gitignore detected.\n")
            proceed = messagebox.askyesno(
                "No .gitignore found",
                "No .gitignore file detected.\n\n"
                "This will add and commit ALL files, including build artifacts, virtualenvs, etc.\n\n"
                "Continue anyway?"
            )
            if not proceed:
                self._log("User aborted: no .gitignore present.\n")
                self._update_status("Aborted (no .gitignore).")
                return

        self._log(f"Using repo: {repo}\n")
        self._log(f"Commit message: {msg}\n")
        self._log("-" * 40 + "\n")

        self.btn_commit.configure(state="disabled")
        self._update_status("Running git operations...")

        try:
            status_out = self.engine.get_status_porcelain(log_cb)
            if status_out is None:
                messagebox.showerror("Error", "Failed to run 'git status'. See log for details.")
                self._update_status("Error: git status failed.")
                return

            if not status_out.strip():
                self._log("No local changes detected (working tree clean).\n")
                push_anyway = messagebox.askyesno(
                    "No changes to commit",
                    "No changes detected to commit.\n\n"
                    "Do you still want to run 'git push'?"
                )
                if not push_anyway:
                    self._log("User aborted: no changes to commit; push skipped.\n")
                    self._update_status("Aborted (nothing to commit).")
                    return

                success = self.engine.push_only(log_cb)
                if success:
                    messagebox.showinfo("Success", "Push completed successfully (no new commit).")
                    self._update_status("Push complete (no new commit).")
                else:
                    messagebox.showerror("Push failed", "git push failed. See log for details.")
                    self._update_status("Push failed.")
                return

            success = self.engine.commit_and_push(
                message=msg,
                allow_without_gitignore=True,
                log_callback=log_cb
            )

            if success:
                messagebox.showinfo("Success", "Commit & push completed successfully.")
                self._update_status("Commit & push complete.")
            else:
                messagebox.showerror("Error", "Commit and/or push failed. See log for details.")
                self._update_status("Commit/push failed.")
        finally:
            self.btn_commit.configure(state="normal")


# ==============================================================================
# 3. CLI LAYER (Utility)
# ==============================================================================

def run_cli():
    parser = argparse.ArgumentParser(description="Git Commit & Push Helper CLI")
    parser.add_argument("-r", "--repo", default=os.getcwd(), help="Path to the Git repository.")
    parser.add_argument("-m", "--message", required=True, help="Commit message.")
    parser.add_argument("--force-without-gitignore", action="store_true",
                        help="Allow commit/push even if .gitignore is missing.")
    parser.add_argument("--push-only", action="store_true", help="Skip commit and just run git push.")

    args = parser.parse_args()
    engine = GitOpsEngine(repo_path=args.repo)

    def log_cb(s: str):
        sys.stdout.write(s)
        if not s.endswith("\n"):
            sys.stdout.write("\n")
        sys.stdout.flush()

    if not engine.is_git_available():
        print("ERROR: Git is not available on PATH.", file=sys.stderr)
        sys.exit(1)

    if not engine.is_valid_repo():
        print("ERROR: Selected folder is not a Git repository (missing .git).", file=sys.stderr)
        sys.exit(1)

    if args.push_only:
        ok = engine.push_only(log_cb)
        sys.exit(0 if ok else 1)

    if not args.force_without_gitignore and not engine.has_gitignore():
        print("ERROR: No .gitignore found. Use --force-without-gitignore to override.", file=sys.stderr)
        sys.exit(1)

    ok = engine.commit_and_push(
        message=args.message,
        allow_without_gitignore=args.force_without_gitignore,
        log_callback=log_cb
    )
    sys.exit(0 if ok else 1)


# ==============================================================================
# 4. ENTRY POINT
# ==============================================================================

def run_gui():
    engine = GitOpsEngine()
    root = tk.Tk()
    GitCommitGUI(root, engine)
    root.mainloop()

def main():
    if len(sys.argv) > 1:
        run_cli()
    else:
        run_gui()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: _GitPUSHER\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _LocalMIND\.gitignore
--------------------------------------------------------------------------------
# --- Python ---
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# --- Virtual Env ---
venv/
.venv/
env/
ENV/

# --- IDEs ---
.idea/
.vscode/
*.swp
*.swo

# --- LocalMIND Data (DO NOT COMMIT) ---
# The Agent's Memory & Identity
localmind.db

# The RAG Vector Store
chroma_db/

# Cortex Cartridges & SQLite files
*.db
*.db-shm
*.db-wal
*.sqlite
*.sqlite3

# --- OS Junk ---
.DS_Store
Thumbs.db
--------------------------------------------------------------------------------
FILE: _LocalMIND\gitpush.bat
--------------------------------------------------------------------------------
@echo off
REM Usage: gitpush "your commit message"

IF "%~1"=="" (
    echo Commit message required.
    echo Example: gitpush "Updated UI layout"
    exit /b 1
)

git add .
git commit -m "%~1"
git push

--------------------------------------------------------------------------------
FILE: _LocalMIND\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _LocalMIND\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _LocalMIND\requirements.txt
--------------------------------------------------------------------------------
fastapi
uvicorn
chromadb
ollama
pydantic
--------------------------------------------------------------------------------
FILE: _LocalMIND\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _LocalMIND\src\app.py
--------------------------------------------------------------------------------
import sys
import os
import json
import sqlite3
import threading
import uuid
import datetime
import math
import struct
import difflib
import tkinter as tk
from tkinter import ttk, scrolledtext, simpledialog, messagebox, filedialog

# --- OPTIONAL AI DEPENDENCIES ---
try:
    import ollama
    import chromadb
    AI_AVAILABLE = True
except ImportError:
    AI_AVAILABLE = False
    print("WARNING: 'ollama' or 'chromadb' not found. AI features will be disabled.")

# ==============================================================================
# 1. CORE ENGINES (The Backend Logic)
# ==============================================================================

class CortexLink:
    """
    The Bridge: Connects _LocalMIND to a _NeoCORTEX Knowledge Base (.db).
    Acts as a read-only neural interface for the Reference Shelf.
    """
    def __init__(self, db_path):
        self.db_path = db_path
        self.name = os.path.basename(db_path)
        self.config = self._load_manifest()
        
    def _load_manifest(self):
        """Handshake: Checks what model this brain uses."""
        meta = {}
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            # Check if manifest table exists first
            try:
                rows = cursor.execute("SELECT key, value FROM manifest").fetchall()
                for k, v in rows: meta[k] = v
            except sqlite3.OperationalError:
                meta['error'] = "No Manifest Found"
            conn.close()
        except Exception as e:
            print(f"[{self.name}] Connection Error: {e}")
        return meta

    def query(self, query_vector, limit=5):
        """
        Performs a vector search against this specific brain.
        Uses pure Python Cosine Similarity for portability.
        """
        results = []
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Fetch all chunks (Brute force for V1 reliability)
            # In V2, we can optimize with spatial indices if available
            cursor.execute("SELECT c.id, f.path, c.content, c.embedding FROM chunks c JOIN files f ON c.file_id = f.id")
            
            candidates = []
            for row in cursor.fetchall():
                _, path, content, blob = row
                if not blob: continue
                
                try:
                    # Flexible Deserialization (JSON or Binary)
                    try:
                        vec = json.loads(blob)
                    except:
                        vec = struct.unpack(f'{len(query_vector)}f', blob)
                    
                    score = self._cosine_sim(query_vector, vec)
                    candidates.append((score, path, content))
                except Exception:
                    continue
            
            # Sort and Slice
            candidates.sort(key=lambda x: x[0], reverse=True)
            results = candidates[:limit]
            conn.close()
            
        except Exception as e:
            print(f"[{self.name}] Query Error: {e}")
            
        return results

    def _cosine_sim(self, v1, v2):
        dot = sum(a*b for a,b in zip(v1, v2))
        norm_a = math.sqrt(sum(a*a for a in v1))
        norm_b = math.sqrt(sum(b*b for b in v2))
        return dot / (norm_a * norm_b) if norm_a and norm_b else 0.0

    # --- CURATION TOOLS ---
    def list_files(self):
        try:
            conn = sqlite3.connect(self.db_path)
            rows = conn.execute("SELECT path FROM files ORDER BY path").fetchall()
            conn.close()
            return [r[0] for r in rows]
        except: return []

    def get_content(self, path):
        try:
            conn = sqlite3.connect(self.db_path)
            row = conn.execute("SELECT content FROM files WHERE path=?", (path,)).fetchone()
            conn.close()
            return row[0] if row else None
        except: return None

    def update_file(self, path, new_content, author="_LocalMIND"):
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # 1. Get Old Content
            row = cursor.execute("SELECT content FROM files WHERE path=?", (path,)).fetchone()
            if not row:
                # New File Mode
                cursor.execute("INSERT INTO files (path, content, last_updated) VALUES (?,?,?)", (path, new_content, datetime.datetime.now()))
                self._log_diff(cursor, path, "CREATE", "[New File]", author)
            else:
                # Edit Mode
                old = row['content'] or ""
                diff = self._compute_diff(path, old, new_content)
                if not diff: return False # No changes
                
                self._log_diff(cursor, path, "EDIT", diff, author)
                cursor.execute("UPDATE files SET content=?, last_updated=? WHERE path=?", (new_content, datetime.datetime.now(), path))
                
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Update Error: {e}")
            return False

    def _compute_diff(self, path, old, new):
        diff = difflib.unified_diff(old.splitlines(keepends=True), new.splitlines(keepends=True), fromfile=f"a/{path}", tofile=f"b/{path}")
        return "".join(diff)

    def _log_diff(self, cursor, path, type_, diff_blob, author):
        did = str(uuid.uuid4())
        cursor.execute("INSERT INTO diff_log (id, file_path, timestamp, change_type, diff_blob, author) VALUES (?,?,?,?,?,?)", (did, path, datetime.datetime.now(), type_, diff_blob, author))

class IdentityEngine:
    """
    The Agent Manager: Handles 'Roles' (System Prompts) and Personas.
    """
    def __init__(self, db_path):
        self.db_path = db_path
        self._init_roles()

    def _init_roles(self):
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS roles (
            id TEXT PRIMARY KEY, name TEXT UNIQUE, system_prompt TEXT, description TEXT
        )''')
        
        # Seed Defaults
        if c.execute("SELECT count(*) FROM roles").fetchone()[0] == 0:
            defaults = [
                ("gen", "Generalist", "You are a helpful, precise assistant.", "Standard helpful AI."),
                ("curator", "Data Curator", "You are a Data Curation Expert. Your job is to read provided context, identify errors, consistency issues, or outdated information, and propose exact edits. Be extremely rigorous.", "Specialist for cleaning datasets."),
                ("librarian", "Meta-Librarian", "You are the manager of the Reference Shelf. You help the user decide which data sources to mount and how to organize them.", "Helps organize the books.")
            ]
            c.executemany("INSERT INTO roles (id, name, system_prompt, description) VALUES (?,?,?,?)", defaults)
            conn.commit()
        conn.close()

    def get_roles(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        rows = conn.execute("SELECT * FROM roles").fetchall()
        conn.close()
        return [dict(r) for r in rows]

    def create_role(self, name, prompt, description):
        rid = str(uuid.uuid4())[:8]
        conn = sqlite3.connect(self.db_path)
        try:
            conn.execute("INSERT INTO roles (id, name, system_prompt, description) VALUES (?,?,?,?)", (rid, name, prompt, description))
            conn.commit()
            return rid
        except sqlite3.IntegrityError:
            return None
        finally:
            conn.close()

    def get_role(self, role_id):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        row = conn.execute("SELECT * FROM roles WHERE id = ?", (role_id,)).fetchone()
        conn.close()
        return dict(row) if row else None

class ReferenceShelf:
    """
    The Bookshelf: Manages mounted _NeoCORTEX databases.
    """
    def __init__(self):
        self.mounted_books = {} # {path: CortexLink}

    def mount(self, db_path):
        if db_path in self.mounted_books: return
        link = CortexLink(db_path)
        self.mounted_books[db_path] = link

    def unmount(self, db_path):
        if db_path in self.mounted_books:
            del self.mounted_books[db_path]

    def search_library(self, query_vec, limit=3):
        """Aggregates knowledge from ALL mounted books."""
        results = []
        for book in self.mounted_books.values():
            hits = book.query(query_vec, limit=limit)
            for score, path, content in hits:
                results.append((score, path, content, book.name))
        
        # Global Rank
        results.sort(key=lambda x: x[0], reverse=True)
        return results[:5] # Top 5 across all books

class WorkflowEngine:
    """
    The Processor: Orchestrates the Task List (Identity + Shelf -> Inference).
    """
    def __init__(self, backend):
        self.backend = backend

    def run_workflow(self, task, user_prompt, role_id):
        """Dispatcher for different task types."""
        if task == "Summarize":
            return self._run_helper_task(user_prompt, "You are a highly efficient summarizer. Condense the user input into a concise summary.")
        elif task == "Audit":
            return self._run_helper_task(user_prompt, "You are a data auditor. Check the following input for logical inconsistencies, errors, or security risks. Report only valid issues.")
        elif task == "Extract Entities":
            return self._run_helper_task(user_prompt, "Extract all named entities (People, Organizations, Locations, File Paths) from the text as a JSON list.")
        else:
            # Default: Chat
            return self._run_chat_workflow(user_prompt, role_id)

    def _run_helper_task(self, user_prompt, system_instruction):
        """Runs a task using the lightweight Helper Model."""
        model = self.backend.helper_model
        return self._inference(model, user_prompt, system_instruction)

    def _run_chat_workflow(self, user_prompt, role_id):
        """Runs the main Chat Workflow using the Active Model and RAG."""
        model = self.backend.active_model
        
        # 1. IDENTITY
        role = self.backend.identity.get_role(role_id)
        sys_prompt = role['system_prompt'] if role else "You are a helpful assistant."

        # 2. REFERENCE (The Shelf) - RAG Only on Main Chat for now
        context_str = ""
        if self.backend.shelf.mounted_books and AI_AVAILABLE:
            try:
                # Get Vector
                emb_resp = ollama.embeddings(model=model, prompt=user_prompt)
                q_vec = emb_resp['embedding']
                
                # Search
                hits = self.backend.shelf.search_library(q_vec)
                
                if hits:
                    context_str = "\n\n### REFERENCE SHELF DATA ###\n"
                    for score, path, content, book_name in hits:
                        context_str += f"[BOOK: {book_name} | SOURCE: {os.path.basename(path)}]\n{content[:600]}...\n"
            except Exception as e:
                print(f"Workflow Retrieval Error: {e}")

        # 3. SYNTHESIS
        full_system = f"{sys_prompt}{context_str}"
        
        # 4. INFERENCE
        return self._inference(model, user_prompt, full_system)

    def _inference(self, model, prompt, system_prompt):
        if not AI_AVAILABLE: return "AI Offline."
        try:
            res = ollama.chat(
                model=model,
                messages=[
                    {'role': 'system', 'content': system_prompt},
                    {'role': 'user', 'content': prompt}
                ]
            )
            return res['message']['content']
        except Exception as e:
            return f"Inference Error: {e}"

class LocalMindBackend:
    def __init__(self, root_dir):
        self.root_dir = root_dir
        self.db_path = os.path.join(root_dir, "localmind.db")
        
        # Init Main DB
        self._init_sqlite()
        
        # Init Engines
        self.identity = IdentityEngine(self.db_path)
        self.shelf = ReferenceShelf()
        self.workflow = WorkflowEngine(self)
        
        # Global State (defaults)
        self.active_model = "llama3"
        self.helper_model = "llama3"

    def _init_sqlite(self):
        conn = sqlite3.connect(self.db_path)
        # Chat History Table
        conn.execute('''CREATE TABLE IF NOT EXISTS chats (
            id INTEGER PRIMARY KEY AUTOINCREMENT, session_id TEXT, 
            role TEXT, content TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )''')
        # Projects Table
        conn.execute('''CREATE TABLE IF NOT EXISTS projects (
            id TEXT PRIMARY KEY, name TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )''')
        conn.commit()
        conn.close()

    def get_models(self):
        if not AI_AVAILABLE: return []
        try:
            res = ollama.list()
            models = []
            # 1. Extract List
            if isinstance(res, dict) and 'models' in res: models = res['models']
            elif isinstance(res, list): models = res
            elif hasattr(res, 'models'): models = res.models
            
            # 2. Extract Names
            names = []
            for m in models:
                if isinstance(m, dict): names.append(m.get('name') or m.get('model'))
                else: names.append(getattr(m, 'model', getattr(m, 'name', None)))
            return [n for n in names if n]
        except Exception as e:
            print(f"Ollama Connect Error: {e}")
            return []

    def save_chat(self, role, content, session="default"):
        conn = sqlite3.connect(self.db_path)
        conn.execute("INSERT INTO chats (session_id, role, content) VALUES (?,?,?)", (session, role, content))
        conn.commit()
        conn.close()

    def clear_history(self, session="default"):
        conn = sqlite3.connect(self.db_path)
        conn.execute("DELETE FROM chats WHERE session_id=?", (session,))
        conn.commit()
        conn.close()

    def get_history(self, session="default"):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        rows = conn.execute("SELECT role, content FROM chats WHERE session_id=? ORDER BY id ASC", (session,)).fetchall()
        conn.close()
        return [dict(r) for r in rows]

    def create_empty_cartridge(self, path):
        """Mints a new, empty _NeoCORTEX compatible .db (Full Schema)"""
        if os.path.exists(path): return False
        try:
            conn = sqlite3.connect(path)
            cursor = conn.cursor()
            
            # 1. Config & Graph
            cursor.execute("CREATE TABLE IF NOT EXISTS manifest (key TEXT PRIMARY KEY, value TEXT)")
            cursor.execute("CREATE TABLE IF NOT EXISTS graph_nodes (id TEXT PRIMARY KEY, type TEXT, label TEXT, data_json TEXT)")
            cursor.execute("CREATE TABLE IF NOT EXISTS graph_edges (source TEXT, target TEXT, weight REAL)")

            # 2. Files (Provenance & Content)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS files (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    path TEXT UNIQUE NOT NULL,
                    content TEXT,
                    origin_type TEXT DEFAULT 'manual',
                    origin_path TEXT,
                    vfs_path TEXT,
                    metadata TEXT DEFAULT '{}',
                    last_updated TIMESTAMP,
                    status TEXT DEFAULT 'indexed'
                )
            """)

            # 3. Chunks (Vectors)
            cursor.execute("""
            CREATE TABLE IF NOT EXISTS chunks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_id INTEGER,
                chunk_index INTEGER,
                content TEXT,
                embedding BLOB,
                name TEXT,
                type TEXT,
                start_line INTEGER,
                end_line INTEGER,
                FOREIGN KEY(file_id) REFERENCES files(id)
            )
            """)

            # 4. Diff Log (History)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS diff_log (
                    id TEXT PRIMARY KEY,
                    file_path TEXT NOT NULL,
                    timestamp TIMESTAMP,
                    change_type TEXT,
                    diff_blob TEXT,
                    author TEXT
                )
            """)

            # Stamp It
            cursor.execute("INSERT INTO manifest (key, value) VALUES (?, ?)", ("created_by", "_LocalMIND"))
            cursor.execute("INSERT INTO manifest (key, value) VALUES (?, ?)", ("schema_version", "1.1"))
            
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Creation Error: {e}")
            return False

# ==============================================================================
# 2. UI COMPONENTS (The Workbench)
# ==============================================================================

class Tooltip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tip = None
        widget.bind("<Enter>", self.show)
        widget.bind("<Leave>", self.hide)

    def show(self, event=None):
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        self.tip = tk.Toplevel(self.widget)
        self.tip.wm_overrideredirect(True)
        self.tip.wm_geometry(f"+{x}+{y}")
        tk.Label(self.tip, text=self.text, bg="#ffffe0", fg="black", font=("tahoma", 8), bd=1, relief="solid").pack()

    def hide(self, event=None):
        if self.tip: self.tip.destroy(); self.tip = None

class CartridgeBrowser(tk.Toplevel):
    """Popup to browse files inside a mounted DB"""
    def __init__(self, parent, cortex_link, on_select):
        super().__init__(parent)
        self.title(f"Browsing: {cortex_link.name}")
        self.geometry("500x400")
        self.configure(bg="#1e1e1e")
        self.on_select = on_select
        
        # Treeview
        self.tree = ttk.Treeview(self, show="tree", selectmode="browse")
        self.tree.pack(fill="both", expand=True, padx=10, pady=10)
        self.tree.bind("<Double-1>", self._on_double_click)
        
        # Populate
        files = cortex_link.list_files()
        self._build_tree(files)

    def _build_tree(self, paths):
        # Simple folder simulation from flat paths
        self.tree.delete(*self.tree.get_children())
        nodes = {}
        for p in paths:
            parts = p.split('/')
            parent = ""
            for i, part in enumerate(parts):
                current_path = "/".join(parts[:i+1])
                if current_path not in nodes:
                    if i == len(parts) - 1:
                        # It's a file
                        oid = self.tree.insert(parent, "end", text=f"ðŸ“„ {part}", values=(p,))
                    else:
                        # It's a folder
                        oid = self.tree.insert(parent, "end", text=f"ðŸ“ {part}", open=False)
                    nodes[current_path] = oid
                parent = nodes[current_path]

    def _on_double_click(self, event):
        item = self.tree.selection()
        if not item: return
        values = self.tree.item(item[0], 'values')
        if values: # It's a file
            self.on_select(values[0])
            self.destroy()

class DraftingPanel(tk.Frame):
    """LEFT COLUMN: Workspace / Document Editor"""
    def __init__(self, parent, backend):
        super().__init__(parent, bg="#1e293b", width=250)
        self.backend = backend
        self.pack_propagate(False)

        # Header
        tk.Label(self, text="WORKSPACE / DRAFTING", bg="#0f172a", fg="#94a3b8", font=("Arial", 8, "bold"), pady=5).pack(fill="x")
        
        # Toolbar
        toolbar = tk.Frame(self, bg="#1e293b", pady=5)
        toolbar.pack(fill="x", padx=5)
        # Local IO
        tk.Button(toolbar, text="ðŸ’¾ LOC", bg="#334155", fg="white", width=6, relief="flat", font=("Arial", 8), command=self.save_file).pack(side="left", padx=1)
        tk.Button(toolbar, text="ðŸ“‚ LOC", bg="#334155", fg="white", width=6, relief="flat", font=("Arial", 8), command=self.open_file).pack(side="left", padx=1)
        # Cartridge IO
        tk.Label(toolbar, text="|", bg="#1e293b", fg="#64748b").pack(side="left", padx=5)
        tk.Button(toolbar, text="ðŸ“¥ DB", bg="#0f766e", fg="white", width=6, relief="flat", font=("Arial", 8), command=self.load_from_db).pack(side="left", padx=1)
        tk.Button(toolbar, text="ðŸ“¤ DB", bg="#c2410c", fg="white", width=6, relief="flat", font=("Arial", 8), command=self.commit_to_db).pack(side="left", padx=1)
        
        # State
        self.active_db = None
        self.active_path = None
        
        # Editor
        self.editor = scrolledtext.ScrolledText(self, bg="#0f172a", fg="#cbd5e1", font=("Consolas", 10), insertbackground="white", bd=0)
        self.editor.pack(fill="both", expand=True, padx=5, pady=5)
        self.editor.insert("1.0", "# Scratchpad\nUse this space to curate findings or draft outputs...")

    def save_file(self):
        path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt"), ("Markdown", "*.md"), ("All", "*.*")])
        if path:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(self.editor.get("1.0", tk.END))

    def open_file(self):
        path = filedialog.askopenfilename(filetypes=[("Text", "*.txt"), ("Markdown", "*.md"), ("All", "*.*")])
        if path:
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            self.editor.delete("1.0", tk.END)
            self.editor.insert("1.0", content)

    def load_from_db(self):
        # 1. Select Cartridge (Simple List Selection)
        books = list(self.backend.shelf.mounted_books.values())
        if not books: 
            messagebox.showwarning("Shelf Empty", "Mount a cartridge first."); return
        
        # Create a simple modal to pick the book if multiple exist
        if len(books) == 1:
            target_book = books[0]
            self._open_browser(target_book)
        else:
            self._pick_book_modal(books)

    def _pick_book_modal(self, books):
        # Temporary modal to pick book
        top = tk.Toplevel(self)
        top.title("Select Cartridge")
        top.geometry("300x200")
        lb = tk.Listbox(top)
        lb.pack(fill="both", expand=True)
        for b in books: lb.insert("end", b.name)
        def confirm():
            sel = lb.curselection()
            if sel:
                target = books[sel[0]]
                top.destroy()
                self._open_browser(target)
        tk.Button(top, text="Open", command=confirm).pack(fill="x")

    def _open_browser(self, target_book):
        # 2. Open Tree Browser
        CartridgeBrowser(self, target_book, lambda path: self._load_file(target_book, path))

    def _load_file(self, book, path):
        content = book.get_content(path)
        if content:
            self.editor.delete("1.0", tk.END)
            self.editor.insert("1.0", content)
            self.active_db = book
            self.active_path = path
            # Update Header
            self.master.master.log(f"Editing: {path} [{book.name}]")

    def commit_to_db(self):
        if not self.active_db or not self.active_path:
            messagebox.showwarning("Error", "No active DB file loaded. Use 'Load DB' or Create New."); return
            
        content = self.editor.get("1.0", tk.END).strip()
        if self.active_db.update_file(self.active_path, content, author="User"):
            messagebox.showinfo("Success", "Changes committed to Cartridge Audit Log.")
        else:
            messagebox.showerror("Error", "Commit failed (No changes or DB locked).")

class ShelfPanel(tk.Frame):
    """RIGHT COLUMN: The Reference Library"""
    def __init__(self, parent, backend):
        super().__init__(parent, bg="#1e1e1e", width=250)
        self.backend = backend
        self.pack_propagate(False)

        # Header
        tk.Label(self, text="REFERENCE SHELF", bg="#000000", fg="#facc15", font=("Arial", 8, "bold"), pady=5).pack(fill="x")

        # Controls
        ctrl = tk.Frame(self, bg="#1e1e1e", pady=5)
        ctrl.pack(fill="x")
        
        # Row 1: Mount / Create
        row1 = tk.Frame(ctrl, bg="#1e1e1e")
        row1.pack(fill="x", padx=10, pady=2)
        tk.Button(row1, text="âž• MOUNT", bg="#334155", fg="white", width=10, relief="flat", command=self.mount_db).pack(side="left", fill="x", expand=True, padx=(0,2))
        tk.Button(row1, text="âœ¨ NEW CART", bg="#15803d", fg="white", width=10, relief="flat", command=self.create_db).pack(side="left", fill="x", expand=True, padx=(2,0))

        # List
        self.listbox = tk.Listbox(self, bg="#262626", fg="#d4d4d4", bd=0, highlightthickness=0)
        self.listbox.pack(fill="both", expand=True, padx=5, pady=5)

    def mount_db(self):
        path = filedialog.askopenfilename(title="Select _NeoCORTEX Cartridge", filetypes=[("SQLite DB", "*.db")])
        if path:
            self.backend.shelf.mount(path)
            self.refresh_list()

    def create_db(self):
        path = filedialog.asksaveasfilename(title="New Brain Cartridge", defaultextension=".db", filetypes=[("SQLite DB", "*.db")])
        if path:
            if self.backend.create_empty_cartridge(path):
                self.backend.shelf.mount(path)
                self.refresh_list()
            else:
                messagebox.showerror("Error", "Failed to create Cartridge.")

    def refresh_list(self):
        self.listbox.delete(0, tk.END)
        for path, link in self.backend.shelf.mounted_books.items():
            model = link.config.get('embed_model', 'Unknown')
            self.listbox.insert(tk.END, f"ðŸ“˜ {link.name} [{model}]")

class WorkbenchPanel(tk.Frame):
    """CENTER COLUMN: Chat & Task Execution"""
    def __init__(self, parent, backend):
        super().__init__(parent, bg="#0f172a")
        self.backend = backend
        self.current_role_id = "gen" # Default
        
        # Top Bar: Identity Controls
        top_bar = tk.Frame(self, bg="#0f172a", pady=5)
        top_bar.pack(fill="x")
        
        tk.Label(top_bar, text="ACTIVE PERSONA:", bg="#0f172a", fg="#64748b", font=("Arial", 8, "bold")).pack(side="left", padx=(10, 5))
        
        # Persona Dropdown
        self.role_var = tk.StringVar()
        self.role_combo = ttk.Combobox(top_bar, textvariable=self.role_var, state="readonly", width=30)
        self.role_combo.pack(side="left", padx=5)
        self.role_combo.bind("<<ComboboxSelected>>", self._on_role_select)
        
        # Create Role Button (+)
        self.btn_new_role = tk.Button(top_bar, text="+", bg="#334155", fg="white", relief="flat", width=3, command=self.create_new_role)
        self.btn_new_role.pack(side="left", padx=5)
        Tooltip(self.btn_new_role, "Create a new Agent Persona")

        # Settings Gear
        self.btn_config = tk.Button(top_bar, text="âš™", bg="#334155", fg="#cbd5e1", relief="flat", width=3, command=self.open_settings)
        self.btn_config.pack(side="left", padx=5)
        Tooltip(self.btn_config, "System Configuration")

        # Clear Session Button
        self.btn_clear = tk.Button(top_bar, text="ðŸ—‘ï¸", bg="#b91c1c", fg="white", relief="flat", width=3, command=self.clear_session)
        self.btn_clear.pack(side="right", padx=10)
        Tooltip(self.btn_clear, "Flush Chat History")

        # Split Center into Chat (Top) and System Log (Bottom)
        self.paned_center = tk.PanedWindow(self, orient="vertical", bg="#0f172a", sashwidth=4, sashrelief="flat")
        self.paned_center.pack(fill="both", expand=True)

        # 1. Chat Area
        self.display = scrolledtext.ScrolledText(self.paned_center, bg="#0f172a", fg="#e2e8f0", font=("Consolas", 10), state="disabled", padx=10, pady=10)
        self.display.tag_config("user", foreground="#60a5fa", justify="right")
        self.display.tag_config("assistant", foreground="#a78bfa", justify="left")
        self.paned_center.add(self.display, height=500)

        # 2. System Log Console
        log_frame = tk.Frame(self.paned_center, bg="#000000")
        tk.Label(log_frame, text="SYSTEM LOG", bg="#1e1e1e", fg="#64748b", font=("Arial", 7, "bold"), anchor="w").pack(fill="x")
        self.log_display = scrolledtext.ScrolledText(log_frame, bg="#0a0a0a", fg="#00ff00", font=("Consolas", 9), state="disabled", padx=5, pady=5)
        self.log_display.pack(fill="both", expand=True)
        self.paned_center.add(log_frame, height=150)

        # Input Area
        input_frame = tk.Frame(self, bg="#1e293b", height=80)
        input_frame.pack(fill="x", side="bottom")
        
        # Task Selector
        self.task_var = tk.StringVar(value="Chat")
        self.task_combo = ttk.Combobox(input_frame, textvariable=self.task_var, state="readonly", width=15)
        self.task_combo['values'] = ["Chat", "Summarize", "Audit", "Extract Entities"]
        self.task_combo.pack(side="left", padx=(5,0), pady=5, anchor="n")
        
        # Context Toggle
        self.use_context = tk.BooleanVar()
        self.chk_context = tk.Checkbutton(input_frame, text="Use Draft", variable=self.use_context, bg="#1e293b", fg="#94a3b8", selectcolor="#0f172a", activebackground="#1e293b", activeforeground="white", font=("Arial", 8))
        self.chk_context.pack(side="left", padx=5, pady=5, anchor="n")
        
        self.draft_panel = None # To be linked

        self.txt_input = tk.Text(input_frame, height=4, bg="#334155", fg="white", font=("Consolas", 10), insertbackground="white")
        self.txt_input.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        self.txt_input.bind("<Return>", self._on_enter)
        
        btn_send = tk.Button(input_frame, text="RUN >", bg="#6366f1", fg="white", font=("Arial", 10, "bold"), relief="flat", command=self.run_task)
        btn_send.pack(side="right", fill="y", padx=5, pady=5)
        
        # Initialize Roles & History
        self.refresh_roles()
        self.refresh_history()

    def link_draft(self, panel):
        self.draft_panel = panel

    def refresh_roles(self):
        self.roles = self.backend.identity.get_roles()
        self.role_combo['values'] = [r['name'] for r in self.roles]
        if self.roles:
            self.role_combo.current(0)
            self._on_role_select(None)

    def _on_role_select(self, event):
        name = self.role_var.get()
        role = next((r for r in self.roles if r['name'] == name), None)
        if role:
            self.current_role_id = role['id']
            self._log_system(f"Persona switched to: {role['name']}")

    def clear_session(self):
        if messagebox.askyesno("Clear Session", "Flush current chat history? This cannot be undone."):
            self.backend.clear_history()
            self.refresh_history()
            self._log_system("Session Flushed.")

    def open_settings(self):
        SettingsModal(self, self.backend)

    def create_new_role(self):
        name = simpledialog.askstring("New Persona", "Name of Role (e.g., 'Python Expert')")
        if not name: return
        prompt = simpledialog.askstring("New Persona", "System Prompt (Instructions)")
        if not prompt: return
        desc = simpledialog.askstring("New Persona", "Short Description")
        
        rid = self.backend.identity.create_role(name, prompt, desc)
        if rid:
            self.refresh_roles()
            self.role_combo.set(name)
            self._on_role_select(None)
            messagebox.showinfo("Success", "New Persona Created.")
        else:
            messagebox.showerror("Error", "Could not create role (Name might be duplicate).")

    def _log_system(self, msg):
        ts = datetime.datetime.now().strftime('%H:%M:%S')
        self.log_display.config(state="normal")
        self.log_display.insert("end", f"[{ts}] {msg}\n")
        self.log_display.see("end")
        self.log_display.config(state="disabled")

    def _on_enter(self, event):
        if not event.state & 0x0001:
            self.run_task()
            return "break"

    def refresh_history(self):
        self.display.config(state="normal")
        self.display.delete("1.0", "end")
        for msg in self.backend.get_history():
            tag = "user" if msg['role'] == 'user' else "assistant"
            self.display.insert("end", f"\n{msg['role'].upper()}:\n{msg['content']}\n", tag)
            self.display.insert("end", "-"*40, "sys")
        self.display.see("end")
        self.display.config(state="disabled")

    def run_task(self):
        prompt = self.txt_input.get("1.0", "end").strip()
        
        # Handle Context Injection
        if self.use_context.get() and self.draft_panel:
            draft_text = self.draft_panel.editor.get("1.0", "end").strip()
            if draft_text:
                # If prompt is empty (e.g. just running 'Summarize'), provide a default
                if not prompt: prompt = "[Process this document]"
                prompt = f"{prompt}\n\n--- DRAFT CONTEXT ---\n{draft_text}"
        
        if not prompt: return
        
        task = self.task_var.get()
        
        self.txt_input.delete("1.0", "end")
        self.backend.save_chat("user", prompt)
        self.refresh_history()
        
        # Run in thread
        threading.Thread(target=self._worker, args=(prompt, task), daemon=True).start()

    def _worker(self, prompt, task):
        # Route via Workflow Engine
        response = self.backend.workflow.run_workflow(task, prompt, self.current_role_id)
        self.backend.save_chat("assistant", response)
        self.after(0, self.refresh_history)

class SettingsModal(tk.Toplevel):
    def __init__(self, parent, backend):
        super().__init__(parent)
        self.title("System Config")
        self.geometry("400x300")
        self.configure(bg="#1e1e1e")
        self.backend = backend
        
        tk.Label(self, text="NEURAL CONFIGURATION", bg="#1e1e1e", fg="#facc15", font=("Arial", 10, "bold")).pack(pady=10)
        
        # Model Selection
        tk.Label(self, text="Inference Model (Architect):", bg="#1e1e1e", fg="#94a3b8").pack(anchor="w", padx=20)
        self.model_var = tk.StringVar()
        self.model_combo = ttk.Combobox(self, textvariable=self.model_var)
        self.model_combo.pack(fill="x", padx=20, pady=(0, 10))
        
        tk.Label(self, text="Helper Model (Summarizer):", bg="#1e1e1e", fg="#94a3b8").pack(anchor="w", padx=20)
        self.helper_var = tk.StringVar()
        self.helper_combo = ttk.Combobox(self, textvariable=self.helper_var)
        self.helper_combo.pack(fill="x", padx=20, pady=(0, 20))
        
        # Populate
        models = self.backend.get_models()
        if models:
            self.model_combo['values'] = models
            self.helper_combo['values'] = models
            self.model_var.set(models[0])
            if len(models) > 1: self.helper_var.set(models[1])
            else: self.helper_var.set(models[0])
            
        # Set current from backend if available
        if self.backend.active_model in models: self.model_var.set(self.backend.active_model)
        
        tk.Button(self, text="SAVE & CLOSE", bg="#15803d", fg="white", command=self.save_and_close).pack(pady=20)

    def save_and_close(self):
        self.backend.active_model = self.model_var.get()
        self.backend.helper_model = self.helper_var.get()
        self.destroy()

# ==============================================================================
# 3. MAIN APP
# ==============================================================================

class LocalMindApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("_LocalMIND v0.5 [Workbench]")
        self.root.geometry("1400x900")
        self.root.configure(bg="#0f172a")

        self.backend = LocalMindBackend(os.getcwd())

        # Main Layout: 3 Columns
        self.panes = tk.PanedWindow(self.root, orient="horizontal", bg="#0f172a", sashwidth=4, sashrelief="flat")
        self.panes.pack(fill="both", expand=True)

        # --- INSTANTIATION ---
        # Panels are now mostly independent due to backend state sharing
        self.draft_panel = DraftingPanel(self.panes, self.backend)
        self.work_panel = WorkbenchPanel(self.panes, self.backend)
        self.work_panel.link_draft(self.draft_panel) # Link for Context Access
        self.shelf_panel = ShelfPanel(self.panes, self.backend)

        # --- LAYOUT (Visual Order: Left -> Right) ---
        self.panes.add(self.draft_panel, width=300)
        self.panes.add(self.work_panel, width=700)
        self.panes.add(self.shelf_panel, width=400)

        # Status Bar
        self.status_var = tk.StringVar(value="System Ready.")
        self.status_bar = tk.Label(self.root, textvariable=self.status_var, bg="#0f172a", fg="#64748b", font=("Consolas", 8), anchor="w", padx=10, pady=2)
        self.status_bar.pack(side="bottom", fill="x")

    def log(self, msg):
        self.status_var.set(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] {msg}")
        self.root.update_idletasks()

    # on_role_change is deprecated/handled internally

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = LocalMindApp()
    app.run()







--------------------------------------------------------------------------------
FILE: _LocalMIND\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\library_manager.py
--------------------------------------------------------------------------------

import json
import sys
from pathlib import Path

# Add self to path to allow importing the internal registry service
sys.path.append(str(Path(__file__).parent))

def refresh_registry():
    print("Scanning services...")
    # This will eventually call _ServiceRegistryMS
    pass

if __name__ == "__main__":
    refresh_registry()

--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\core\microservice_std_lib.py
--------------------------------------------------------------------------------
"""
LIBRARY: Microservice Standard Lib
VERSION: 2.0.0
ROLE: Provides decorators for tagging Python classes as AI-discoverable services.
"""

import functools
import inspect
from typing import Dict, List, Any, Optional, Type

# ==============================================================================
# DECORATORS (The "Writer" Tools)
# ==============================================================================

def service_metadata(name: str, version: str, description: str, tags: List[str], capabilities: List[str] = None):
    """
    Class Decorator.
    Labels a Microservice class with high-level metadata for the Catalog.
    """
    def decorator(cls):
        cls._is_microservice = True
        cls._service_info = {
            "name": name,
            "version": version,
            "description": description,
            "tags": tags,
            "capabilities": capabilities or []
        }
        return cls
    return decorator

def service_endpoint(inputs: Dict[str, str], outputs: Dict[str, str], description: str, tags: List[str] = None, side_effects: List[str] = None, mode: str = "sync"):
    """
    Method Decorator.
    Defines the 'Socket' that the AI Architect can plug into.
    
    :param inputs: Dict of {arg_name: type_string} (e.g. {"query": "str"})
    :param outputs: Dict of {return_name: type_string} (e.g. {"results": "List[Dict]"})
    :param description: What this specific function does.
    :param tags: Keywords for searching (e.g. ["search", "read-only"])
    :param side_effects: List of impact types (e.g. ["network:outbound", "disk:write"])
    :param mode: 'sync', 'async', or 'ui_event'
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        
        # Attach metadata to the function object itself
        wrapper._endpoint_info = {
            "name": func.__name__,
            "inputs": inputs,
            "outputs": outputs,
            "description": description,
            "tags": tags or [],
            "side_effects": side_effects or [],
            "mode": mode
        }
        return wrapper
    return decorator

# ==============================================================================
# INTROSPECTION (The "Reader" Tools)
# ==============================================================================

def extract_service_schema(service_cls: Type) -> Dict[str, Any]:
    """
    Scans a decorated Service Class and returns a JSON-serializable schema 
    of its metadata and all its exposed endpoints.
    
    This is what the AI Agent uses to 'read' the manual.
    """
    if not getattr(service_cls, "_is_microservice", False):
        raise ValueError(f"Class {service_cls.__name__} is not decorated with @service_metadata")

    schema = {
        "meta": getattr(service_cls, "_service_info", {}),
        "endpoints": []
    }

    # Inspect all methods of the class
    for name, method in inspect.getmembers(service_cls, predicate=inspect.isfunction):
        # Unwrap decorators if necessary to find our tags
        # (Though usually the wrapper has the tag attached)
        endpoint_info = getattr(method, "_endpoint_info", None)
        
        if endpoint_info:
            schema["endpoints"].append(endpoint_info)

    return schema
--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\core\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\services\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _MicroServicesLIBRARY\services\_ServiceRegistryMS\app.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox
import json
import threading
import requests
import os
import sys
import re

# ==============================================================================
# IMPORT CORE LOGIC
# ==============================================================================
# We need the 'apply_patch_text' function to validate our work.
try:
    from app import apply_patch_text, PatchError
except ImportError:
    try:
        from src.app import apply_patch_text, PatchError
    except ImportError:
        print("WARNING: Could not import 'app.py'. Validation disabled.")
        apply_patch_text = None
        PatchError = Exception

# ==============================================================================
# ðŸ§  CHAIN OF THOUGHT ENGINE
# ==============================================================================

class ChainOfThoughtClient:
    """
    Manages the multi-step inference process with Ollama.
    """
    def __init__(self, model="qwen2.5-coder:7b", host="http://localhost:11434"):
        self.host = host
        self.model = model
        self.log_callback = None
        self.stop_event = threading.Event()

    def log(self, step_num, message, status="INFO"):
        """Sends log updates to the GUI."""
        if self.log_callback:
            self.log_callback(step_num, message, status)

    def _call_ollama(self, prompt, context_window=8192):
        """Helper to send raw requests to Ollama."""
        try:
            payload = {
                "model": self.model,
                "prompt": prompt,
                "stream": False,
                "options": {
                    "temperature": 0.1,  # Strict adherence
                    "num_ctx": context_window
                }
            }
            response = requests.post(f"{self.host}/api/generate", json=payload)
            response.raise_for_status()
            data = response.json()
            return data.get("response", "").strip()
        except requests.exceptions.ConnectionError:
            raise Exception("Ollama is not running. Run 'ollama serve'.")
        except Exception as e:
            raise Exception(f"API Error: {e}")

    def execute_chain(self, target_code, messy_instruction, done_callback):
        """
        The Master Tasklist Execution Loop.
        """
        def _run():
            try:
                self.stop_event.clear()

                # --- STEP 1: SCOUTING (Locate the Search Block) ---
                self.log(1, "ðŸ” ANALYZING INTENT & LOCATING CONTEXT...", "WORK")
                
                # UPDATED PROMPT: Explicitly handles "New Code" vs "Old Code"
                scout_prompt = f"""
TASK: Localize the code to be replaced.
CONTEXT: The "USER INSTRUCTION" likely contains the NEW version of a code block (Desired State).
GOAL: Find the *ORIGINAL, EXISTING* code block in the "TARGET FILE" that corresponds to this change (Current State).

RULES:
1. Return the code EXACTLY as it appears in the TARGET FILE right now.
2. Do NOT return the "New Version" from the instructions.
3. Do NOT include placeholder comments (like # ...) unless they literally exist in the TARGET FILE.

TARGET FILE:
```python
{target_code}
```

USER INSTRUCTION (New Version):
{messy_instruction}

RESPONSE (The EXACT lines from the TARGET FILE that will be replaced):
"""
                found_block = self._call_ollama(scout_prompt)
                
                # Cleanup: Remove markdown if the model added it
                clean_block = found_block.replace("```python", "").replace("```", "").strip()
                
                # Validation: Does this block actually exist in the file?
                if clean_block not in target_code:
                    # Retry logic or Fail
                    self.log(1, "âŒ FAILED: AI returned code not found in file.", "ERR")
                    # Provide a helpful hint in the error
                    hint = "Hint: The AI likely tried to return the NEW code instead of the OLD code."
                    done_callback(False, f"Could not locate the exact code block.\n{hint}\n\nAI Output:\n{clean_block[:100]}...")
                    return
                
                found_block = clean_block
                self.log(1, f"âœ… CONTEXT LOCKED: Found {len(found_block.splitlines())} lines.", "OK")

                # --- STEP 2: ARCHITECTING (Draft the Replacement) ---
                self.log(2, "ðŸ”¨ DRAFTING NEW CODE (Filling Placeholders)...", "WORK")
                
                architect_prompt = f"""
TASK: Rewrite the "SOURCE BLOCK" applying the "USER CHANGES".
CRITICAL RULE: The user might use placeholders like "# ... existing code ...". You MUST replace those placeholders with the ACTUAL lines from the "SOURCE BLOCK".

SOURCE BLOCK (Original from File):
```python
{found_block}
```

USER CHANGES (New/Messy Instructions):
{messy_instruction}

RESPONSE (The fully complete, valid Python code block):
"""
                draft_block = self._call_ollama(architect_prompt)
                # Cleanup markdown
                draft_block = draft_block.replace("```python", "").replace("```", "").strip()
                self.log(2, "âœ… DRAFT COMPLETE.", "OK")

                # --- STEP 3: ENGINEERING (Format to JSON) ---
                self.log(3, "ðŸ“¦ PACKAGING INTO JSON PATCH...", "WORK")
                
                final_prompt = f"""
TASK: Create a JSON patch.
SEARCH_BLOCK: {found_block}
REPLACE_BLOCK: {draft_block}

SCHEMA:
{{
  "hunks": [
    {{
      "description": "Auto-generated patch",
      "search_block": "PASTE SEARCH_BLOCK HERE",
      "replace_block": "PASTE REPLACE_BLOCK HERE",
      "use_patch_indent": false
    }}
  ]
}}

OUTPUT (JSON ONLY):
"""
                json_str = self._call_ollama(final_prompt)
                
                # JSON Extraction logic
                start = json_str.find("{")
                end = json_str.rfind("}")
                if start != -1 and end != -1:
                    json_str = json_str[start:end+1]

                self.log(3, "âœ… JSON GENERATED.", "OK")
                done_callback(True, json_str)

            except Exception as e:
                self.log(4, f"ðŸ”¥ SYSTEM ERROR: {e}", "ERR")
                done_callback(False, str(e))

        threading.Thread(target=_run, daemon=True).start()


# ==============================================================================
# ðŸ–¥ï¸ GUI
# ==============================================================================

class CoTPatchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("System 2 Patcher (Chain-of-Thought)")
        self.root.geometry("1200x850")
        self.root.configure(bg="#0f172a")

        self.client = ChainOfThoughtClient()
        self.client.log_callback = self.update_task_list

        self._setup_ui()

    def _setup_ui(self):
        # Styles
        style = ttk.Style()
        style.theme_use("clam")
        self.colors = {
            "bg": "#0f172a", "panel": "#1e293b", "input": "#020617",
            "text": "#e2e8f0", "green": "#22c55e", "red": "#ef4444", 
            "yellow": "#facc15", "purple": "#7C3AED"
        }
        
        # --- Top Bar ---
        top = tk.Frame(self.root, bg=self.colors["panel"], pady=5)
        top.pack(fill="x")
        
        tk.Button(top, text="ðŸ“‚ Load Target File", command=self.load_file, 
                  bg="#334155", fg="white", relief="flat", padx=10).pack(side="left", padx=10)
        
        self.lbl_file = tk.Label(top, text="No file loaded", bg=self.colors["panel"], fg="#94a3b8")
        self.lbl_file.pack(side="left", padx=5)

        tk.Label(top, text="Model:", bg=self.colors["panel"], fg="white").pack(side="right", padx=5)
        self.model_var = tk.StringVar(value="qwen2.5-coder:7b")
        models = ["qwen2.5-coder:7b", "qwen2.5-coder:1.5b", "starcoder2:7b", "mistral:latest"]
        ttk.Combobox(top, textvariable=self.model_var, values=models, width=20).pack(side="right", padx=10)

        # --- Main Split ---
        paned = tk.PanedWindow(self.root, orient="horizontal", bg="#0f172a", sashwidth=4, sashrelief="flat")
        paned.pack(fill="both", expand=True, padx=10, pady=10)

        # LEFT COLUMN: Inputs
        left_frame = tk.Frame(paned, bg=self.colors["panel"])
        
        # 1. Target Code View
        tk.Label(left_frame, text="1. TARGET CODE (Context)", bg="#334155", fg="white", anchor="w").pack(fill="x")
        self.txt_target = scrolledtext.ScrolledText(left_frame, height=15, bg=self.colors["input"], fg="#94a3b8", bd=0)
        self.txt_target.pack(fill="both", expand=True, pady=(0, 10))
        
        # 2. User Instructions
        tk.Label(left_frame, text="2. MESSY INSTRUCTION (Prompt)", bg="#334155", fg="white", anchor="w").pack(fill="x")
        self.txt_instruct = scrolledtext.ScrolledText(left_frame, height=10, bg=self.colors["input"], fg="#e2e8f0", bd=0, insertbackground="white")
        self.txt_instruct.pack(fill="both", expand=True)
        self.txt_instruct.insert("1.0", "# Paste your sloppy code or request here...\n# e.g. \"Update the scan function to look 3 folders up. Use placeholders.\"")
        
        paned.add(left_frame, minsize=400)

        # RIGHT COLUMN: Process & Output
        right_frame = tk.Frame(paned, bg=self.colors["panel"])
        
        # 3. Task List (The Brain)
        tk.Label(right_frame, text="ðŸ§  THOUGHT PROCESS (Tasklist)", bg="#475569", fg="white", anchor="w").pack(fill="x")
        self.list_tasks = tk.Listbox(right_frame, height=8, bg=self.colors["input"], fg=self.colors["green"], 
                                     font=("Consolas", 10), bd=0, selectbackground="#334155")
        self.list_tasks.pack(fill="x", padx=5, pady=5)
        
        # Action Button
        self.btn_run = tk.Button(right_frame, text="ðŸš€ EXECUTE TASK CHAIN", command=self.run_chain, 
                                 bg=self.colors["purple"], fg="white", font=("Segoe UI", 11, "bold"), relief="flat")
        self.btn_run.pack(fill="x", padx=5, pady=5)

        # 4. JSON Output
        tk.Label(right_frame, text="3. FINAL JSON PATCH", bg="#334155", fg="white", anchor="w").pack(fill="x")
        self.txt_json = scrolledtext.ScrolledText(right_frame, bg=self.colors["input"], fg="#fbbf24", font=("Consolas", 10), bd=0)
        self.txt_json.pack(fill="both", expand=True, padx=5, pady=5)

        # Bottom Buttons
        btn_frame = tk.Frame(right_frame, bg=self.colors["panel"])
        btn_frame.pack(fill="x", pady=5)
        
        tk.Button(btn_frame, text="âœ… VALIDATE PATCH", command=self.validate, bg="#059669", fg="white", relief="flat").pack(side="left", fill="x", expand=True, padx=5)
        tk.Button(btn_frame, text="ðŸ’¾ SAVE JSON", command=self.save_json, bg="#334155", fg="white", relief="flat").pack(side="left", fill="x", expand=True, padx=5)

        paned.add(right_frame, minsize=400)

    # --- Logic ---

    def load_file(self):
        path = filedialog.askopenfilename()
        if path:
            try:
                with open(path, "r", encoding="utf-8") as f:
                    content = f.read()
                self.txt_target.delete("1.0", tk.END)
                self.txt_target.insert("1.0", content)
                self.lbl_file.config(text=os.path.basename(path))
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {e}")

    def update_task_list(self, step, msg, status="INFO"):
        # Map status to color
        colors = {"WORK": self.colors["yellow"], "OK": self.colors["green"], "ERR": self.colors["red"], "INFO": self.colors["text"]}
        fg = colors.get(status, self.colors["text"])
        
        def _update():
            self.list_tasks.insert(tk.END, f"[{step}] {msg}")
            self.list_tasks.itemconfig(tk.END, {'fg': fg})
            self.list_tasks.see(tk.END)
        
        self.root.after(0, _update)

    def run_chain(self):
        target = self.txt_target.get("1.0", tk.END).strip()
        instruct = self.txt_instruct.get("1.0", tk.END).strip()
        
        if not target or not instruct:
            messagebox.showwarning("Missing Input", "Please provide both the Target Code and Instructions.")
            return

        # UI Reset
        self.list_tasks.delete(0, tk.END)
        self.txt_json.delete("1.0", tk.END)
        self.btn_run.config(state="disabled", text="THINKING...", bg="#4b5563")
        
        # Update Model
        self.client.model = self.model_var.get()
        
        # Run
        self.client.execute_chain(target, instruct, self.on_complete)

    def on_complete(self, success, result):
        self.root.after(0, lambda: self._finish_ui(success, result))

    def _finish_ui(self, success, result):
        self.btn_run.config(state="normal", text="ðŸš€ EXECUTE TASK CHAIN", bg=self.colors["purple"])
        
        if success:
            self.txt_json.insert("1.0", result)
            # Auto-validate if core logic is available
            if apply_patch_text:
                self.validate()
        else:
            self.update_task_list(4, f"FATAL ERROR: {result}", "ERR")
            messagebox.showerror("Chain Failed", result)

    def validate(self):
        if not apply_patch_text:
            messagebox.showerror("Error", "Core patch logic not found. Cannot validate.")
            return

        try:
            target = self.txt_target.get("1.0", tk.END)
            patch_str = self.txt_json.get("1.0", tk.END).strip()
            
            if not patch_str:
                return

            patch_obj = json.loads(patch_str)
            
            # Dry run
            apply_patch_text(target, patch_obj)
            
            self.update_task_list(5, "âœ… VALIDATION SUCCESSFUL. Patch is clean.", "OK")
            messagebox.showinfo("Success", "Patch is valid and applies cleanly!")
            
        except Exception as e:
            self.update_task_list(5, f"âŒ VALIDATION FAILED: {e}", "ERR")
            messagebox.showerror("Validation Failed", str(e))

    def save_json(self):
        content = self.txt_json.get("1.0", tk.END).strip()
        if not content: return
        path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON", "*.json")])
        if path:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)

if __name__ == "__main__":
    root = tk.Tk()
    app = CoTPatchApp(root)
    root.mainloop()
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\.gitignore
--------------------------------------------------------------------------------
# --- Python ---
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# --- Virtual Env ---
venv/
.venv/
env/
ENV/

# --- IDEs ---
.idea/
.vscode/
*.swp
*.swo

# --- Project Specific (Generated Data) ---
cortex_dbs/
temp_scan.db
*.db
*.db-shm
*.db-wal
_logs/

# --- OS Junk ---
.DS_Store
Thumbs.db
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _NeoCORTEX\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _NeoCORTEX\requirements.txt
--------------------------------------------------------------------------------
# --- Critical UI/Graphing ---
pygame-ce>=2.3.0
Pillow>=10.0.0

# --- Networking/AI ---
requests>=2.30.0

# --- Database Extensions ---
# (Ensure your Python environment supports installing this, 
# otherwise you may need to manually place the DLL/SO)
sqlite-vec>=0.1.0

# --- Document Processing ---
pypdf>=3.0.0
beautifulsoup4>=4.12.0
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\app.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import os
import sqlite3
import threading
import queue
import json
import time
import sys

# --- Ensure src/ is importable as a top-level root ---
# `python -m src.app` makes `src` a package, but subfolders like
# src/_micro_services/** may not include __init__.py. Adding this
# directory to sys.path allows importing `_micro_services...` as a namespace.
_SRC_DIR = os.path.dirname(os.path.abspath(__file__))
if _SRC_DIR not in sys.path:
    sys.path.insert(0, _SRC_DIR)

# --- MICROSERVICE IMPORTS ---
from _micro_services._LibrarianServiceMS.librarian_service import LibrarianMS
from _micro_services._ScannerMS.scanner import ScannerMS
from _micro_services._IngestEngineMS.ingest_engine import IngestEngine
from _micro_services._GraphEngineMS.graph_view import GraphView
from _micro_services._ThoughtStreamMS.thought_stream import ThoughtStream
from _micro_services._SearchEngineMS.search_engine import SearchEngineMS
from _micro_services._ExporterMS.exporter import ExporterMS

# --- UI CONSTANTS ---
BG_COLOR = "#1e1e2f"
SIDEBAR_COLOR = "#171725"
ACCENT_COLOR = "#007ACC"
DANGER_COLOR = "#D32F2F"
SUCCESS_COLOR = "#388E3C"
TEXT_COLOR = "#e0e0e0"
EDITOR_BG = "#252526"
MODAL_BG = "#252526"

class Sidebar(tk.Frame):
    def __init__(self, parent, app, librarian: LibrarianMS):
        super().__init__(parent, bg=SIDEBAR_COLOR, width=250)
        self.app = app
        self.librarian = librarian
        self.pack_propagate(False)

        tk.Label(self, text="CORTEX DB", bg=SIDEBAR_COLOR, fg=ACCENT_COLOR, font=("Consolas", 14, "bold"), pady=20).pack(fill="x")
        tk.Label(self, text="ACTIVE KNOWLEDGE BASES", bg=SIDEBAR_COLOR, fg="#666", font=("Arial", 8, "bold"), anchor="w", padx=10).pack(fill="x")
        
        self.db_listbox = tk.Listbox(self, bg=SIDEBAR_COLOR, fg=TEXT_COLOR, bd=0, highlightthickness=0, selectbackground=ACCENT_COLOR)
        self.db_listbox.pack(fill="both", expand=True, padx=5, pady=5)
        self.db_listbox.bind("<<ListboxSelect>>", self.on_db_select)

        # Bottom Controls
        btn_frame = tk.Frame(self, bg=SIDEBAR_COLOR, pady=10)
        btn_frame.pack(fill="x", side="bottom")
        tk.Button(btn_frame, text="REFRESH LIST", bg="#2d2d44", fg="white", relief="flat", command=self.refresh_list).pack(fill="x", padx=10)

        self.refresh_list()

    def refresh_list(self):
        self.db_listbox.delete(0, tk.END)
        dbs = self.librarian.list_kbs()
        for db in dbs:
            self.db_listbox.insert(tk.END, db)

    def on_db_select(self, event):
        selection = self.db_listbox.curselection()
        if selection:
            db_name = self.db_listbox.get(selection[0])
            self.app.set_active_db(db_name)

class SettingsModal(tk.Toplevel):
    def __init__(self, parent, current_embed, current_helper, current_architect, ingestor_factory, callback):
        super().__init__(parent)
        self.title("Neural Configuration")
        self.geometry("450x350")
        self.configure(bg=MODAL_BG)
        self.ingestor_factory = ingestor_factory
        self.callback = callback
        
        x = parent.winfo_x() + (parent.winfo_width() // 2) - 225
        y = parent.winfo_y() + (parent.winfo_height() // 2) - 175
        self.geometry(f"+{x}+{y}")

        self.embed_var = tk.StringVar(value=current_embed)
        self.helper_var = tk.StringVar(value=current_helper)
        self.architect_var = tk.StringVar(value=current_architect)

        p = 20
        tk.Label(self, text="Main Architect (Reasoning/Chat):", bg=MODAL_BG, fg="white", font=("Arial", 9, "bold")).pack(anchor="w", padx=p, pady=(p, 5))
        self.architect_combo = ttk.Combobox(self, textvariable=self.architect_var, width=40)
        self.architect_combo.pack(padx=p, fill="x")
        
        tk.Label(self, text="Helper Agent (Fast Tags/Summary):", bg=MODAL_BG, fg="#A020F0", font=("Arial", 9, "bold")).pack(anchor="w", padx=p, pady=(15, 5))
        self.helper_combo = ttk.Combobox(self, textvariable=self.helper_var, width=40)
        self.helper_combo.pack(padx=p, fill="x")

        tk.Label(self, text="Embedder (Vectors):", bg=MODAL_BG, fg="#007ACC", font=("Arial", 9, "bold")).pack(anchor="w", padx=p, pady=(15, 5))
        self.embed_combo = ttk.Combobox(self, textvariable=self.embed_var, width=40)
        self.embed_combo.pack(padx=p, fill="x")

        btn_frame = tk.Frame(self, bg=MODAL_BG, pady=20)
        btn_frame.pack(fill="x", side="bottom")

        tk.Button(btn_frame, text="Apply Settings", bg=ACCENT_COLOR, fg="white", relief="flat", padx=15, pady=5, command=self.save_and_close).pack(side="right", padx=p)
        tk.Button(btn_frame, text="â†» Refresh Models", bg="#444", fg="white", relief="flat", padx=10, pady=5, command=self.refresh_models).pack(side="left", padx=p)

        # Defer model loading to allow window to render first
        self.after(100, lambda: self.refresh_models(silent=True))

    def refresh_models(self, silent=False):
        try:
            temp_engine = self.ingestor_factory("temp_scan.db")
            available_models = temp_engine.get_available_models()
            if available_models:
                self.embed_combo['values'] = tuple(available_models)
                self.helper_combo['values'] = tuple(available_models)
                self.architect_combo['values'] = tuple(available_models)
                if not silent: messagebox.showinfo("Ollama", f"Found {len(available_models)} models.")
            else:
                if not silent: messagebox.showwarning("Ollama", "No models found.")
        except Exception as e:
            if not silent: messagebox.showerror("Error", str(e))

    def save_and_close(self):
        self.callback(self.embed_var.get(), self.helper_var.get(), self.architect_var.get())
        self.destroy()

class IngestView(tk.Frame):
    def __init__(self, parent, app, scanner: ScannerMS, ingestor_factory):
        super().__init__(parent, bg=BG_COLOR)
        self.app = app
        self.scanner = scanner
        self.ingestor_factory = ingestor_factory
        self.current_tree = None
        self.current_engine = None # Reference to active engine for cancelling
        
        self.selected_embed = "nomic-embed-text"
        self.selected_helper = "qwen2.5:0.5b"
        self.selected_architect = "qwen2.5:7b"
        
        self.paned = ttk.PanedWindow(self, orient="horizontal")
        self.paned.pack(fill="both", expand=True)

        left_frame = tk.Frame(self.paned, bg=BG_COLOR)
        self.paned.add(left_frame, weight=1)

        # --- CONTROL PANEL ---
        ctrl_frame = tk.Frame(left_frame, bg=BG_COLOR, pady=10, padx=10)
        ctrl_frame.pack(fill="x")

        # Row 1: Source Picker
        row1 = tk.Frame(ctrl_frame, bg=BG_COLOR)
        row1.pack(fill="x", pady=2)
        tk.Label(row1, text="SOURCE:", bg=BG_COLOR, fg="gray", width=10, anchor="w").pack(side="left")
        self.path_entry = tk.Entry(row1, bg="#2d2d44", fg="white", insertbackground="white")
        self.path_entry.pack(side="left", fill="x", expand=True, padx=5)
        self.path_entry.insert(0, os.getcwd()) 
        tk.Button(row1, text="ðŸ“‚ Folder", bg="#444", fg="white", relief="flat", command=self.browse_folder).pack(side="left", padx=1)
        tk.Button(row1, text="ðŸ“„ File", bg="#444", fg="white", relief="flat", command=self.browse_file).pack(side="left", padx=1)
        
        # Row 2: Scan Options & Target DB
        row2 = tk.Frame(ctrl_frame, bg=BG_COLOR)
        row2.pack(fill="x", pady=5)
        
        tk.Label(row2, text="WEB DEPTH:", bg=BG_COLOR, fg="gray", width=10, anchor="w").pack(side="left")
        self.depth_spin = tk.Spinbox(row2, from_=0, to=5, width=3, bg="#2d2d44", fg="white", buttonbackground="#444")
        self.depth_spin.pack(side="left", padx=(5, 15))

        tk.Button(row2, text="ðŸ” SCAN TARGET", bg=ACCENT_COLOR, fg="white", relief="flat", command=self.run_scan).pack(side="left", padx=5)
        
        # Target DB Selector
        tk.Label(row2, text="TARGET DB:", bg=BG_COLOR, fg="gray", padx=10).pack(side="left")

        # Default to NONE (disables ingestion until a real DB is selected)
        self.target_db_var = tk.StringVar(value="NONE")
        # Scaled width to 90 as requested
        self.target_db_combo = ttk.Combobox(row2, textvariable=self.target_db_var, width=90, state="readonly")
        self.target_db_combo.pack(side="left", fill="x", padx=5)
        self.target_db_combo.bind("<<ComboboxSelected>>", self.on_db_combo_select)

        # Artifact Type Selector (explicit cartridge contract)
        tk.Label(row2, text="ARTIFACT:", bg=BG_COLOR, fg="gray", padx=10).pack(side="left")
        self.artifact_type_var = tk.StringVar(value="UNKNOWN")
        self.artifact_type_combo = ttk.Combobox(row2, textvariable=self.artifact_type_var, width=14, state="readonly")
        self.artifact_type_combo['values'] = ("UNKNOWN", "CODEBASE", "DOCUMENTS", "WEBSITE", "MIXED")
        self.artifact_type_combo.pack(side="left", padx=5)
        self.artifact_type_combo.bind("<<ComboboxSelected>>", lambda e: self._sync_db_dependent_controls())

        # New DB Button (inline creation mode)
        tk.Button(row2, text="âž• NEW", bg="#444", fg="white", relief="flat", command=self.create_new_db_dialog).pack(side="left", padx=(5, 2))

        # Inline New-DB name entry (disabled until NEW is clicked)
        self._new_db_placeholder = "type new db name and press Enter"
        self.new_db_var = tk.StringVar(value=self._new_db_placeholder)
        self.new_db_entry = tk.Entry(row2, textvariable=self.new_db_var, bg="#2d2d44", fg="#777", insertbackground="white", state="disabled", width=28)
        self.new_db_entry.pack(side="left", padx=(2, 0))
        self.new_db_entry.bind("<FocusIn>", self._on_new_db_focus_in)
        self.new_db_entry.bind("<FocusOut>", self._on_new_db_focus_out)
        self.new_db_entry.bind("<Return>", self._on_new_db_enter)

        self.refresh_db_combo()
        self._sync_db_dependent_controls()

        # Tree View for Scan Results
        self.tree = ttk.Treeview(left_frame, selectmode="extended")
        self.tree.pack(fill="both", expand=True, padx=10, pady=5)
        
        # --- ACTION BAR ---
        action_frame = tk.Frame(left_frame, bg="#101018", pady=10, padx=10)
        action_frame.pack(fill="x", side="bottom")
        
        # Config Cog
        tk.Button(action_frame, text="âš™", bg="#101018", fg="#666", font=("Arial", 16), bd=0, command=self.open_settings).pack(side="left", padx=(0, 10))
        self.lbl_config = tk.Label(action_frame, text="[Default Config]", bg="#101018", fg="gray", font=("Consolas", 9))
        self.lbl_config.pack(side="left")
        self._update_config_label()
        
        # Traffic Light Controls
        btn_box = tk.Frame(action_frame, bg="#101018")
        btn_box.pack(side="right")

        self.reconstruct_btn = tk.Button(btn_box, text="â™» RECONSTRUCT", bg="#444", fg="white", relief="flat", command=self.reconstruct_files)
        self.reconstruct_btn.pack(side="right", padx=5)

        self.cancel_btn = tk.Button(btn_box, text="ðŸ›‘ CANCEL", bg=DANGER_COLOR, fg="white", relief="flat", state="disabled", command=self.cancel_ingestion)
        self.cancel_btn.pack(side="right", padx=5)

        self.ingest_btn = tk.Button(btn_box, text="â–¶ START INGESTION", bg="gray", fg="white", relief="flat", state="disabled", command=self.start_ingestion)
        self.ingest_btn.pack(side="right", padx=5)
        
        self.lbl_status = tk.Label(action_frame, text="Ready", bg="#101018", fg="gray")
        self.lbl_status.pack(side="right", padx=10)

        self.stream = ThoughtStream(self.paned)
        self.paned.add(self.stream, weight=0) 

    def refresh_db_combo(self):
        # Always include a NONE sentinel so the user can't accidentally ingest into "no selection"
        dbs = ["NONE"] + self.app.librarian.list_kbs()
        self.target_db_combo['values'] = dbs

        # Prefer active_db if set, else keep current selection, else default to NONE
        if self.app.active_db:
            self.target_db_combo.set(self.app.active_db)
            self.target_db_var.set(self.app.active_db)
        else:
            cur = (self.target_db_var.get() or "").strip()
            if cur not in dbs:
                self.target_db_combo.set("NONE")
                self.target_db_var.set("NONE")

        self._sync_db_dependent_controls()

    def on_db_combo_select(self, event):
        selected = (self.target_db_var.get() or "").strip()
        if not selected or selected == "NONE":
            self.app.active_db = None
            self._sync_db_dependent_controls()
            return

        self.app.set_active_db(selected)
        self._sync_db_dependent_controls()

    def _sync_db_dependent_controls(self):
        """Enable/disable controls that require a real active DB."""
        selected = (self.target_db_var.get() or "").strip()
        has_db = bool(selected) and selected != "NONE"

        artifact = "UNKNOWN"
        if hasattr(self, "artifact_type_var"):
            artifact = (self.artifact_type_var.get() or "UNKNOWN").strip().upper()
        has_artifact = bool(artifact) and artifact != "UNKNOWN"

        # If scan is ready, ingestion button should still be blocked unless a DB + Artifact are selected
        if hasattr(self, "ingest_btn"):
            if has_db and has_artifact and self.current_tree:
                self.ingest_btn.config(state="normal", bg=ACCENT_COLOR)
            else:
                self.ingest_btn.config(state="disabled", bg="gray")

        if hasattr(self, "reconstruct_btn"):
            self.reconstruct_btn.config(state=("normal" if has_db else "disabled"))

    def create_new_db_dialog(self):
        """Enter 'new DB creation' mode: enable the inline entry and focus it."""
        self.new_db_entry.config(state="normal")
        self.new_db_entry.focus_set()
        # Select placeholder text for quick overwrite
        self.new_db_entry.selection_range(0, tk.END)

    def _on_new_db_focus_in(self, event=None):
        val = self.new_db_var.get()
        if val == self._new_db_placeholder:
            self.new_db_var.set("")
            self.new_db_entry.config(fg="white")

    def _on_new_db_focus_out(self, event=None):
        val = (self.new_db_var.get() or "").strip()
        if not val:
            self.new_db_var.set(self._new_db_placeholder)
            self.new_db_entry.config(fg="#777")
            self.new_db_entry.config(state="disabled")

    def _on_new_db_enter(self, event=None):
        raw = (self.new_db_var.get() or "").strip()
        if not raw or raw == self._new_db_placeholder:
            return

        # Ensure extension
        if not raw.lower().endswith('.db'):
            raw += '.db'

        try:
            result = self.app.librarian.create_kb(raw)
            actual_name = result.get('name', raw)

            self.app.sidebar.refresh_list()
            self.refresh_db_combo()
            self.app.set_active_db(actual_name)
            self.target_db_combo.set(actual_name)
            self.target_db_var.set(actual_name)

            # Exit creation mode
            self.new_db_var.set(self._new_db_placeholder)
            self.new_db_entry.config(fg="#777")
            self.new_db_entry.config(state="disabled")
            self._sync_db_dependent_controls()
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def browse_folder(self):
        path = filedialog.askdirectory()
        if path:
            self.path_entry.delete(0, tk.END)
            self.path_entry.insert(0, path)

    def browse_file(self):
        path = filedialog.askopenfilename()
        if path:
            self.path_entry.delete(0, tk.END)
            self.path_entry.insert(0, path)

    def open_settings(self):
        SettingsModal(self, self.selected_embed, self.selected_helper, self.selected_architect, self.ingestor_factory, self.on_settings_saved)

    def on_settings_saved(self, new_embed, new_helper, new_architect):
        self.selected_embed = new_embed
        self.selected_helper = new_helper
        self.selected_architect = new_architect
        self._update_config_label()

    def _update_config_label(self):
        e_name = self.selected_embed.split(':')[0]
        h_name = self.selected_helper.split(':')[0]
        a_name = self.selected_architect.split(':')[0]
        self.lbl_config.config(text=f"[{a_name} | {h_name} | {e_name}]")

    def run_scan(self):
        path = self.path_entry.get().strip()
        try:
            depth = int(self.depth_spin.get())
        except ValueError:
            depth = 0

        if not path: return

        self.lbl_status.config(text="Scanning...")
        self.config(cursor="watch")
        self.update_idletasks()
        
        try:
            # Run scan
            data = self.scanner.scan_directory(path, web_depth=depth)
        finally:
            self.config(cursor="")
        
        if not data:
            messagebox.showerror("Error", "Invalid path or URL")
            self.lbl_status.config(text="Scan Failed")
            return
            
        self.current_tree = data
        self._populate_tree("", data)
        self._sync_db_dependent_controls()
        self.lbl_status.config(text="Scan Complete. Select a DB and Ingest.")

    def _populate_tree(self, parent_id, node):
        if parent_id == "": self.tree.delete(*self.tree.get_children())
        display_text = f"{node['text']}"
        if node.get('type') == 'binary': display_text += " [BIN]"
        if node.get('type') == 'web': display_text += " [WEB]"
        
        oid = self.tree.insert(parent_id, "end", text=display_text, open=True)
        for child in node.get('children', []): self._populate_tree(oid, child)

    def start_ingestion(self):
        target_db = (self.target_db_var.get() or "").strip()
        if not target_db or target_db == "NONE":
            messagebox.showwarning("Warning", "Please select a Target DB (not NONE).")
            return

        artifact = (self.artifact_type_var.get() if hasattr(self, "artifact_type_var") else "UNKNOWN")
        artifact = (artifact or "UNKNOWN").strip().upper()
        if artifact == "UNKNOWN":
            messagebox.showwarning("Warning", "Please select an Artifact Type (not UNKNOWN).")
            return

        # Handle New DB Creation Logic
        if not target_db.lower().endswith('.db'):
            target_db += '.db'

        existing_dbs = self.app.librarian.list_kbs()
        if target_db not in existing_dbs:
            # Auto-create (IMPORTANT: use canonical returned name)
            try:
                result = self.app.librarian.create_kb(target_db)
                target_db = result.get('name', target_db)
                self.app.sidebar.refresh_list()
                self.refresh_db_combo()
            except Exception as e:
                messagebox.showerror("Error", f"Could not create DB: {e}")
                return

        # Set Active (canonical)
        self.app.set_active_db(target_db)
        self.target_db_var.set(target_db)
        self.target_db_combo.set(target_db)
        self._sync_db_dependent_controls()

        files = self.scanner.flatten_tree(self.current_tree)
        if not files: return

        # UI State Lock
        self.ingest_btn.config(state="disabled", text="RUNNING...")
        self.cancel_btn.config(state="normal")
        self.reconstruct_btn.config(state="disabled")

        embed_model = self.selected_embed
        summary_model = self.selected_helper 
        db_path = os.path.join(self.app.librarian.storage_dir, target_db)

        # Stamp cartridge contract fields into manifest BEFORE ingestion begins
        try:
            source = (self.path_entry.get() or "").strip()
            try:
                depth = int(self.depth_spin.get())
            except Exception:
                depth = 0

            artifact_profile = {
                "artifact_type": artifact,
                "source": source,
                "web_depth": depth,
                "ui": "_NeoCORTEX",
                "stamped_at": time.time()
            }
            source_prov = {
                "source": source,
                "web_depth": depth,
                "stamped_at": time.time()
            }

            conn = sqlite3.connect(db_path)
            cur = conn.cursor()
            cur.execute("CREATE TABLE IF NOT EXISTS manifest (key TEXT PRIMARY KEY, value TEXT)")
            cur.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("artifact_type", artifact))
            cur.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("artifact_profile", json.dumps(artifact_profile)))
            cur.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("source_provenance", json.dumps(source_prov)))
            conn.commit()
            conn.close()
        except Exception:
            # Never block ingest if manifest stamping fails
            pass
        
        # Instantiate Engine and keep ref for cancelling
        self.current_engine = self.ingestor_factory(db_path)
        self.msg_queue = queue.Queue()
        
        def worker():
            for status in self.current_engine.process_files(files, embed_model, summary_model):
                self.msg_queue.put(status)
            self.msg_queue.put(None)

        threading.Thread(target=worker, daemon=True).start()
        self.check_queue()

    def cancel_ingestion(self):
        if self.current_engine:
            self.current_engine.abort()
            self.lbl_status.config(text="Stopping...")
            self.cancel_btn.config(state="disabled")

    def reconstruct_files(self):
        if not self.app.active_db:
            messagebox.showwarning("Warning", "Select a Knowledge Base first.")
            return

        target_dir = filedialog.askdirectory(title="Select Reconstruction Destination")
        if not target_dir: return

        try:
            db_path = os.path.join(self.app.librarian.storage_dir, self.app.active_db)
            count, errors = self.app.exporter.export_knowledge_base(db_path, target_dir)
            
            msg = f"Reconstruction Complete.\nFiles Restored: {count}"
            if errors: msg += f"\nErrors: {len(errors)} (Check logs)"
            messagebox.showinfo("Result", msg)
        except Exception as e:
            messagebox.showerror("Failed", str(e))

    def check_queue(self):
        try:
            while True:
                status = self.msg_queue.get_nowait()
                if status is None:
                    # DONE
                    self.ingest_btn.config(state="normal", text="START INGESTION")
                    self.cancel_btn.config(state="disabled")
                    self.reconstruct_btn.config(state="normal")
                    self.lbl_status.config(text="Ingestion Cycle Ended.")
                    self.current_engine = None
                    if self.app.active_db: 
                        self.app.editor_view.refresh_file_list()
                        self.app.db_view.refresh_data()
                    return
                
                self.lbl_status.config(text=f"{status.progress_percent:.1f}% - {status.log_message}")
                if status.thought_frame:
                    tf = status.thought_frame
                    self.stream.add_thought_bubble(tf['file'], tf['chunk_index'], tf['content'], tf['vector_preview'], tf['concept_color'])
        except queue.Empty:
            pass
        self.after(100, self.check_queue)

class DatabaseView(tk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, bg=BG_COLOR)
        self.app = app
        
        toolbar = tk.Frame(self, bg=SIDEBAR_COLOR, pady=5, padx=5)
        toolbar.pack(fill="x")
        
        tk.Label(toolbar, text="TABLE:", bg=SIDEBAR_COLOR, fg="gray", font=("Arial", 8, "bold")).pack(side="left")
        self.table_var = tk.StringVar(value="files")
        self.table_combo = ttk.Combobox(toolbar, textvariable=self.table_var, width=15, state="readonly")
        self.table_combo['values'] = ('files', 'chunks', 'diff_log', 'graph_nodes', 'graph_edges', 'manifest')
        self.table_combo.pack(side="left", padx=5)
        self.table_combo.bind("<<ComboboxSelected>>", self.refresh_data)

        tk.Label(toolbar, text="FILTER (SQL LIKE):", bg=SIDEBAR_COLOR, fg="gray", font=("Arial", 8, "bold")).pack(side="left", padx=(15, 5))
        self.search_entry = tk.Entry(toolbar, bg="#2d2d44", fg="white", insertbackground="white")
        self.search_entry.pack(side="left", fill="x", expand=True)
        self.search_entry.bind("<Return>", self.refresh_data)
        
        tk.Button(toolbar, text="ðŸ’¾ SAVE SELECTED", bg=ACCENT_COLOR, fg="white", relief="flat", command=self.export_selected).pack(side="right", padx=5)
        
        self.tree_frame = tk.Frame(self, bg=BG_COLOR)
        self.tree_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        self.tree = ttk.Treeview(self.tree_frame, show="headings", selectmode="browse")
        vsb = ttk.Scrollbar(self.tree_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(self.tree_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        
        self.tree.grid(column=0, row=0, sticky='nsew')
        vsb.grid(column=1, row=0, sticky='ns')
        hsb.grid(column=0, row=1, sticky='ew')
        
        self.tree.bind("<Double-1>", self.on_double_click)
        self.tree_frame.grid_columnconfigure(0, weight=1)
        self.tree_frame.grid_rowconfigure(0, weight=1)

    def refresh_data(self, event=None):
        if not self.app.active_db: return
        table = self.table_var.get()
        query_filter = self.search_entry.get().strip()
        self.tree.delete(*self.tree.get_children())
        
        db_path = os.path.join(self.app.librarian.storage_dir, self.app.active_db)
        if not os.path.exists(db_path): return

        try:
            conn = sqlite3.connect(db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            sql = f"SELECT * FROM {table}"
            params = []
            
            if query_filter:
                cols = self._get_columns(cursor, table)
                text_cols = [c for c in cols if 'id' in c or 'path' in c or 'content' in c or 'label' in c]
                if text_cols:
                    conditions = " OR ".join([f"{col} LIKE ?" for col in text_cols])
                    sql += f" WHERE {conditions}"
                    params = [f"%{query_filter}%" for _ in text_cols]

            sql += " LIMIT 100"
            cursor.execute(sql, params)
            rows = cursor.fetchall()
            
            if rows:
                col_names = rows[0].keys()
                self.tree['columns'] = col_names
                for col in col_names:
                    self.tree.heading(col, text=col)
                    self.tree.column(col, width=100)
                
                for row in rows:
                    values = [str(val)[:50] + "..." if len(str(val)) > 50 else val for val in row]
                    self.tree.insert("", "end", values=values, tags=(str(row[0]),)) # Tag with ID if possible
            conn.close()
        except Exception as e:
            print(f"Inspector Error: {e}")

    def _get_columns(self, cursor, table):
        cursor.execute(f"PRAGMA table_info({table})")
        return [row[1] for row in cursor.fetchall()]

    def on_double_click(self, event):
        item = self.tree.identify_row(event.y)
        if not item: return
        values = self.tree.item(item, 'values')
        if not values: return
        
        # Simple Viewer
        top = tk.Toplevel(self)
        top.geometry("600x400")
        txt = scrolledtext.ScrolledText(top, bg=EDITOR_BG, fg=TEXT_COLOR)
        txt.pack(fill="both", expand=True)
        txt.insert("1.0", f"{values}")

    def export_selected(self):
        # Implementation similar to previous, kept brief for this file
        pass

class EditorView(tk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, bg=BG_COLOR)
        self.app = app
        self.current_file = None
        
        self.paned = ttk.PanedWindow(self, orient="horizontal")
        self.paned.pack(fill="both", expand=True)

        left_frame = tk.Frame(self.paned, bg=SIDEBAR_COLOR)
        self.paned.add(left_frame, weight=1)
        tk.Label(left_frame, text="EXPLORER", bg=SIDEBAR_COLOR, fg="#888", font=("Arial", 8, "bold"), anchor="w", padx=5).pack(fill="x", pady=(5,0))

        self.file_tree = ttk.Treeview(left_frame, selectmode="browse", show="tree")
        self.file_tree.pack(fill="both", expand=True, padx=5, pady=5)
        self.file_tree.bind("<<TreeviewSelect>>", self.on_file_select)
        
        center_frame = tk.Frame(self.paned, bg=EDITOR_BG)
        self.paned.add(center_frame, weight=4)
        
        toolbar = tk.Frame(center_frame, bg=EDITOR_BG)
        toolbar.pack(fill="x", pady=5, padx=10)
        self.lbl_current_file = tk.Label(toolbar, text="No file selected", bg=EDITOR_BG, fg=ACCENT_COLOR, font=("Consolas", 10, "bold"))
        self.lbl_current_file.pack(side="left")
        self.btn_save = tk.Button(toolbar, text="SAVE CHANGES", bg="#2d2d44", fg="white", relief="flat", state="disabled", command=self.save_changes)
        self.btn_save.pack(side="right")

        self.editor = scrolledtext.ScrolledText(center_frame, bg=EDITOR_BG, fg=TEXT_COLOR, font=("Consolas", 11), insertbackground="white", undo=True)
        self.editor.pack(fill="both", expand=True, padx=10, pady=(0, 10))

        right_frame = tk.Frame(self.paned, bg=SIDEBAR_COLOR)
        self.paned.add(right_frame, weight=2)
        
        tk.Label(right_frame, text="NEURAL SEARCH", bg=SIDEBAR_COLOR, fg="#888", font=("Arial", 8, "bold"), anchor="w", padx=5).pack(fill="x", pady=(5,0))
        
        search_box = tk.Frame(right_frame, bg=SIDEBAR_COLOR, pady=5, padx=5)
        search_box.pack(fill="x")
        
        self.search_var = tk.StringVar()
        self.entry_search = tk.Entry(search_box, textvariable=self.search_var, bg="#2d2d44", fg="white", insertbackground="white")
        self.entry_search.pack(side="left", fill="x", expand=True)
        self.entry_search.bind("<Return>", self.perform_search)
        
        tk.Button(search_box, text="GO", bg=ACCENT_COLOR, fg="white", relief="flat", width=3, command=self.perform_search).pack(side="right", padx=(5,0))
        
        self.results_tree = ttk.Treeview(right_frame, selectmode="browse", show="tree")
        self.results_tree.pack(fill="both", expand=True, padx=5, pady=5)
        self.results_tree.bind("<<TreeviewSelect>>", self.on_result_select)

    def refresh_file_list(self):
        for item in self.file_tree.get_children(): self.file_tree.delete(item)
        if not self.app.active_db: return
        try:
            files = self.app.librarian.list_files_in_kb(self.app.active_db)
            for path in files:
                self.file_tree.insert("", "end", iid=path, text=path)
        except Exception as e:
            print(f"Error listing files: {e}")

    def on_file_select(self, event):
        selection = self.file_tree.selection()
        if not selection: return
        file_path = selection[0]
        content = self.app.librarian.get_file_content(self.app.active_db, file_path)
        if content is None: return
        self.current_file = file_path
        self.lbl_current_file.config(text=f"EDITING: {file_path}")
        self.editor.delete(1.0, tk.END)
        self.editor.insert(tk.END, content)
        self.btn_save.config(state="normal", bg=ACCENT_COLOR)

    def save_changes(self):
        if not self.app.active_db or not self.current_file: return
        new_content = self.editor.get(1.0, tk.END).strip()
        try:
            result = self.app.librarian.update_file(self.app.active_db, self.current_file, new_content, author="user")
            messagebox.showinfo("Success", f"File saved.\nDiff Size: {result.get('diff_size')} bytes")
        except Exception as e:
            messagebox.showerror("Save Error", str(e))

    def perform_search(self, event=None):
        query = self.search_var.get().strip()
        if not query or not self.app.active_db: return
        self.results_tree.delete(*self.results_tree.get_children())
        db_path = os.path.join(self.app.librarian.storage_dir, self.app.active_db)
        results = self.app.search_engine.search(db_path, query, limit=15)
        for i, res in enumerate(results):
            score_pct = int(res['score'] * 100) if res['score'] <= 1 else int(res['score'])
            display = f"[{score_pct}] {os.path.basename(res['path'])}"
            self.results_tree.insert("", "end", text=display, values=(res['path'], res['snippet']))

    def on_result_select(self, event):
        selection = self.results_tree.selection()
        if not selection: return
        item = self.results_tree.item(selection[0])
        values = item['values']
        if not values: return
        file_path = values[0]
        content = self.app.librarian.get_file_content(self.app.active_db, file_path)
        if not content: return
        self.current_file = file_path
        self.lbl_current_file.config(text=f"EDITING: {file_path}")
        self.editor.delete(1.0, tk.END)
        self.editor.insert(tk.END, content)
        self.btn_save.config(state="normal", bg=ACCENT_COLOR)
        snippet_start = values[1].replace("...", "").strip()[:20] 
        start_idx = self.editor.search(snippet_start, "1.0", stopindex=tk.END)
        if start_idx:
            self.editor.see(start_idx)
            self.editor.tag_add("highlight", start_idx, f"{start_idx} lineend")
            self.editor.tag_config("highlight", background="#333344", foreground="#00FF00")

class NeoCortexApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("_NeoCORTEX v1.1 (Universal)")
        self.geometry("1200x800")
        self.configure(bg=BG_COLOR)

        # 1. Initialize Services
        self.librarian = LibrarianMS("./cortex_dbs")
        self.scanner = ScannerMS()
        self.search_engine = SearchEngineMS()
        self.exporter = ExporterMS()
        self.ingest_factory = lambda db_path: IngestEngine(db_path)
        
        self.active_db = None

        # 2. Setup Layout
        self._setup_ui()

    def _setup_ui(self):
        self.sidebar = Sidebar(self, self, self.librarian)
        self.sidebar.pack(side="left", fill="y")

        self.main_area = tk.Frame(self, bg=BG_COLOR)
        self.main_area.pack(side="right", fill="both", expand=True)
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("TNotebook", background=BG_COLOR, borderwidth=0)
        style.configure("TNotebook.Tab", background="#2d2d44", foreground="white", padding=[10, 5])
        style.map("TNotebook.Tab", background=[("selected", ACCENT_COLOR)])

        self.notebook = ttk.Notebook(self.main_area)
        self.notebook.pack(fill="both", expand=True)

        self.ingest_view = IngestView(self.notebook, self, self.scanner, self.ingest_factory)
        self.notebook.add(self.ingest_view, text="  INGEST & WEAVE  ")

        self.editor_view = EditorView(self.notebook, self)
        self.notebook.add(self.editor_view, text="  KNOWLEDGE EDITOR  ")

        self.db_view = DatabaseView(self.notebook, self)
        self.notebook.add(self.db_view, text="  DATABASE INSPECTOR  ")

        self.graph_view = GraphView(self.notebook)
        self.notebook.add(self.graph_view, text="  NEURAL GRAPH  ")

    def set_active_db(self, db_name):
        self.active_db = db_name
        self.title(f"_NeoCORTEX v1.1 - Connected to [{db_name}]")
        self.editor_view.refresh_file_list()
        self.db_view.refresh_data()
        self.ingest_view.refresh_db_combo() # Sync Ingest View
        
        db_path = os.path.join(self.librarian.storage_dir, db_name)
        self.after(100, lambda: self.graph_view.load_from_db(db_path))

if __name__ == "__main__":
    app = NeoCortexApp()
    app.mainloop()






--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_ArchitectMS\gnn_brain.py
--------------------------------------------------------------------------------
import sqlite3
import torch
import json
import struct
from torch_geometric.data import Data
from torch_geometric.nn import SAGEConv
import torch.nn.functional as F

class CodeGraphBrain:
    def __init__(self, db_path):
        self.db_path = db_path
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        
    def load_graph_from_neocortex(self):
        """
        Bridges _NeoCORTEX SQLite tables to a PyTorch Geometric Graph.
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # 1. Load Nodes & Features (The Embeddings you already have!)
        # We average chunk embeddings to get a single 'File Embedding'
        print("Loading embeddings...")
        sql = """
            SELECT f.path, c.embedding 
            FROM files f 
            JOIN chunks c ON f.id = c.file_id
        """
        cursor.execute(sql)
        
        node_map = {} # path -> index
        x_list = []   # features
        
        raw_data = cursor.fetchall()
        
        # Aggregate embeddings per file (Simple mean)
        temp_features = {}
        for path, emb_blob in raw_data:
            if not emb_blob: continue
            # Deserialize the BLOB from sqlite-vec format or JSON
            try:
                # Assuming JSON based on ingest_engine.py line 125
                vec = json.loads(emb_blob) 
                if path not in temp_features: temp_features[path] = []
                temp_features[path].append(vec)
            except: pass

        for i, (path, vecs) in enumerate(temp_features.items()):
            node_map[path] = i
            # Average the chunk vectors to get a File Vector
            avg_vec = torch.tensor(vecs).mean(dim=0)
            x_list.append(avg_vec)

        # 2. Load Edges (Your SynapseWeaver data)
        print("Loading edges...")
        cursor.execute("SELECT source, target FROM graph_edges")
        edge_list = []
        for src, tgt in cursor.fetchall():
            if src in node_map and tgt in node_map:
                edge_list.append([node_map[src], node_map[tgt]])
                # Add reverse edge for undirected graph
                edge_list.append([node_map[tgt], node_map[src]])

        conn.close()

        # 3. Construct PyG Data
        x = torch.stack(x_list) # Node Features [Num_Nodes, Hidden_Dim]
        edge_index = torch.tensor(edge_list, dtype=torch.long).t().contiguous()
        
        data = Data(x=x, edge_index=edge_index)
        return data.to(self.device), node_map

    def train_architect(self, data):
        """Train a tiny GNN to understand code structure"""
        model = GraphSAGE(data.num_features, 64, data.num_features).to(self.device)
        optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
        
        print("Training Architect Brain...")
        model.train()
        for epoch in range(100): # Fast training loop
            optimizer.zero_grad()
            z = model(data.x, data.edge_index)
            
            # Self-Supervised: Try to reconstruct the graph edges
            # (Predict existing links)
            out = (z[data.edge_index[0]] * z[data.edge_index[1]]).sum(dim=-1)
            loss = F.binary_cross_entropy_with_logits(out, torch.ones_like(out))
            
            loss.backward()
            optimizer.step()
            
            if epoch % 20 == 0:
                print(f"Epoch {epoch}: Loss {loss.item():.4f}")
        
        return model

# --- The Model ---
class GraphSAGE(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, out_channels):
        super().__init__()
        self.conv1 = SAGEConv(in_channels, hidden_channels)
        self.conv2 = SAGEConv(hidden_channels, out_channels)
    
    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = self.conv2(x, edge_index)
        return x # Returns new, "context-aware" embeddings

if __name__ == "__main__":
    # Test run
    brain = CodeGraphBrain("./cortex_dbs/_NeoCORTEX_FirstIngestion.db")
    graph, mappings = brain.load_graph_from_neocortex()
    model = brain.train_architect(graph)
    print("Brain Trained!")
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_ExporterMS\exporter.py
--------------------------------------------------------------------------------
import os
import sqlite3
import logging
from pathlib import Path
from typing import List, Tuple, Optional

# ==============================================================================
# CONFIGURATION
# ==============================================================================
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger("Exporter")
# ==============================================================================

class ExporterMS:
    """
    The Reconstructor: Reads the latest file snapshots from a Cortex Knowledge Base
    and rebuilds the directory structure on the local file system.
    
    UPGRADE: Uses 'vfs_path' for precise reconstruction of mixed sources (Web/File).
    """

    def export_knowledge_base(self, db_path: str, output_dir: str) -> Tuple[int, List[str]]:
        """
        Exports all files from the KB to the target directory.
        :return: (count_of_files_exported, list_of_errors)
        """
        db = Path(db_path).resolve()
        out_root = Path(output_dir).resolve()
        
        if not db.exists():
            raise FileNotFoundError(f"Database not found: {db}")

        # Create output directory if it doesn't exist
        out_root.mkdir(parents=True, exist_ok=True)

        log.info(f"Starting Export: {db.name} -> {out_root}")
        
        exported_count = 0
        errors = []

        try:
            conn = sqlite3.connect(db)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()

            # 1. Fetch all files
            # We use vfs_path (Virtual File System) as the truth for where it goes.
            cursor.execute("SELECT vfs_path, content, origin_type FROM files")
            rows = cursor.fetchall()

            for row in rows:
                vfs_path = row['vfs_path']
                content = row['content']
                origin = row['origin_type']

                if not vfs_path: continue

                # 2. Construct Destination Path
                # Security Check: Prevent path traversal (e.g. ../../etc/passwd)
                safe_rel = self._sanitize_path(vfs_path)
                
                dest_path = out_root / safe_rel

                try:
                    # 3. Write File
                    # Ensure parent dirs exist
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Write content (UTF-8)
                    with open(dest_path, 'w', encoding='utf-8', newline='') as f:
                        if content:
                            f.write(content)
                    
                    exported_count += 1
                    
                except Exception as e:
                    err_msg = f"Failed to write {vfs_path}: {e}"
                    log.error(err_msg)
                    errors.append(err_msg)

            conn.close()
            log.info(f"Export Complete. {exported_count} files written. {len(errors)} errors.")
            return exported_count, errors

        except Exception as e:
            log.critical(f"Critical Export Failure: {e}")
            raise e

    def _sanitize_path(self, path_str: str) -> Path:
        """
        Ensures the path is relative and does not escape the root.
        """
        # Strip leading slashes/dots/drive letters
        clean = path_str.lstrip("/\\.").replace("..", "").replace(":", "")
        return Path(clean)

if __name__ == "__main__":
    pass
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_GraphEngineMS\graph_engine.py
--------------------------------------------------------------------------------
import pygame
import math
import random

# Initialize font module globally once
pygame.font.init()

class GraphRenderer:
    def __init__(self, width, height, bg_color=(16, 16, 24)):
        self.width = width
        self.height = height
        self.bg_color = bg_color
        
        self.surface = pygame.Surface((width, height))
        
        # Camera
        self.cam_x = 0
        self.cam_y = 0
        self.zoom = 1.0
        
        # Assets
        self.font = pygame.font.SysFont("Consolas", 12)
        
        # Data
        self.nodes = [] 
        self.links = []
        
        # Interaction
        self.dragged_node_idx = None
        self.hovered_node_idx = None
        
        # Physics State
        self.settled = False

    def resize(self, width, height):
        self.width = width
        self.height = height
        self.surface = pygame.Surface((width, height))

    def set_data(self, nodes, links):
        self.nodes = nodes
        self.links = links
        self.settled = False # Wake up physics on new data
        
        # 1. Build an ID map so we can find parents
        node_map = {node['id']: node for node in self.nodes}

        for n in self.nodes:
            # GNN Injection: Use pre-calculated layout if available
            if 'gnn_x' in n and 'gnn_y' in n:
                n['x'] = n['gnn_x'] * self.width
                n['y'] = n['gnn_y'] * self.height

            elif 'x' not in n:
                # SMART SPAWN: If I am a satellite, spawn near my planet
                parent_id = n.get('meta', {}).get('parent')
                if parent_id and parent_id in node_map and 'x' in node_map[parent_id]:
                    p = node_map[parent_id]
                    angle = random.random() * 6.28
                    dist = 30
                    n['x'] = p['x'] + math.cos(angle) * dist
                    n['y'] = p['y'] + math.sin(angle) * dist
                else:
                    # Random spawn for Files
                    n['x'] = random.randint(int(self.width*0.2), int(self.width*0.8))
                    n['y'] = random.randint(int(self.height*0.2), int(self.height*0.8))
            if 'vx' not in n: n['vx'] = 0
            if 'vy' not in n: n['vy'] = 0
            
            # Semantic Coloring
            if n.get('type') == 'file':
                n['_color'] = (0, 122, 204) # Blue
                n['_radius'] = 6
            elif n.get('type') == 'web':
                n['_color'] = (204, 0, 122) # Purple/Pink
                n['_radius'] = 7
            elif n.get('type') == 'chunk':
                n['_color'] = (100, 200, 100) # Satellite Green
                n['_radius'] = 3
            else:
                n['_color'] = (160, 32, 240) # Default
                n['_radius'] = 6

    # --- INPUT HANDLING ---
    
    def screen_to_world(self, sx, sy):
        cx, cy = self.width / 2, self.height / 2
        wx = (sx - cx) / self.zoom + cx - self.cam_x
        wy = (sy - cy) / self.zoom + cy - self.cam_y
        return wx, wy

    def get_node_at(self, sx, sy):
        wx, wy = self.screen_to_world(sx, sy)
        for n in self.nodes:
            dist = math.hypot(n['x'] - wx, n['y'] - wy)
            if dist < n['_radius'] * 2:
                return n
        return None

    def handle_mouse_down(self, x, y):
        wx, wy = self.screen_to_world(x, y)
        for i, n in enumerate(self.nodes):
            dist = math.hypot(n['x'] - wx, n['y'] - wy)
            if dist < n['_radius'] * 2:
                self.dragged_node_idx = i
                self.settled = False # Wake up physics
                return True
        return False

    def handle_mouse_move(self, x, y, is_dragging):
        wx, wy = self.screen_to_world(x, y)
        
        if is_dragging and self.dragged_node_idx is not None:
            node = self.nodes[self.dragged_node_idx]
            node['x'] = wx
            node['y'] = wy
            node['vx'] = 0
            node['vy'] = 0
            self.settled = False
        else:
            prev_hover = self.hovered_node_idx
            self.hovered_node_idx = None
            for i, n in enumerate(self.nodes):
                dist = math.hypot(n['x'] - wx, n['y'] - wy)
                if dist < n['_radius'] * 2:
                    self.hovered_node_idx = i
                    break
            return prev_hover != self.hovered_node_idx

    def handle_mouse_up(self):
        self.dragged_node_idx = None

    def pan(self, dx, dy):
        self.cam_x += dx / self.zoom
        self.cam_y += dy / self.zoom

    def zoom_camera(self, amount, mouse_x, mouse_y):
        self.zoom *= amount
        self.zoom = max(0.1, min(self.zoom, 5.0))

    # --- PHYSICS (Damped) ---

    def step_physics(self):
        if not self.nodes or self.settled: return

        REPULSION = 1000
        ATTRACTION = 0.01
        CENTER_GRAVITY = 0.01
        DAMPING = 0.85 # Increased damping to settle faster
        
        cx, cy = self.width / 2, self.height / 2
        total_kinetic_energy = 0

        for i, a in enumerate(self.nodes):
            if i == self.dragged_node_idx: continue

            # LOD: Freeze satellites if zoomed out
            if self.zoom < 1.2 and a.get('type') == 'chunk':
                a['vx'] = 0
                a['vy'] = 0
                continue
            
            fx, fy = 0, 0
            
            # 1. Gravity (Center pull)
            fx += (cx - a['x']) * CENTER_GRAVITY
            fy += (cy - a['y']) * CENTER_GRAVITY

            # 2. Repulsion
            for j, b in enumerate(self.nodes):
                if i == j: continue
                dx = a['x'] - b['x']
                dy = a['y'] - b['y']
                dist_sq = dx*dx + dy*dy
                if dist_sq < 0.1: dist_sq = 0.1
                
                # Performance opt: Ignore far away nodes
                if dist_sq > 25000: continue 

                f = REPULSION / dist_sq
                dist = math.sqrt(dist_sq)
                fx += (dx / dist) * f
                fy += (dy / dist) * f

            a['vx'] = (a['vx'] + fx) * DAMPING
            a['vy'] = (a['vy'] + fy) * DAMPING

        # 3. Attraction (Links)
        for u, v in self.links:
            a = self.nodes[u]
            b = self.nodes[v]
            dx = b['x'] - a['x']
            dy = b['y'] - a['y']
            fx = dx * ATTRACTION
            fy = dy * ATTRACTION
            
            if u != self.dragged_node_idx:
                a['vx'] += fx
                a['vy'] += fy
            if v != self.dragged_node_idx:
                b['vx'] -= fx
                b['vy'] -= fy

        # 4. Apply & Measure Energy
        for i, n in enumerate(self.nodes):
            if i == self.dragged_node_idx: continue
            n['x'] += n['vx']
            n['y'] += n['vy']
            total_kinetic_energy += (abs(n['vx']) + abs(n['vy']))

        # 5. Sleep Threshold
        if total_kinetic_energy < 0.5:
            self.settled = True

    # --- RENDERING ---

    def get_image_bytes(self):
        self.surface.fill(self.bg_color)
        
        cx, cy = self.width / 2, self.height / 2
        def to_screen(x, y):
            sx = (x - cx + self.cam_x) * self.zoom + cx
            sy = (y - cy + self.cam_y) * self.zoom + cy
            return int(sx), int(sy)

        # Links
        for u, v in self.links:
            if self.zoom < 1.2:
                if self.nodes[u].get('type') == 'chunk' or self.nodes[v].get('type') == 'chunk':
                    continue

            start = to_screen(self.nodes[u]['x'], self.nodes[u]['y'])
            end = to_screen(self.nodes[v]['x'], self.nodes[v]['y'])
            pygame.draw.line(self.surface, (60, 60, 80), start, end, 1)

        # Nodes
        for i, n in enumerate(self.nodes):
            # LOD: Hide chunks if zoomed out
            if self.zoom < 1.2 and n.get('type') == 'chunk':
                continue

            sx, sy = to_screen(n['x'], n['y'])
            if sx < -20 or sx > self.width + 20 or sy < -20 or sy > self.height + 20: continue
                
            rad = int(n['_radius'] * self.zoom)
            col = n['_color']
            
            if i == self.hovered_node_idx or i == self.dragged_node_idx:
                pygame.draw.circle(self.surface, (255, 255, 255), (sx, sy), rad + 2)
            
            pygame.draw.circle(self.surface, col, (sx, sy), rad)
            
            if self.zoom > 0.8 or i == self.hovered_node_idx:
                text = self.font.render(n['label'], True, (200, 200, 200))
                self.surface.blit(text, (sx + rad + 4, sy - 6))

        return pygame.image.tostring(self.surface, 'RGB')


--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_GraphEngineMS\graph_view.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import sqlite3
import json
import os
from .graph_engine import GraphRenderer

class GraphView(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.pack(fill="both", expand=True)
        
        # UI Container
        self.canvas_lbl = tk.Label(self, bg="#101018", cursor="crosshair")
        self.canvas_lbl.pack(fill="both", expand=True)
        
        # Engine Init
        self.engine = GraphRenderer(800, 600)
        self.photo = None 
        
        # Input State
        self.last_mouse_x = 0
        self.last_mouse_y = 0
        self.is_dragging_node = False
        self.is_panning = False

        # Bindings
        self.canvas_lbl.bind('<Button-1>', self.on_click)
        self.canvas_lbl.bind('<Double-Button-1>', self.on_double_click)
        self.canvas_lbl.bind('<ButtonRelease-1>', self.on_release)
        self.canvas_lbl.bind('<B1-Motion>', self.on_drag)
        self.canvas_lbl.bind('<Motion>', self.on_hover)
        self.canvas_lbl.bind('<Button-4>', lambda e: self.on_zoom(1.1)) # Linux Scroll Up
        self.canvas_lbl.bind('<Button-5>', lambda e: self.on_zoom(0.9)) # Linux Scroll Down
        self.canvas_lbl.bind('<MouseWheel>', self.on_windows_scroll)    # Windows Scroll
        self.canvas_lbl.bind('<Configure>', self.on_resize)
        
        # Start the Heartbeat
        self.animate()

    def load_from_db(self, db_path):
        """
        Loads graph data from SQLite.
        Does NOT block the UI. The physics engine will settle the nodes frame-by-frame.
        """
        if not os.path.exists(db_path): return
        
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # [cite_start]Fetch Nodes [cite: 198]
            db_nodes = cursor.execute("SELECT id, type, label, data_json FROM graph_nodes").fetchall()
            
            # [cite_start]Fetch Edges [cite: 198]
            db_edges = cursor.execute("SELECT source, target FROM graph_edges").fetchall()
            
            conn.close()
        except Exception as e:
            print(f"Graph Load Error: {e}")
            return

        # Format for Engine
        id_to_index = {}
        formatted_nodes = []
        
        for idx, row in enumerate(db_nodes):
            node_id, n_type, label, raw_json = row
            meta = {}
            try:
                if raw_json: meta = json.loads(raw_json)
            except: pass
            
            id_to_index[node_id] = idx
            formatted_nodes.append({'id': node_id, 'type': n_type, 'label': label, 'meta': meta})

        formatted_links = []
        for src, tgt in db_edges:
            if src in id_to_index and tgt in id_to_index:
                formatted_links.append((id_to_index[src], id_to_index[tgt]))

        # Inject Data - The Physics Engine handles the "Explosion" logic internally
        self.engine.set_data(formatted_nodes, formatted_links)

    def on_resize(self, event):
        if event.width > 1 and event.height > 1:
            self.engine.resize(event.width, event.height)

    def on_double_click(self, event):
        # Zoom in on the node we clicked
        hit_node = self.engine.get_node_at(event.x, event.y)
        if hit_node:
            # Center camera on node and zoom in
            self.engine.cam_x = hit_node['x']
            self.engine.cam_y = hit_node['y']
            self.engine.zoom = 2.0
            self.engine.settled = False

    def on_click(self, event):
        self.last_mouse_x = event.x
        self.last_mouse_y = event.y
        
        # Check if we clicked a node
        hit = self.engine.handle_mouse_down(event.x, event.y)
        if hit:
            self.is_dragging_node = True
        else:
            self.is_panning = True

    def on_release(self, event):
        self.engine.handle_mouse_up()
        self.is_dragging_node = False
        self.is_panning = False

    def on_drag(self, event):
        if self.is_dragging_node:
            self.engine.handle_mouse_move(event.x, event.y, True)
        elif self.is_panning:
            # Camera Pan
            dx = event.x - self.last_mouse_x
            dy = event.y - self.last_mouse_y
            self.engine.pan(dx, dy)
            
        self.last_mouse_x = event.x
        self.last_mouse_y = event.y

    def on_hover(self, event):
        if not self.is_dragging_node:
            self.engine.handle_mouse_move(event.x, event.y, False)

    def on_zoom(self, amount):
        self.engine.zoom_camera(amount, 0, 0)
        self.engine.settled = False # Wake up physics on zoom

    def on_windows_scroll(self, event):
        if event.delta > 0: self.on_zoom(1.1)
        else: self.on_zoom(0.9)

    def animate(self):
        """
        The Heartbeat Loop. 
        Runs at ~30 FPS. Handles Physics + Rendering.
        """
        # 1. Step Physics (Micro-calculations)
        self.engine.step_physics()
        
        # 2. Render to Buffer
        raw_data = self.engine.get_image_bytes()
        
        # 3. Blit to Screen
        if raw_data:
            img = Image.frombytes('RGB', (self.engine.width, self.engine.height), raw_data)
            self.photo = ImageTk.PhotoImage(img)
            self.canvas_lbl.configure(image=self.photo)
        
        # 4. Loop
        self.after(30, self.animate)
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_IngestEngineMS\ingest_engine.py
--------------------------------------------------------------------------------
import os
import time
import re
import sqlite3
import requests
import json
from typing import List, Generator, Dict, Any, Optional
from dataclasses import dataclass
from .semantic_chunker import SemanticChunker

# Optional Libraries for Enhanced Ingestion
try:
    import pypdf
except ImportError:
    pypdf = None

try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

# Configuration
OLLAMA_API_URL = "http://localhost:11434/api"

@dataclass
class IngestStatus:
    current_file: str
    progress_percent: float
    processed_files: int
    total_files: int
    log_message: str
    thought_frame: Optional[Dict] = None

class SynapseWeaver:
    """
    Parses source code to extract import dependencies.
    """
    def __init__(self):
        self.py_pattern = re.compile(r'^\s*(?:from|import)\s+([\w\.]+)')
        self.js_pattern = re.compile(r'(?:import\s+.*?from\s+[\'"]|require\([\'"])([\.\/\w\-_]+)[\'"]')

    def extract_dependencies(self, content: str, file_path: str) -> List[str]:
        dependencies = []
        # Only parse code files for dependencies
        if not file_path.endswith(('.py', '.js', '.ts', '.tsx', '.jsx')):
            return []

        lines = content.split('\n')
        for line in lines:
            match = None
            if file_path.endswith('.py'):
                match = self.py_pattern.match(line)
            else:
                match = self.js_pattern.search(line)
            
            if match:
                raw_dep = match.group(1)
                clean_dep = raw_dep.split('.')[-1].split('/')[-1]
                if clean_dep not in dependencies:
                    dependencies.append(clean_dep)
        return dependencies

class IngestEngine:
    """
    The Heavy Lifter: Reads Files (Code, PDF, MD) & Websites.
    """
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.stop_signal = False
        self.weaver = SynapseWeaver()
        self.chunker = SemanticChunker()

    def abort(self):
        self.stop_signal = True

    def check_ollama_connection(self) -> bool:
        try:
            requests.get(f"{OLLAMA_API_URL}/tags", timeout=2)
            return True
        except:
            return False

    def get_available_models(self) -> List[str]:
        try:
            res = requests.get(f"{OLLAMA_API_URL}/tags")
            if res.status_code == 200:
                data = res.json()
                return [m['name'] for m in data.get('models', [])]
        except:
            pass
        return []

    def process_files(self, file_paths: List[str], embed_model: str = "none", summary_model: str = "none") -> Generator[IngestStatus, None, None]:
        total = len(file_paths)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("PRAGMA synchronous = OFF")
        cursor.execute("PRAGMA journal_mode = MEMORY")

        # --- STEP 0: STAMP MANIFEST ---
        # Note: manifest table is also created during DB creation, but keep this for safety.
        cursor.execute("CREATE TABLE IF NOT EXISTS manifest (key TEXT PRIMARY KEY, value TEXT)")

        # Record the models used for this ingest in a single structured blob.
        ingest_models_obj = {"embed_model": embed_model, "summary_model": summary_model}
        cursor.execute(
            "INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)",
            ("ingest_models", json.dumps(ingest_models_obj))
        )

        # Standard run metadata
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("last_ingest_time", str(time.time())))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("file_count", str(total)))

        # Initialize provenance if not present (do not overwrite if DB creator/UI already set it)
        cursor.execute("INSERT OR IGNORE INTO manifest (key, value) VALUES (?, ?)", ("source_provenance", "{}"))

        # Cartridge interpretation hints (do not overwrite if UI already set these)
        cursor.execute("INSERT OR IGNORE INTO manifest (key, value) VALUES (?, ?)", ("artifact_type", "unknown"))

        artifact_profile_obj = {
            "embed_model": embed_model,
            "summary_model": summary_model,
            "vfs_strategy": "relpath_from_scan_root_v1",
            "supports_graph_weaving": True,
            "notes": "artifact_type/profile may be overridden by UI in future"
        }
        cursor.execute("INSERT OR IGNORE INTO manifest (key, value) VALUES (?, ?)", ("artifact_profile", json.dumps(artifact_profile_obj)))

        conn.commit()

        node_registry = {}
        file_contents = {}

        # Compute a stable scan_root for filesystem inputs so VFS paths can be portable.
        fs_paths = [p for p in file_paths if not (p.startswith("http://") or p.startswith("https://"))]
        scan_root = ""
        if fs_paths:
            try:
                scan_root = os.path.commonpath(fs_paths)
            except Exception:
                scan_root = ""

        # Persist scan_root (do not overwrite if UI already set it)
        try:
            cursor.execute("INSERT OR IGNORE INTO manifest (key, value) VALUES (?, ?)", ("scan_root", scan_root))
            cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("vfs_strategy", "relpath_from_scan_root_v1"))
            conn.commit()
        except Exception:
            pass

        # --- PHASE 1: INGESTION ---
        for idx, file_path in enumerate(file_paths):
            if self.stop_signal:
                yield IngestStatus(file_path, 0, idx, total, "Ingestion Aborted.")
                break

            filename = os.path.basename(file_path)
            if not filename and file_path.startswith("http"):
                filename = file_path.replace("https://", "").replace("http://", "").replace("/", "_")[:50]

            content = ""
            origin_type = 'filesystem'

            # 1. READ CONTENT (Universal Reader Logic)
            try:
                if file_path.startswith("http://") or file_path.startswith("https://"):
                    # --- WEB ---
                    origin_type = 'web'
                    yield IngestStatus(filename, (idx/total)*100, idx, total, f"Fetching URL: {file_path}...")
                    
                    resp = requests.get(file_path, timeout=10)
                    resp.raise_for_status()
                    
                    if BeautifulSoup:
                        soup = BeautifulSoup(resp.content, 'html.parser')
                        # Remove script/style
                        for script in soup(["script", "style"]): script.extract()
                        content = soup.get_text()
                    else:
                        # Fallback regex strip
                        content = re.sub('<[^<]+?>', '', resp.text)
                    
                    # Clean up whitespace
                    lines = (line.strip() for line in content.splitlines())
                    content = '\n'.join(chunk for chunk in lines if chunk)

                elif file_path.lower().endswith(".pdf"):
                    # --- PDF ---
                    if not pypdf:
                        yield IngestStatus(filename, (idx/total)*100, idx, total, "Skipping PDF (pypdf not installed)")
                        continue
                    
                    yield IngestStatus(filename, (idx/total)*100, idx, total, "Extracting PDF text...")
                    with open(file_path, 'rb') as f:
                        reader = pypdf.PdfReader(f)
                        text_pages = []
                        for page in reader.pages:
                            text_pages.append(page.extract_text())
                        content = "\n\n".join(text_pages)

                else:
                    # --- TEXT / CODE / MD ---
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()

            except Exception as e:
                yield IngestStatus(filename, (idx/total)*100, idx, total, f"Read Error: {e}")
                continue

            # Derive portable VFS path + stable node_id now that origin_type is known
            if origin_type == 'web':
                vfs_path = filename
                file_key = file_path  # URLs are stable enough as identity
                node_id = file_path
                node_label = filename
            else:
                if scan_root:
                    rel = os.path.relpath(file_path, scan_root)
                    rel = rel.replace('\\', '/')
                    vfs_path = rel
                else:
                    vfs_path = filename

                file_key = vfs_path
                node_id = vfs_path
                node_label = filename

            # Cache content for weaving keyed by stable node_id
            file_contents[node_id] = content

            # 2. Summarize
            summary_text = ""
            if summary_model != "none":
                yield IngestStatus(filename, (idx/total)*100, idx, total, f"Summarizing with {summary_model}...")
                summary_text = self._generate_summary(summary_model, content[:3000])

            # 3. Track File
            try:
                meta_obj = {"summary": summary_text, "tags": []}
                meta_json = json.dumps(meta_obj)

                cursor.execute("""
                    INSERT OR REPLACE INTO files 
                    (path, content, last_updated, origin_type, origin_path, vfs_path, metadata) 
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (file_key, content, time.time(), origin_type, file_path, vfs_path, meta_json))
                
                file_id = cursor.lastrowid
            except sqlite3.Error as e:
                yield IngestStatus(file_path, (idx/total)*100, idx, total, f"DB Error: {e}")
                continue

            # 4. Graph Node
            node_type = 'web' if origin_type == 'web' else 'file'
            cursor.execute("""
                INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json)
                VALUES (?, ?, ?, ?)
            """, (node_id, node_type, node_label, json.dumps({"origin_path": file_path, "vfs_path": vfs_path})))

            node_registry[node_id] = node_id

            # 5. Chunking & Embedding
            # Note: SemanticChunker handles generic text via _chunk_generic
            chunks = self.chunker.chunk_file(content, filename)

            for i, chunk_obj in enumerate(chunks):
                chunk_text = chunk_obj.content
                if self.stop_signal: break
                
                embedding = None
                if embed_model != "none":
                    embedding = self._get_embedding(embed_model, chunk_text)
                
                emb_blob = json.dumps(embedding).encode('utf-8') if embedding else None
                
                cursor.execute("""
                INSERT INTO chunks (file_id, chunk_index, content, embedding, name, type, start_line, end_line)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (file_id, i, chunk_text, emb_blob, chunk_obj.name, chunk_obj.type, chunk_obj.start_line, chunk_obj.end_line))

                # --- SATELLITE NODE ---
                chunk_node_id = f"{node_id}::{chunk_obj.name}"
                cursor.execute("""
                    INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json)
                    VALUES (?, ?, ?, ?)
                """, (chunk_node_id, 'chunk', chunk_obj.name, json.dumps({"parent": node_id})))

                cursor.execute("""
                    INSERT OR IGNORE INTO graph_edges (source, target, weight)
                    VALUES (?, ?, 2.0)
                """, (chunk_node_id, node_id))

                # Visual Feedback
                thought_frame = {
                    "id": f"{file_id}_{i}",
                    "file": f"{filename} [{chunk_obj.name}]",
                    "chunk_index": i,
                    "content": chunk_text,
                    "vector_preview": embedding[:20] if embedding else [],
                    "concept_color": "#E02080" if origin_type == 'web' else "#007ACC"
                }
                
                yield IngestStatus(
                    current_file=filename,
                    progress_percent=((idx + (i/len(chunks))) / total) * 100,
                    processed_files=idx,
                    total_files=total,
                    log_message=f"Processing {filename}...",
                    thought_frame=thought_frame
                )

            conn.commit()

        # --- PHASE 2: WEAVING ---
        # (Only relevant for code/text files, websites typically don't have python 'imports')
        if any(f.endswith('.py') or f.endswith('.js') for f in file_paths):
            yield IngestStatus("Graph", 100, total, total, "Weaving Knowledge Graph...")
            
            for source_id, content in file_contents.items():
                if self.stop_signal: break
                deps = self.weaver.extract_dependencies(content, source_id)
                for dep in deps:
                    target_id = None
                    for potential_match in node_registry.keys():
                        base = os.path.basename(potential_match)
                        base_no_ext = os.path.splitext(base)[0]
                        if base == dep or base_no_ext == dep or potential_match.startswith(dep + '.') or potential_match == dep:
                            target_id = potential_match
                            break
                    if target_id and target_id != source_id:
                        try:
                            cursor.execute("INSERT OR IGNORE INTO graph_edges (source, target, weight) VALUES (?, ?, 1.0)", (source_id, target_id))
                        except: pass

        # --- PHASE 3: WRITE CARTRIDGE BOOT FILES (Self-Describing DB for downstream RAG) ---
        try:
            now_ts = time.time()

            # Build a lightweight inventory for INDEX.json
            ext_counts = {}
            for fp in file_paths:
                ext = os.path.splitext(fp)[1].lower() or "(none)"
                ext_counts[ext] = ext_counts.get(ext, 0) + 1

            index_obj = {
                "schema": "neocortex.cartridge.index.v1",
                "generated_at": now_ts,
                "file_count": total,
                "extensions": ext_counts,
                "scan_root": scan_root,
                "vfs_strategy": "relpath_from_scan_root_v1",
                "ingest": {
                    "embed_model": embed_model,
                    "summary_model": summary_model
                },
                "graph": {
                    "dependency_edges_created": None
                },
                "boot": {
                    "readme_vfs": "__cartridge__/README.md",
                    "index_vfs": "__cartridge__/INDEX.json"
                }
            }

            readme_text = (
                "# Neural Cartridge (NeoCORTEX)\n\n"
                "This SQLite database is a *self-describing knowledge cartridge* produced by _NeoCORTEX.\n"
                "It contains ingested source material (files/pages), semantic chunks, vector embeddings, and optional graph wiring.\n\n"
                "## Boot Protocol\n"
                "- Read the manifest table first: `SELECT key, value FROM manifest`\n"
                "- Then read this file and `__cartridge__/INDEX.json` from the `files` table via `vfs_path`.\n\n"
                "## Path Contract\n"
                "- `origin_path` is provenance (absolute filesystem path or URL)\n"
                "- `vfs_path` is the cartridge-internal portable path\n"
                f"- scan_root: {scan_root}\n"
                "- vfs_strategy: relpath_from_scan_root_v1\n\n"
                "## Tables (High Level)\n"
                "- files: full source content + provenance\n"
                "- chunks: semantic segments (may include embeddings)\n"
                "- graph_nodes / graph_edges: optional structural wiring\n\n"
                "## Ingest Metadata\n"
                f"- embed_model: {embed_model}\n"
                f"- summary_model: {summary_model}\n"
                f"- file_count: {total}\n"
            )

            boot_meta_readme = json.dumps({"summary": "Cartridge boot README", "tags": ["__cartridge__", "boot", "readme"]})
            boot_meta_index = json.dumps({"summary": "Cartridge inventory index", "tags": ["__cartridge__", "boot", "index"]})

            cursor.execute(
                """
                INSERT OR REPLACE INTO files
                (path, content, last_updated, origin_type, origin_path, vfs_path, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    "__cartridge__/README.md",
                    readme_text,
                    now_ts,
                    "system",
                    "__cartridge__",
                    "__cartridge__/README.md",
                    boot_meta_readme
                )
            )

            cursor.execute(
                """
                INSERT OR REPLACE INTO files
                (path, content, last_updated, origin_type, origin_path, vfs_path, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    "__cartridge__/INDEX.json",
                    json.dumps(index_obj, indent=2),
                    now_ts,
                    "system",
                    "__cartridge__",
                    "__cartridge__/INDEX.json",
                    boot_meta_index
                )
            )

            cursor.execute(
                "INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)",
                ("boot_files", json.dumps(["__cartridge__/README.md", "__cartridge__/INDEX.json"]))
            )

            conn.commit()
        except Exception:
            # Never fail the ingest just because boot files couldn't be written
            pass

        conn.commit()
        conn.close()

        yield IngestStatus(
            current_file="Complete",
            progress_percent=100,
            processed_files=total,
            total_files=total,
            log_message=f"Ingestion Complete. {total} items processed. Boot files written to __cartridge__/."
        )

    def _get_embedding(self, model: str, text: str) -> Optional[List[float]]:
        try:
            res = requests.post(f"{OLLAMA_API_URL}/embeddings", json={"model": model, "prompt": text}, timeout=30)
            if res.status_code == 200: return res.json().get("embedding")
        except: return None
        return None

    def _generate_summary(self, model: str, text: str) -> str:
        try:
            prompt = f"Summarize this text in one concise sentence:\n\n{text}"
            res = requests.post(f"{OLLAMA_API_URL}/generate", json={"model": model, "prompt": prompt, "stream": False}, timeout=10)
            if res.status_code == 200: return res.json().get("response", "").strip()
        except: return ""

--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_IngestEngineMS\semantic_chunker.py
--------------------------------------------------------------------------------
import ast
import re
from dataclasses import dataclass
from typing import List, Dict, Optional

@dataclass
class CodeChunk:
    name: str          # e.g., "class AuthMS" or "def login"
    type: str          # "class", "function", "text"
    content: str       # The raw source code
    start_line: int
    end_line: int
    docstring: str = ""

class SemanticChunker:
    """
    Intelligent Code Splitter.
    Parses source code into logical units (Classes, Functions) rather than random windows.
    """
    
    def chunk_file(self, content: str, filename: str) -> List[CodeChunk]:
        if filename.endswith(".py"):
            return self._chunk_python(content)
        return self._chunk_generic(content)

    def _chunk_python(self, source: str) -> List[CodeChunk]:
        chunks = []
        try:
            tree = ast.parse(source)
            lines = source.splitlines(keepends=True)
            
            def get_segment(node):
                start = node.lineno - 1
                end = node.end_lineno if hasattr(node, 'end_lineno') else start + 1
                return "".join(lines[start:end]), start + 1, end

            for node in tree.body:
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ""
                    chunks.append(CodeChunk(
                        name=f"def {node.name}", type="function", 
                        content=text, start_line=s, end_line=e, docstring=doc
                    ))
                elif isinstance(node, ast.ClassDef):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ""
                    chunks.append(CodeChunk(
                        name=f"class {node.name}", type="class", 
                        content=text, start_line=s, end_line=e, docstring=doc
                    ))

            if not chunks:
                return self._chunk_generic(source)
                
        except SyntaxError:
            return self._chunk_generic(source)
            
        return chunks

    def _chunk_generic(self, text: str, window_size: int = 1500) -> List[CodeChunk]:
        chunks = []
        lines = text.splitlines(keepends=True)
        current_chunk = []
        current_size = 0
        chunk_idx = 1
        start_line = 1
        
        for i, line in enumerate(lines):
            current_chunk.append(line)
            current_size += len(line)
            
            if current_size >= window_size:
                chunks.append(CodeChunk(
                    name=f"Chunk {chunk_idx}", type="text_block",
                    content="".join(current_chunk), start_line=start_line, end_line=i + 1
                ))
                current_chunk = []
                current_size = 0
                chunk_idx += 1
                start_line = i + 2
                
        if current_chunk:
            chunks.append(CodeChunk(
                name=f"Chunk {chunk_idx}", type="text_block",
                content="".join(current_chunk), start_line=start_line, end_line=len(lines)
            ))
            
        return chunks
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_LibrarianServiceMS\librarian_service.py
--------------------------------------------------------------------------------
import os
import sqlite3
import time
import uuid
import difflib
import logging
import json
from pathlib import Path
from typing import List, Dict, Optional, Any

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger("Librarian")

class LibrarianMS:
    """
    The Factory Foreman: Manages the creation and 'sealing' of Cortex Cartridges (.db files).
    Ensures that every exported DB contains a 'Manifest' so external Agents know how to read it.
    """
    
    def __init__(self, storage_dir: str = "./cortex_dbs"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)

    # --- KB Management ---

    def list_kbs(self) -> List[str]:
        if not self.storage_dir.exists():
            return []
        files = list(self.storage_dir.glob("*.db"))
        files.sort(key=os.path.getmtime, reverse=True)
        return [f.name for f in files]

    def create_kb(self, name: str) -> Dict[str, str]:
        safe_name = self._sanitize_name(name)
        db_path = self.storage_dir / safe_name
        
        if db_path.exists():
            raise FileExistsError(f"Knowledge Base '{safe_name}' already exists.")

        try:
            self._init_schema(db_path)
            return {"status": "success", "path": str(db_path), "name": safe_name}
        except Exception as e:
            if db_path.exists(): os.remove(db_path)
            raise e

    def delete_kb(self, name: str):
        db_path = self.storage_dir / name
        if db_path.exists():
            os.remove(db_path)
            # Clean up potential WAL/SHM files
            for ext in ['-wal', '-shm']:
                aux = self.storage_dir / (name + ext)
                if aux.exists(): os.remove(aux)

    def _init_schema(self, db_path: Path):
        """Initializes the Standard Cortex Schema."""
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("PRAGMA journal_mode=WAL")
        
        # 1. Manifest (The "Label" for the Agent)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS manifest (
                key TEXT PRIMARY KEY, 
                value TEXT
            )
        """)
        
        # 2. Graph (The Neural Structure)
        cursor.execute("CREATE TABLE IF NOT EXISTS graph_nodes (id TEXT PRIMARY KEY, type TEXT, label TEXT, data_json TEXT)")
        cursor.execute("CREATE TABLE IF NOT EXISTS graph_edges (source TEXT, target TEXT, weight REAL)")

        # 3. Files (The Artifacts)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT UNIQUE NOT NULL,      -- Internal ID
                content TEXT,                   -- Full text snapshot
                origin_type TEXT DEFAULT 'filesystem', 
                origin_path TEXT,               
                vfs_path TEXT,                  -- Relative export path
                metadata TEXT DEFAULT '{}',     -- Tags/Authors
                last_updated TIMESTAMP,
                status TEXT DEFAULT 'indexed'
            )
        """)

        # 4. Chunks (The Vectors)
        # Note: We store embedding as a BLOB (JSON bytes) for maximum portability.
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS chunks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            file_id INTEGER,
            chunk_index INTEGER,
            content TEXT,
            embedding BLOB,     -- JSON UTF-8 Bytes
            name TEXT,          
            type TEXT,          
            start_line INTEGER,
            end_line INTEGER,
            FOREIGN KEY(file_id) REFERENCES files(id)
        )
        """)

        # 5. Diff Log (History)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS diff_log (
                id TEXT PRIMARY KEY,
                file_path TEXT NOT NULL,
                timestamp TIMESTAMP,
                change_type TEXT,
                diff_blob TEXT,
                author TEXT
            )
        """)
        
        # Set Creation Timestamp + Standard Cartridge Manifest Defaults
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("created_at", str(time.time())))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("schema_version", "1.0"))

        # Core identity + interpretation hints (so external Agents know what this DB *is*)
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("cartridge_id", str(uuid.uuid4())))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("artifact_type", "unknown"))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("artifact_profile", "{}"))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("root_vfs", "/"))

        # Boot-strapping cards for RAG consumers
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("entrypoints", "[]"))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("ingest_models", "{}"))
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", ("source_provenance", "{}"))
        
        conn.commit()
        conn.close()

    def update_manifest(self, db_name: str, key: str, value: str):
        """Updates the manifest. Used by IngestEngine to record Model Names."""
        db_path = self.storage_dir / db_name
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", (key, str(value)))
        conn.commit()
        conn.close()

    # --- File Versioning ---

    def update_file(self, db_name: str, file_path: str, new_content: str, 
                   author: str = "user", origin_type: str = "filesystem", 
                   origin_path: str = None, metadata: dict = None) -> Dict[str, Any]:
        """Updates a file and logs the diff."""
        db_path = self.storage_dir / db_name
        if not db_path.exists(): raise FileNotFoundError("KB not found")

        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        now = time.time()
        meta_json = json.dumps(metadata) if metadata else "{}"

        try:
            cursor.execute("SELECT id, content FROM files WHERE path = ?", (file_path,))
            row = cursor.fetchone()

            if not row:
                # CREATE
                cursor.execute(
                    """INSERT INTO files 
                       (path, content, last_updated, origin_type, origin_path, vfs_path, metadata) 
                       VALUES (?, ?, ?, ?, ?, ?, ?)""",
                    (file_path, new_content, now, origin_type, origin_path or file_path, file_path, meta_json)
                )
                self._log_diff(cursor, file_path, "CREATE", "[New File]", author, now)
                conn.commit()
                return {"status": "created", "path": file_path}

            # EDIT
            old_content = row['content'] or ""
            diff_text = self._compute_diff(file_path, old_content, new_content)
            
            if not diff_text:
                return {"status": "unchanged", "path": file_path}

            self._log_diff(cursor, file_path, "EDIT", diff_text, author, now)
            cursor.execute(
                "UPDATE files SET content = ?, last_updated = ?, metadata = ? WHERE path = ?",
                (new_content, now, meta_json, file_path)
            )
            conn.commit()
            return {"status": "updated", "path": file_path, "diff_size": len(diff_text)}

        finally:
            conn.close()

    def get_file_content(self, db_name: str, file_path: str) -> Optional[str]:
        db_path = self.storage_dir / db_name
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT content FROM files WHERE path = ?", (file_path,))
        row = cursor.fetchone()
        conn.close()
        return row[0] if row else None

    def list_files_in_kb(self, db_name: str) -> List[str]:
        db_path = self.storage_dir / db_name
        if not db_path.exists(): return []
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        rows = cursor.execute("SELECT path FROM files ORDER BY path ASC").fetchall()
        conn.close()
        return [r[0] for r in rows]

    # --- Helpers ---

    def _compute_diff(self, path: str, old: str, new: str) -> str:
        old_lines = old.splitlines(keepends=True)
        new_lines = new.splitlines(keepends=True)
        diff_gen = difflib.unified_diff(
            old_lines, new_lines, 
            fromfile=f"a/{path}", tofile=f"b/{path}",
            lineterm=''
        )
        return "".join(diff_gen)

    def _log_diff(self, cursor, path, change_type, diff_text, author, timestamp):
        diff_id = str(uuid.uuid4())
        cursor.execute(
            "INSERT INTO diff_log (id, file_path, timestamp, change_type, diff_blob, author) VALUES (?, ?, ?, ?, ?, ?)",
            (diff_id, path, timestamp, change_type, diff_text, author)
        )

    def _sanitize_name(self, name: str) -> str:
        # Enforce .db extension strictly to ensure visibility in list_kbs
        if name.endswith('.db'):
            name = name[:-3]
        
        # Sanitize the base name (strip dots/special chars)
        clean_base = "".join(c for c in name if c.isalnum() or c in (' ', '_', '-')).strip()
        clean_base = clean_base.replace(' ', '_')
        
        return f"{clean_base}.db"



--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_ScannerMS\scanner.py
--------------------------------------------------------------------------------
import os
import time
import requests
from urllib.parse import urljoin, urlparse
from typing import Dict, List, Any, Optional

# Try imports for Web/PDF support
try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

class ScannerMS:
    """
    The Scanner: Walks file systems OR crawls websites (Depth-Aware).
    """
    
    def __init__(self):
        self.IGNORE_DIRS = {
            '.git', '__pycache__', 'node_modules', 'venv', '.env', 
            '.idea', '.vscode', 'dist', 'build', 'coverage', 'site-packages'
        }
        self.BINARY_EXTENSIONS = {
            '.pyc', '.pyd', '.exe', '.dll', '.so', '.dylib', '.class', 
            '.jpg', '.jpeg', '.png', '.gif', '.ico', 
            '.zip', '.tar', '.gz', '.docx', '.xlsx',
            '.db', '.sqlite', '.sqlite3'
        }
        self.visited_urls = set()

    def is_binary(self, file_path: str) -> bool:
        _, ext = os.path.splitext(file_path)
        if ext.lower() in self.BINARY_EXTENSIONS: return True
        return False

    def scan_directory(self, root_path: str, web_depth: int = 0) -> Optional[Dict[str, Any]]:
        """
        Main Entry Point.
        :param root_path: File path or URL.
        :param web_depth: How many links deep to crawl (0 = single page).
        """
        # 1. Web Crawl Mode
        if root_path.startswith("http://") or root_path.startswith("https://"):
            self.visited_urls.clear()
            return self._crawl_web_recursive(root_path, depth=web_depth, origin_domain=urlparse(root_path).netloc)

        # 2. Local File System Mode
        target = os.path.abspath(root_path)
        if not os.path.exists(target): return None
        
        if not os.path.isdir(target): 
            return self._create_node(target, is_dir=False)
            
        return self._scan_fs_recursive(target)

    # --- Web Logic ---
    def _crawl_web_recursive(self, url: str, depth: int, origin_domain: str) -> Dict[str, Any]:
        """
        Recursively fetches links.
        """
        node = {
            'text': url, 
            'path': url, 
            'type': 'web', 
            'children': [], 
            'checked': True
        }
        
        if depth < 0 or url in self.visited_urls: return node
        self.visited_urls.add(url)

        if depth > 0 and BeautifulSoup:
            try:
                # Polite Delay
                time.sleep(0.1)
                resp = requests.get(url, timeout=5)
                if resp.status_code == 200:
                    soup = BeautifulSoup(resp.content, 'html.parser')
                    for link in soup.find_all('a', href=True):
                        full_url = urljoin(url, link['href'])
                        parsed = urlparse(full_url)
                        
                        # Filter: Only same domain, valid schemes
                        if parsed.netloc == origin_domain and parsed.scheme in ['http', 'https']:
                            if full_url not in self.visited_urls:
                                child_node = self._crawl_web_recursive(full_url, depth - 1, origin_domain)
                                node['children'].append(child_node)
            except Exception as e:
                node['error'] = str(e)
                
        return node

    # --- File System Logic ---
    def _scan_fs_recursive(self, current_path: str) -> Dict[str, Any]:
        node = self._create_node(current_path, is_dir=True)
        node['children'] = []
        try:
            with os.scandir(current_path) as it:
                entries = sorted(it, key=lambda e: (not e.is_dir(), e.name.lower()))
                for entry in entries:
                    if entry.is_dir() and entry.name in self.IGNORE_DIRS: continue
                    if entry.name.startswith('.'): continue

                    if entry.is_dir():
                        child = self._scan_fs_recursive(entry.path)
                        if child: node['children'].append(child)
                    else:
                        node['children'].append(self._create_node(entry.path, is_dir=False))
        except PermissionError:
            node['error'] = "Access Denied"
        return node

    def _create_node(self, path: str, is_dir: bool) -> Dict[str, Any]:
        name = os.path.basename(path)
        node = {'text': name, 'path': path, 'type': 'folder' if is_dir else 'file', 'checked': False}
        if not is_dir and self.is_binary(path): node['type'] = 'binary'
        return node

    def flatten_tree(self, tree_node: Dict[str, Any]) -> List[str]:
        files = []
        if tree_node['type'] in ['file', 'web']:
            files.append(tree_node['path'])
        elif 'children' in tree_node:
            for child in tree_node['children']:
                files.extend(self.flatten_tree(child))
        return files
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_SearchEngineMS\search_engine.py
--------------------------------------------------------------------------------
import sqlite3
import json
import struct
import requests
import os
import math
from typing import List, Dict, Any, Optional

# Configuration
OLLAMA_API_URL = "http://localhost:11434/api"

class SearchEngineMS:
    """
    The Oracle: Performs Hybrid Search (Vector Similarity + Keyword Matching).
    Includes a pure-Python fallback for vector math if sqlite-vec is missing.
    """

    def __init__(self, embed_model: str = "nomic-embed-text"):
        self.embed_model = embed_model
        self.vec_extension_loaded = False

    def _load_extension(self, conn: sqlite3.Connection):
        """Attempts to load sqlite-vec if available."""
        try:
            conn.enable_load_extension(True)
            import sqlite_vec
            sqlite_vec.load(conn)
            self.vec_extension_loaded = True
        except (ImportError, AttributeError, sqlite3.OperationalError):
            # Silently fail and fallback to Python math
            self.vec_extension_loaded = False

    def search(self, db_path: str, query: str, limit: int = 10) -> List[Dict]:
        if not os.path.exists(db_path):
            return []

        conn = sqlite3.connect(db_path)
        self._load_extension(conn)
        cursor = conn.cursor()

        # 1. Vectorize Query
        query_vec = self._get_query_embedding(query)
        if not query_vec:
            # Fallback to keyword only if embedding fails (e.g. Ollama offline)
            conn.close()
            return self._keyword_search_fallback(db_path, query, limit)

        results = []
        
        try:
            if self.vec_extension_loaded:
                # FAST PATH: C++ Extension
                results = self._search_sqlite_vec(cursor, query_vec, limit)
            else:
                # SLOW PATH: Python Math (Robustness)
                results = self._search_pure_python(cursor, query_vec, limit)
        except Exception as e:
            print(f"[SearchEngine] Error: {e}")
            results = self._keyword_search_fallback(db_path, query, limit)

        conn.close()
        return results

    def _search_sqlite_vec(self, cursor, query_vec: List[float], limit: int) -> List[Dict]:
        """Used when sqlite-vec is successfully loaded."""
        vec_bytes = struct.pack(f'{len(query_vec)}f', *query_vec)
        sql = """
            SELECT f.path, c.content, vec_distance_cosine(c.embedding, ?) as distance
            FROM chunks c
            JOIN files f ON c.file_id = f.id
            WHERE c.embedding IS NOT NULL
            ORDER BY distance ASC
            LIMIT ?
        """
        rows = cursor.execute(sql, (vec_bytes, limit)).fetchall()
        return self._format_results(rows, score_is_distance=True)

    def _search_pure_python(self, cursor, query_vec: List[float], limit: int) -> List[Dict]:
        """
        Fallback: Fetches all embeddings and computes Cosine Similarity in Python.
        Slower, but guarantees functionality without DLL dependencies.
        """
        sql = "SELECT c.id, f.path, c.content, c.embedding FROM chunks c JOIN files f ON c.file_id = f.id"
        cursor.execute(sql)
        
        candidates = []
        for row in cursor.fetchall():
            chunk_id, path, content, blob = row
            if not blob: continue
            
            try:
                # Deserialize: Try JSON first (as per your IngestEngine), then struct
                try:
                    vec = json.loads(blob)
                except:
                    # Fallback for binary blob if changed later
                    vec = struct.unpack(f'{len(query_vec)}f', blob)
                
                score = self._cosine_similarity(query_vec, vec)
                candidates.append((score, path, content))
            except Exception:
                continue

        # Sort by Score DESC (High similarity is better)
        candidates.sort(key=lambda x: x[0], reverse=True)
        top_n = candidates[:limit]
        
        return [{
            "path": r[1],
            "score": r[0],
            "snippet": r[2][:200].replace('\n', ' ') + "...",
            "full_content": r[2]
        } for r in top_n]

    def _keyword_search_fallback(self, db_path: str, query: str, limit: int) -> List[Dict]:
        """Used if Ollama is dead or vectors fail completely."""
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        sql = "SELECT path, content FROM files WHERE content LIKE ? LIMIT ?"
        rows = cursor.execute(sql, (f'%{query}%', limit)).fetchall()
        conn.close()
        return [{
            "path": r[0],
            "score": 0.0,
            "snippet": r[1][:200].replace('\n', ' ') + "...",
            "full_content": r[1]
        } for r in rows]

    def _cosine_similarity(self, vec_a: List[float], vec_b: List[float]) -> float:
        dot = sum(a * b for a, b in zip(vec_a, vec_b))
        norm_a = math.sqrt(sum(a * a for a in vec_a))
        norm_b = math.sqrt(sum(b * b for b in vec_b))
        return dot / (norm_a * norm_b) if norm_a and norm_b else 0.0

    def _get_query_embedding(self, text: str) -> Optional[List[float]]:
        try:
            res = requests.post(
                f"{OLLAMA_API_URL}/embeddings",
                json={"model": self.embed_model, "prompt": text},
                timeout=5
            )
            if res.status_code == 200:
                return res.json().get("embedding")
        except:
            pass
        return None

    def _format_results(self, rows, score_is_distance=False):
        results = []
        for r in rows:
            score = r[2]
            # Convert Cosine Distance (0..2) to Similarity (0..1)
            if score_is_distance:
                score = 1 - score 
            
            results.append({
                "path": r[0],
                "score": score,
                "snippet": r[1][:200].replace('\n', ' ') + "...",
                "full_content": r[1]
            })
        return results

if __name__ == "__main__":
    print("SearchEngineMS Ready.")
--------------------------------------------------------------------------------
FILE: _NeoCORTEX\src\_micro_services\_ThoughtStreamMS\thought_stream.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk
import datetime

class ThoughtStream(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.header = ttk.Label(self, text="NEURAL INSPECTOR", font=("Consolas", 10, "bold"))
        self.header.pack(fill="x", padx=5, pady=5)
        
        self.canvas = tk.Canvas(self, bg="#13131f", highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = tk.Frame(self.canvas, bg="#13131f")
        
        self.scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw", width=340)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

    def add_thought_bubble(self, filename, chunk_id, content, vector_preview, color):
        bubble = tk.Frame(self.scrollable_frame, bg="#1a1a25", highlightbackground="#444", highlightthickness=1)
        bubble.pack(fill="x", padx=5, pady=5)
        
        ts = datetime.datetime.now().strftime("%H:%M:%S")
        tk.Label(bubble, text=f"{filename} #{chunk_id} [{ts}]", fg="#007ACC", bg="#1a1a25", font=("Consolas", 8)).pack(anchor="w", padx=5, pady=2)
        
        snippet = content[:400] + "..." if len(content) > 400 else content
        tk.Label(bubble, text=snippet, fg="#ccc", bg="#10101a", font=("Consolas", 8), justify="left", wraplength=300).pack(fill="x", padx=5, pady=2)
        
        self._draw_sparkline(bubble, vector_preview, color)

    def _draw_sparkline(self, parent, vector, color):
        if not vector: return
        h = 30
        w = 300
        cv = tk.Canvas(parent, height=h, width=w, bg="#1a1a25", highlightthickness=0)
        cv.pack(padx=5, pady=2)
        bar_w = w / len(vector)
        for i, val in enumerate(vector):
            mag = abs(val) 
            bar_h = mag * h
            x0 = i * bar_w
            y0 = h - bar_h
            x1 = x0 + bar_w
            y1 = h
            cv.create_rectangle(x0, y0, x1, y1, fill=color, outline="")
--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\.gitignore
--------------------------------------------------------------------------------
# --- Python ---
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# --- Virtual Env ---
venv/
.venv/
env/
ENV/

# --- IDEs ---
.idea/
.vscode/
*.swp
*.swo

# --- OS Junk ---
.DS_Store
Thumbs.db
--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\requirements.txt
--------------------------------------------------------------------------------
pygame-ce>=2.4.0
--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

REM 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv targeting Python 3.10...
    REM We use REM instead of :: to prevent syntax crashes inside IF blocks
    py -3.10 -m venv .venv
)

REM 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
if exist .venv\Scripts\python.exe (
    .venv\Scripts\python.exe -m pip install --upgrade pip
    if exist requirements.txt (
        .venv\Scripts\pip install -r requirements.txt
    )
) else (
    echo [ERROR] .venv creation failed. Do you have Python 3.10 installed?
    echo Please install Python 3.10 from python.org and try again.
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\src\app.py
--------------------------------------------------------------------------------
import sys
import pygame
import random
import time
import math

# ==============================================================================
#   C O N F I G U R A T I O N
# ==============================================================================
CONFIG = {
    "WINDOW_TITLE": "OBS Neon/Gothic Board",
    "INITIAL_W": 1280,
    "INITIAL_H": 720,
    "FPS": 60,
    "PADDING": 80,
    "TOOLBAR_HEIGHT": 60,
    
    "DEFAULT_SIZE": 130,
    "MIN_SIZE": 20,
    "MAX_SIZE": 300,
    
    # Palette Presets for Cycling
    "PALETTES": [
        (245, 245, 240), # Off-White
        (188, 19, 254),  # Neon Purple
        (0, 255, 65),    # Matrix Green
        (255, 50, 50),   # Alert Red
        (50, 150, 255),  # Ice Blue
        (255, 180, 0),   # Amber
        (5, 5, 5),       # Black
    ],
    
    "COLORS": {
        "BLACK": (5, 5, 5),
        "UI_BG": (30, 30, 30),
        "UI_TEXT": (200, 200, 200),
        "UI_HOVER": (60, 60, 60)
    }
}

# ==============================================================================
#   U T I L I T I E S
# ==============================================================================
def lerp_color(c1, c2, t):
    """Linear interpolate between color c1 and c2 by factor t (0.0 to 1.0)"""
    return (
        int(c1[0] + (c2[0] - c1[0]) * t),
        int(c1[1] + (c2[1] - c1[1]) * t),
        int(c1[2] + (c2[2] - c1[2]) * t)
    )

# ==============================================================================
#   E F F E C T S   E N G I N E
# ==============================================================================
class MatrixColumn:
    """A single falling column for Matrix II"""
    def __init__(self, x, h, font_size):
        self.x = x
        self.max_h = h
        self.y = random.randint(-h, 0)
        self.speed = random.randint(5, 12)
        self.font_size = font_size
        self.chars = []
        self.rebuild_chars()

    def rebuild_chars(self):
        # Fill column with random chars
        count = (self.max_h // self.font_size) + 2
        self.chars = [chr(random.randint(33, 126)) for _ in range(count)]

    def update(self, h):
        self.y += self.speed
        if self.y > h:
            self.y = random.randint(-h // 2, 0)
            self.speed = random.randint(5, 12)
            # Randomly morph a character occasionally
        if random.random() < 0.05:
            idx = random.randint(0, len(self.chars) - 1)
            self.chars[idx] = chr(random.randint(33, 126))

    def draw(self, screen, font):
        # Draw the "Stream" relative to y
        # We only draw the bottom N characters to look like a trail
        trail_len = 15
        grid_y = int(self.y // self.font_size)
        
        for i in range(trail_len):
            char_idx = (grid_y - i) % len(self.chars)
            if grid_y - i < 0: continue # Don't draw above screen
            
            char = self.chars[char_idx]
            draw_y = (grid_y - i) * self.font_size
            
            # Alpha fade
            alpha = 255 - (i * (255 // trail_len))
            if alpha < 0: alpha = 0
            
            # Color Logic: Head is White, Tail is Green
            color = (200, 255, 200) if i == 0 else (0, 255, 65)
            
            s = font.render(char, True, color)
            s.set_alpha(alpha)
            screen.blit(s, (self.x, draw_y))

class Particle:
    def __init__(self, w, h, p_type):
        self.w, self.h = w, h
        self.reset(p_type, random_y=True)

    def reset(self, p_type, random_y=False):
        self.type = p_type
        self.x = random.randint(0, self.w)
        self.y = random.randint(0, self.h) if random_y else -20
        
        if self.type == "rain":
            self.speed_y = random.randint(15, 25)
            self.size = random.randint(10, 20)
            self.color = (100, 100, 100)
        elif self.type == "snow":
            self.speed_y = random.randint(2, 5)
            self.x = random.randint(0, self.w)
            self.size = random.randint(2, 4)
            self.color = (200, 200, 200)
        elif self.type == "embers":
            self.y = random.randint(0, self.h) if random_y else self.h + 20
            self.speed_y = random.uniform(-1, -4)
            self.size = random.randint(2, 6)
            self.color = (255, 100, 20)
        elif self.type == "stars":
            self.speed_x = random.uniform(-0.5, -3.0)
            self.size = random.randint(1, 3)
            self.color = (255, 255, 255)
        elif self.type == "matrix":
            self.speed_y = random.randint(10, 20)
            self.size = random.randint(14, 20)
            self.char_idx = random.randint(33, 126)
            self.color = (0, 255, 65)

    def update(self, w, h, global_wind):
        if self.type == "stars":
            self.x += self.speed_x
            if self.x < 0: self.x = w
        elif self.type == "embers":
            self.x += math.sin(time.time() * 5 + self.y) * 0.5
            self.y += self.speed_y
            if self.y < -10: self.reset(self.type)
        else:
            self.y += self.speed_y
            self.x += global_wind * (0.5 if self.type == "snow" else 0.1)
            if self.y > h: self.reset(self.type)
            if self.x > w: self.x = 0
            elif self.x < 0: self.x = w

    def draw(self, screen):
        if self.type == "rain":
            pygame.draw.line(screen, self.color, (self.x, self.y), (self.x, self.y + self.size), 1)
        elif self.type == "snow" or self.type == "stars":
            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.size)
        elif self.type == "embers":
            s = pygame.Surface((self.size*2, self.size*2), pygame.SRCALPHA)
            pygame.draw.circle(s, (*self.color, 150), (self.size, self.size), self.size)
            screen.blit(s, (self.x, self.y))
        elif self.type == "matrix" and font_matrix:
            char = chr(self.char_idx)
            s = font_matrix.render(char, True, self.color)
            screen.blit(s, (self.x, self.y))

class EffectManager:
    def __init__(self):
        self.particles = []
        self.matrix_cols = []
        self.active_modes = {
            "rain": False, "snow": False, "embers": False, 
            "stars": False, "storm": False, "matrix": False, "matrix2": False
        }
        self.wind_time = 0
        self.lightning_intensity = 0
        self.next_lightning = 0
        self.matrix_font = pygame.font.SysFont("consolas", 14)

    def toggle(self, mode, w, h):
        self.active_modes[mode] = not self.active_modes[mode]
        self._rebuild(w, h)

    def _rebuild(self, w, h):
        self.particles = []
        # Standard Particles
        if self.active_modes["rain"]: 
            for _ in range(100): self.particles.append(Particle(w, h, "rain"))
        if self.active_modes["snow"]:
            for _ in range(150): self.particles.append(Particle(w, h, "snow"))
        if self.active_modes["embers"]:
            for _ in range(60): self.particles.append(Particle(w, h, "embers"))
        if self.active_modes["stars"]:
            for _ in range(100): self.particles.append(Particle(w, h, "stars"))
        if self.active_modes["matrix"]:
            for _ in range(50): self.particles.append(Particle(w, h, "matrix"))
            
        # Matrix II Setup
        self.matrix_cols = []
        if self.active_modes["matrix2"]:
            col_size = 14 # roughly font width
            num_cols = w // col_size
            for i in range(num_cols):
                self.matrix_cols.append(MatrixColumn(i * col_size, h, 14))

    def update(self, w, h):
        self.wind_time += 0.01
        wind = math.sin(self.wind_time) * 2
        
        for p in self.particles: p.update(w, h, wind)
        for col in self.matrix_cols: col.update(h)

        if self.active_modes["storm"]:
            now = time.time()
            if self.lightning_intensity <= 0 and now > self.next_lightning:
                self.next_lightning = now + random.uniform(0.5, 3.0)
                self.lightning_intensity = random.randint(50, 200)
            if self.lightning_intensity > 0:
                self.lightning_intensity -= 15
        else:
            self.lightning_intensity = 0

    def draw(self, screen):
        # Draw Matrix II Bottom Layer
        for col in self.matrix_cols: col.draw(screen, self.matrix_font)
        
        # Draw Particles
        for p in self.particles: p.draw(screen)
            
        if self.lightning_intensity > 0:
            s = pygame.Surface(screen.get_size())
            s.fill((255, 255, 255))
            s.set_alpha(max(0, self.lightning_intensity))
            screen.blit(s, (0, 0))

# ==============================================================================
#   U I
# ==============================================================================
class Button:
    def __init__(self, x, y, w, h, text, callback, param=None):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = text
        self.callback = callback
        self.param = param
        self.is_hovered = False

    def draw(self, screen, font):
        bg = CONFIG["COLORS"]["UI_HOVER"] if self.is_hovered else CONFIG["COLORS"]["UI_BG"]
        pygame.draw.rect(screen, bg, self.rect, border_radius=5)
        pygame.draw.rect(screen, (80, 80, 80), self.rect, 1, border_radius=5)
        txt = font.render(self.text, True, CONFIG["COLORS"]["UI_TEXT"])
        screen.blit(txt, txt.get_rect(center=self.rect.center))

    def check_hover(self, pos): self.is_hovered = self.rect.collidepoint(pos)
    def check_click(self, pos):
        if self.rect.collidepoint(pos):
            if self.param is not None: self.callback(self.param)
            else: self.callback()
            return True
        return False

# ==============================================================================
#   M A I N   E N G I N E
# ==============================================================================
class NeonBoardEngine:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((CONFIG["INITIAL_W"], CONFIG["INITIAL_H"]), pygame.RESIZABLE)
        pygame.display.set_caption(CONFIG["WINDOW_TITLE"])
        
        self.running = True
        self.text = "TYPE HERE"
        
        # State
        self.bg_color = CONFIG["COLORS"]["BLACK"]
        self.fg_color_idx = 0 # White
        self.aux_color_idx = 1 # Purple
        
        self.text_style = "normal" 
        self.font_size = CONFIG["DEFAULT_SIZE"]
        self.is_bold = True
        self.is_italic = False
        self.font_index = 0
        self.preferred_fonts = ["arial", "couriernew", "georgia", "impact", "timesnewroman"]
        
        self.effects = EffectManager()
        self.buttons = []
        self.ui_font = pygame.font.SysFont("arial", 12)
        self._init_buttons()

    def _init_buttons(self):
        y = CONFIG["INITIAL_H"] - 50
        h = 35
        # Layout: [Font/Colors] ... [Styles] ... [Weather]
        self.buttons = [
            # Color & Font
            Button(10, y, 30, h, "B", self.toggle_bold),
            Button(45, y, 30, h, "I", self.toggle_italic),
            Button(80, y, 40, h, "Font", self.cycle_font),
            Button(125, y, 30, h, "FG", self.cycle_fg),
            Button(160, y, 30, h, "Aux", self.cycle_aux),
            
            # Styles
            Button(200, y, 40, h, "Norm", self.set_style, "normal"),
            Button(245, y, 40, h, "Neon", self.set_style, "neon"),
            Button(290, y, 40, h, "Shadw", self.set_style, "shadow"),
            Button(335, y, 40, h, "Wave", self.set_style, "wave"),
            Button(380, y, 40, h, "Gltch", self.set_style, "glitch"),
            Button(425, y, 40, h, "Pop", self.set_style, "pop"),

            # Weather
            Button(480, y, 35, h, "Rain", self.toggle_fx, "rain"),
            Button(520, y, 35, h, "Snow", self.toggle_fx, "snow"),
            Button(560, y, 35, h, "Fire", self.toggle_fx, "embers"),
            Button(600, y, 35, h, "Star", self.toggle_fx, "stars"),
            Button(640, y, 35, h, "Mtrx1", self.toggle_fx, "matrix"),
            Button(680, y, 35, h, "Mtrx2", self.toggle_fx, "matrix2"),
            Button(720, y, 35, h, "Strm", self.toggle_fx, "storm"),
        ]

    def _recalc_buttons_y(self):
        y = self.screen.get_height() - 50
        for btn in self.buttons: btn.rect.y = y

    # --- Actions ---
    def toggle_bold(self): self.is_bold = not self.is_bold
    def toggle_italic(self): self.is_italic = not self.is_italic
    def cycle_font(self): self.font_index = (self.font_index + 1) % len(self.preferred_fonts)
    
    def cycle_fg(self): self.fg_color_idx = (self.fg_color_idx + 1) % len(CONFIG["PALETTES"])
    def cycle_aux(self): self.aux_color_idx = (self.aux_color_idx + 1) % len(CONFIG["PALETTES"])
    
    def set_style(self, style): 
        if self.text_style == style and style != "normal":
            self.text_style = "normal"
        else:
            self.text_style = style

    def toggle_fx(self, name): 
        self.effects.toggle(name, self.screen.get_width(), self.screen.get_height())

    # --- Run Loop ---
    def run(self):
        clock = pygame.time.Clock()
        while self.running:
            self.handle_events()
            self.effects.update(self.screen.get_width(), self.screen.get_height())
            self.draw()
            pygame.display.flip()
            clock.tick(CONFIG["FPS"])
        pygame.quit()

    def handle_events(self):
        mouse_pos = pygame.mouse.get_pos()
        for btn in self.buttons: btn.check_hover(mouse_pos)

        for event in pygame.event.get():
            if event.type == pygame.QUIT: self.running = False
            elif event.type == pygame.VIDEORESIZE: self._recalc_buttons_y()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if not any(btn.check_click(event.pos) for btn in self.buttons): pass
            elif event.type == pygame.KEYDOWN:
                # F-Key Background Themes
                if event.key == pygame.K_F1: self.bg_color = CONFIG["COLORS"]["BLACK"]
                elif event.key == pygame.K_F2: self.bg_color = (0, 0, 0) # Terminal
                elif event.key == pygame.K_F3: self.bg_color = (43, 58, 40) # Chalk
                elif event.key == pygame.K_F4: self.bg_color = (15, 15, 15) # Gothic
                
                elif event.key == pygame.K_ESCAPE: self.text = ""
                elif event.key == pygame.K_BACKSPACE: self.text = self.text[:-1]
                elif event.key == pygame.K_RETURN: self.text += "\n"
                else:
                    if self.text == "TYPE HERE": self.text = ""
                    if len(event.unicode) > 0 and event.unicode.isprintable(): self.text += event.unicode

    # --- Draw ---
    def draw(self):
        w, h = self.screen.get_size()
        self.screen.fill(self.bg_color)

        # 1. Effects
        self.effects.draw(self.screen)

        # 2. Text Configuration
        font_name = self.preferred_fonts[self.font_index]
        font = pygame.font.SysFont(font_name, self.font_size, self.is_bold, self.is_italic)
        
        fg = CONFIG["PALETTES"][self.fg_color_idx]
        aux = CONFIG["PALETTES"][self.aux_color_idx]
        
        lines = self.wrap_text(self.text, font, w - (CONFIG["PADDING"]*2))
        total_h = len(lines) * font.get_linesize()
        start_y = (h // 2) - (total_h // 2)

        # 3. Render Text
        for i, line in enumerate(lines):
            line_y = start_y + (i * font.get_linesize())
            line_w = font.size(line)[0]
            line_x = (w // 2) - (line_w // 2)
            
            # Universal "Cutout" Stroke (The standard graphic design trap)
            # We draw a thin stroke in BG color around EVERYTHING to separate it from particles
            self._render_stroke(line, line_x, line_y, font, self.bg_color, 2)
            
            if self.text_style == "normal":
                # Clean Look (Subtle outline)
                self._render_stroke(line, line_x, line_y, font, aux, 2)
                self.screen.blit(font.render(line, True, fg), (line_x, line_y))
            
            elif self.text_style == "neon":
                self._render_neon(line, line_x, line_y, font, fg, aux)

            elif self.text_style == "shadow":
                self._render_shadow(line, line_x, line_y, font, fg)

            elif self.text_style == "wave":
                self._render_wave(line, line_x, line_y, font, fg)
                
            elif self.text_style == "glitch":
                self._render_glitch(line, line_x, line_y, font, fg)
                
            elif self.text_style == "pop":
                # THE SMART TRAP: 20% FG / 80% BG
                trap_col = lerp_color(fg, self.bg_color, 0.8)
                # Thick stroke with transition color
                self._render_stroke(line, line_x, line_y, font, trap_col, 6)
                # Main Text
                self.screen.blit(font.render(line, True, fg), (line_x, line_y))

        # 4. UI
        pygame.draw.rect(self.screen, (10,10,10), (0, h-CONFIG["TOOLBAR_HEIGHT"], w, CONFIG["TOOLBAR_HEIGHT"]))
        for btn in self.buttons: btn.draw(self.screen, self.ui_font)

    # --- Renderers ---
    def wrap_text(self, text, font, max_w):
        lines = []
        for raw in text.split('\n'):
            words = raw.split(' ')
            cur = []
            for word in words:
                if font.size(' '.join(cur + [word]))[0] < max_w: cur.append(word)
                else: lines.append(' '.join(cur)); cur = [word]
            lines.append(' '.join(cur))
        return lines

    def _render_stroke(self, text, x, y, font, color, width):
        # Brute force 8-way stroke
        s = font.render(text, True, color)
        for ox in range(-width, width+1):
            for oy in range(-width, width+1):
                if ox == 0 and oy == 0: continue
                self.screen.blit(s, (x+ox, y+oy))

    def _render_neon(self, text, x, y, font, color, glow):
        if random.random() < 0.02:
            temp_glow = (max(0, glow[0]-100), max(0, glow[1]-100), max(0, glow[2]-100))
            self._render_stroke(text, x, y, font, temp_glow, 4)
        else:
            self._render_stroke(text, x, y, font, glow, 4)
        self.screen.blit(font.render(text, True, color), (x, y))

    def _render_shadow(self, text, x, y, font, color):
        s_shad = font.render(text, True, (0, 0, 0))
        self.screen.blit(s_shad, (x+6, y+6))
        self.screen.blit(font.render(text, True, color), (x, y))

    def _render_wave(self, text, x, y, font, color):
        off_x = x
        t = time.time() * 5
        for i, char in enumerate(text):
            cy = y + math.sin(t + i*0.5) * 10
            s = font.render(char, True, color)
            self.screen.blit(s, (off_x, cy))
            off_x += s.get_width()

    def _render_glitch(self, text, x, y, font, color):
        s = font.render(text, True, color)
        w, h = s.get_size()
        s.set_alpha(200)
        self.screen.blit(s, (x, y))
        if random.random() < 0.9: 
            rect = pygame.Rect(0, 0, w, h//2)
            self.screen.blit(s, (x + random.choice([-5, 5]), y), area=rect)

if __name__ == "__main__":
    NeonBoardEngine().run()

--------------------------------------------------------------------------------
FILE: _NeonChalkBOARD\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\README.md
--------------------------------------------------------------------------------
# Patchwright (TokenizingPATCHER Companion)

Patchwright is a local, human-in-the-loop (HITL) patch generation, repair, and validation tool designed specifically for use with **_TokenizingPATCHER**.

It uses a **local LLM via Ollama** (e.g. `qwen2:7b`, `qwen2.5:7b-coder`) to:
- create patches from snippets + target files
- repair failing or malformed patches
- strictly validate patches before they reach the patcher

The system is intentionally **tasklist-driven**: every inference cycle is explicit, editable, and inspectable.

---

## Core Guarantees

Patchwright enforces **hard correctness constraints**:

- âœ… Final output is **always valid JSON**
- âœ… Output **always** conforms to the exact TokenizingPATCHER schema
- âœ… Optional enforcement that every `search_block` exists verbatim in the target file
- âŒ No placeholder text (`... existing code ...`, `TODO`, etc.) in final patches
- âŒ No hidden or implicit inference steps

If a step fails validation, it is retried, repaired, or halted â€” never silently passed through.

---

## TokenizingPATCHER Patch Schema (Strict)

Patchwright **only** outputs patches in this format:

```json
{
  "hunks": [
    {
      "description": "Short human description",
      "search_block": "exact text to find\n(can span multiple lines)",
      "replace_block": "replacement text\n(same or different length)",
      "use_patch_indent": false
    }
  ]
}

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\requirements.txt
--------------------------------------------------------------------------------
# Patchwright (TokenizingPATCHER) Prototype
# Uses only Python stdlib + Tkinter (bundled with standard Windows Python installs).
# No external dependencies required.

# (empty)
--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\app.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
== TokenizingPATCHER Patchwright (Prototype) ==

Tkinter app that runs HITL tasklists (chained inference cycles) against:
- target file text
- snippet text
- existing patch JSON + error log

Guarantees final output is a schema-valid TokenizingPATCHER patch JSON.

Entry modes:
- GUI: `py -m src.app`
- CLI: `py -m src.app validate --patch patch.json --target file.py`
"""

# 1. IMPORTS
import sys
import os
import argparse
import json
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# Local imports
from src._microservices.state import new_state
from src._microservices.tasklists import get_tasklist_names, load_tasklist_by_name
from src._microservices.runner import run_tasklist
from src._microservices.patch_validators import (
    validate_patch_schema_strict,
    check_search_blocks_exist,
)

# 2. CONSTANTS
APP_TITLE = "Patchwright (TokenizingPATCHER) - Prototype"
DARK_BG = "#0f1115"
DARK_FG = "#e7e7e7"
PANEL_BG = "#141822"
ENTRY_BG = "#0b0e14"
ACCENT = "#2a6ef2"


# -----------------------------
# 3. CORE FUNCTIONALITY (Importable)
# -----------------------------

def run_cli_validate(patch_text: str, target_text: str, require_match: bool) -> dict:
    """CLI helper: validate + (optionally) require search_block substring matches."""
    ok, errs = validate_patch_schema_strict(patch_text)
    if not ok:
        return {"ok": False, "stage": "schema", "errors": errs}

    if require_match:
        patch_obj = json.loads(patch_text)
        found, missing = check_search_blocks_exist(target_text, patch_obj)
        if missing:
            return {"ok": False, "stage": "match", "missing_hunks": missing, "found_hunks": found}

    return {"ok": True}


# -----------------------------
# 4. TKINTER UI
# -----------------------------

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.configure(bg=DARK_BG)
        self.geometry("1400x850")

        self.state = new_state()

        self._build_style()
        self._build_layout()
        self._load_tasklist_choices()

    def _build_style(self):
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except tk.TclError:
            pass

        style.configure("TFrame", background=DARK_BG)
        style.configure("Panel.TFrame", background=PANEL_BG)
        style.configure("TLabel", background=PANEL_BG, foreground=DARK_FG)
        style.configure("Header.TLabel", background=PANEL_BG, foreground=DARK_FG, font=("Segoe UI", 11, "bold"))
        style.configure("TButton", font=("Segoe UI", 10))
        style.configure("Accent.TButton", foreground=DARK_FG)

    def _build_layout(self):
        # Main grid: Inputs | Tasklist | Output/State
        self.columnconfigure(0, weight=3)
        self.columnconfigure(1, weight=2)
        self.columnconfigure(2, weight=3)
        self.rowconfigure(0, weight=1)

        self.inputs_panel = ttk.Frame(self, style="Panel.TFrame", padding=10)
        self.task_panel = ttk.Frame(self, style="Panel.TFrame", padding=10)
        self.output_panel = ttk.Frame(self, style="Panel.TFrame", padding=10)

        self.inputs_panel.grid(row=0, column=0, sticky="nsew", padx=8, pady=8)
        self.task_panel.grid(row=0, column=1, sticky="nsew", padx=8, pady=8)
        self.output_panel.grid(row=0, column=2, sticky="nsew", padx=8, pady=8)

        self._build_inputs_panel()
        self._build_task_panel()
        self._build_output_panel()

    # ---------- Inputs ----------
    def _build_inputs_panel(self):
        p = self.inputs_panel
        p.rowconfigure(1, weight=1)
        p.rowconfigure(3, weight=1)
        p.rowconfigure(5, weight=1)

        ttk.Label(p, text="Inputs", style="Header.TLabel").grid(row=0, column=0, sticky="w")

        # Target file
        bar1 = ttk.Frame(p, style="Panel.TFrame")
        bar1.grid(row=0, column=1, sticky="e")
        ttk.Button(bar1, text="Load Target File", command=self._load_target_file).pack(side="left", padx=4)
        ttk.Button(bar1, text="Clear", command=lambda: self._set_text(self.target_txt, "")).pack(side="left", padx=4)

        self.target_txt = self._make_text(p)
        self.target_txt.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(6, 10))
        self._label_above(p, "Target file text", row=1)

        # Snippet
        ttk.Label(p, text="Snippet text", style="TLabel").grid(row=2, column=0, sticky="w")
        self.snippet_txt = self._make_text(p, height=8)
        self.snippet_txt.grid(row=3, column=0, columnspan=2, sticky="nsew", pady=(6, 10))

        # Existing patch + error log
        ttk.Label(p, text="Existing patch JSON (optional)", style="TLabel").grid(row=4, column=0, sticky="w")
        bar2 = ttk.Frame(p, style="Panel.TFrame")
        bar2.grid(row=4, column=1, sticky="e")
        ttk.Button(bar2, text="Load Patch JSON", command=self._load_patch_file).pack(side="left", padx=4)

        self.patch_txt = self._make_text(p, height=10)
        self.patch_txt.grid(row=5, column=0, columnspan=2, sticky="nsew", pady=(6, 10))

        ttk.Label(p, text="Error log (optional)", style="TLabel").grid(row=6, column=0, sticky="w")
        self.err_txt = self._make_text(p, height=6)
        self.err_txt.grid(row=7, column=0, columnspan=2, sticky="nsew", pady=(6, 0))

        p.rowconfigure(7, weight=1)

    # ---------- Tasklist ----------
    def _build_task_panel(self):
        p = self.task_panel
        p.columnconfigure(0, weight=1)
        p.rowconfigure(3, weight=1)

        ttk.Label(p, text="Tasklists (HITL)", style="Header.TLabel").grid(row=0, column=0, sticky="w")

        # Mode + tasklist picker
        top = ttk.Frame(p, style="Panel.TFrame")
        top.grid(row=1, column=0, sticky="ew", pady=(8, 8))
        top.columnconfigure(1, weight=1)

        ttk.Label(top, text="Mode:", style="TLabel").grid(row=0, column=0, sticky="w")
        self.mode_var = tk.StringVar(value="validate_patch")
        mode = ttk.Combobox(top, textvariable=self.mode_var, state="readonly",
                            values=["validate_patch", "repair_patch", "create_patch"])
        mode.grid(row=0, column=1, sticky="ew", padx=(6, 0))
        mode.bind("<<ComboboxSelected>>", lambda _e: self._load_tasklist_choices())

        ttk.Label(top, text="Tasklist:", style="TLabel").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.tasklist_var = tk.StringVar(value="")
        self.tasklist_combo = ttk.Combobox(top, textvariable=self.tasklist_var, state="readonly", values=[])
        self.tasklist_combo.grid(row=1, column=1, sticky="ew", padx=(6, 0), pady=(8, 0))
        self.tasklist_combo.bind("<<ComboboxSelected>>", lambda _e: self._render_tasklist_editor())

        # Buttons
        btns = ttk.Frame(p, style="Panel.TFrame")
        btns.grid(row=2, column=0, sticky="ew")
        ttk.Button(btns, text="Run All Steps", command=self._run_all).pack(side="left", padx=4)
        ttk.Button(btns, text="Validate Output", command=self._validate_output).pack(side="left", padx=4)
        ttk.Button(btns, text="Copy Final Patch", command=self._copy_final).pack(side="left", padx=4)

        # Tasklist editor (raw JSON)
        ttk.Label(p, text="Editable tasklist JSON", style="TLabel").grid(row=3, column=0, sticky="w", pady=(10, 0))
        self.task_json = self._make_text(p, height=22)
        self.task_json.grid(row=4, column=0, sticky="nsew", pady=(6, 0))
        p.rowconfigure(4, weight=1)

    # ---------- Output ----------
    def _build_output_panel(self):
        p = self.output_panel
        p.columnconfigure(0, weight=1)
        p.rowconfigure(1, weight=1)
        p.rowconfigure(3, weight=1)

        ttk.Label(p, text="Outputs", style="Header.TLabel").grid(row=0, column=0, sticky="w")

        ttk.Label(p, text="Final patch JSON (schema-valid)", style="TLabel").grid(row=0, column=0, sticky="e")

        self.final_txt = self._make_text(p, height=18)
        self.final_txt.grid(row=1, column=0, sticky="nsew", pady=(10, 10))

        ttk.Label(p, text="State (debug)", style="TLabel").grid(row=2, column=0, sticky="w")
        self.state_txt = self._make_text(p, height=18)
        self.state_txt.grid(row=3, column=0, sticky="nsew")

    # ---------- Helpers ----------
    def _make_text(self, parent, height=14):
        t = tk.Text(parent, height=height, wrap="none", bg=ENTRY_BG, fg=DARK_FG, insertbackground=DARK_FG,
                    relief="flat", undo=True)
        # simple scrollbars
        y = ttk.Scrollbar(parent, orient="vertical", command=t.yview)
        x = ttk.Scrollbar(parent, orient="horizontal", command=t.xview)
        t.configure(yscrollcommand=y.set, xscrollcommand=x.set)

        # grid them as an internal frame-like pack via place in caller? easiest: return just text,
        # and caller can add scrollbars manually if desired.
        # For prototype: keep it simple: no separate scrollbar widgets.
        return t

    def _label_above(self, parent, text, row):
        # Lightweight label placed just above the widget row
        # (Prototype: already labeled elsewhere; kept for future expansion)
        pass

    def _get_text(self, widget) -> str:
        return widget.get("1.0", "end-1c")

    def _set_text(self, widget, text: str):
        widget.delete("1.0", "end")
        widget.insert("1.0", text)

    def _sync_inputs_to_state(self):
        self.state["mode"] = self.mode_var.get()
        self.state["inputs"]["target_file_text"] = self._get_text(self.target_txt)
        self.state["inputs"]["snippet_text"] = self._get_text(self.snippet_txt)
        self.state["inputs"]["existing_patch_json"] = self._get_text(self.patch_txt)
        self.state["inputs"]["error_log_text"] = self._get_text(self.err_txt)

    def _render_state(self):
        self._set_text(self.state_txt, json.dumps(self.state, indent=2))

    def _load_target_file(self):
        path = filedialog.askopenfilename(title="Select target file")
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                self._set_text(self.target_txt, f.read())
            self.state["inputs"]["file_path"] = path
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read file:\n{e}")

    def _load_patch_file(self):
        path = filedialog.askopenfilename(title="Select patch JSON file", filetypes=[("JSON", "*.json"), ("All", "*.*")])
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                self._set_text(self.patch_txt, f.read())
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read patch:\n{e}")

    def _load_tasklist_choices(self):
        mode = self.mode_var.get()
        names = get_tasklist_names(mode)
        self.tasklist_combo.configure(values=names)
        if names:
            self.tasklist_var.set(names[0])
            self._render_tasklist_editor()

    def _render_tasklist_editor(self):
        mode = self.mode_var.get()
        name = self.tasklist_var.get()
        if not name:
            return
        tasklist = load_tasklist_by_name(mode, name)
        self._set_text(self.task_json, json.dumps(tasklist, indent=2))

    def _run_all(self):
        self._sync_inputs_to_state()

        # Parse edited tasklist JSON (HITL)
        try:
            tasklist = json.loads(self._get_text(self.task_json))
        except Exception as e:
            messagebox.showerror("Tasklist JSON Error", str(e))
            return

        try:
            # Runner returns updated state
            self.state = run_tasklist(self.state, tasklist)
        except Exception as e:
            messagebox.showerror("Run Error", str(e))
            self._render_state()
            return

        # Update outputs
        final_patch = self.state.get("outputs", {}).get("final_patch")
        if final_patch is not None:
            self._set_text(self.final_txt, json.dumps(final_patch, indent=2))
        self._render_state()

    def _validate_output(self):
        txt = self._get_text(self.final_txt).strip()
        if not txt:
            messagebox.showwarning("No Output", "Final patch output is empty.")
            return

        ok, errs = validate_patch_schema_strict(txt)
        if not ok:
            messagebox.showerror("Invalid Patch JSON", "\n".join(errs))
            return

        # Optional: search_block match check against target file
        try:
            patch_obj = json.loads(txt)
        except Exception:
            messagebox.showerror("Invalid JSON", "Final output is not valid JSON.")
            return

        target = self._get_text(self.target_txt)
        found, missing = check_search_blocks_exist(target, patch_obj)
        if missing:
            messagebox.showwarning("Search Blocks Missing",
                                   f"These hunks do NOT match target file: {missing}\nFound: {found}")
        else:
            messagebox.showinfo("Valid", "Patch is schema-valid and all search_blocks match the target.")

    def _copy_final(self):
        txt = self._get_text(self.final_txt)
        if not txt.strip():
            return
        self.clipboard_clear()
        self.clipboard_append(txt)
        self.update()
        messagebox.showinfo("Copied", "Final patch JSON copied to clipboard.")


# -----------------------------
# 5. CLI LOGIC (kept in your boilerplate style)
# -----------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Patchwright: HITL tasklists for TokenizingPATCHER patches (GUI + CLI).",
        epilog="GUI: py -m src.app\nCLI validate: py -m src.app validate --patch patch.json --target file.py"
    )

    sub = parser.add_subparsers(dest="cmd")

    v = sub.add_parser("validate", help="Validate patch JSON (and optionally match search_block against target).")
    v.add_argument("--patch", type=str, required=True, help="Path to patch JSON file.")
    v.add_argument("--target", type=str, required=True, help="Path to target file.")
    v.add_argument("--require-match", action="store_true", help="Fail if any search_block is not found in target.")
    v.add_argument("--print-json", action="store_true", help="Print result JSON to stdout.")

    args = parser.parse_args()

    if args.cmd == "validate":
        with open(args.patch, "r", encoding="utf-8") as f:
            patch_text = f.read()
        with open(args.target, "r", encoding="utf-8") as f:
            target_text = f.read()

        result = run_cli_validate(patch_text, target_text, require_match=args.require_match)
        if args.print_json:
            print(json.dumps(result, indent=2))
        sys.exit(0 if result.get("ok") else 1)

    # Default: GUI
    app = App()
    app.mainloop()


if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\ollama_client.py
--------------------------------------------------------------------------------
import json
import urllib.request

class OllamaClient:
    def __init__(self, base_url: str = "http://localhost:11434"):
        self.base_url = base_url.rstrip("/")

    def generate(self, model: str, system: str, prompt: str, options: dict | None = None) -> str:
        """
        Uses Ollama /api/generate with system+prompt.
        Returns the concatenated response text.
        """
        url = f"{self.base_url}/api/generate"
        payload = {
            "model": model,
            "prompt": prompt,
            "system": system,
            "stream": False
        }
        if options:
            payload["options"] = options

        data = json.dumps(payload).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"})
        with urllib.request.urlopen(req, timeout=300) as resp:
            raw = resp.read().decode("utf-8")
            obj = json.loads(raw)
            return obj.get("response", "")

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\patch_schema.py
--------------------------------------------------------------------------------
REQUIRED_TOP_KEY = "hunks"
REQUIRED_HUNK_KEYS = ["description", "search_block", "replace_block", "use_patch_indent"]

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\patch_validators.py
--------------------------------------------------------------------------------
import json
from src._microservices.patch_schema import REQUIRED_TOP_KEY, REQUIRED_HUNK_KEYS

def validate_patch_schema_strict(patch_text: str):
    errors = []
    try:
        obj = json.loads(patch_text)
    except Exception as e:
        return False, [f"JSON parse failed: {e}"]

    # no extra keys
    if not isinstance(obj, dict):
        return False, ["Top-level JSON must be an object."]
    if list(obj.keys()) != [REQUIRED_TOP_KEY]:
        return False, [f"Top-level must have ONLY key '{REQUIRED_TOP_KEY}' (no extras)."]

    hunks = obj.get(REQUIRED_TOP_KEY)
    if not isinstance(hunks, list) or len(hunks) == 0:
        return False, ["'hunks' must be a non-empty array."]

    for i, h in enumerate(hunks):
        if not isinstance(h, dict):
            errors.append(f"Hunk {i}: must be an object.")
            continue
        if sorted(h.keys()) != sorted(REQUIRED_HUNK_KEYS):
            errors.append(f"Hunk {i}: must have ONLY keys {REQUIRED_HUNK_KEYS}.")
        if not isinstance(h.get("description"), str) or not h["description"].strip():
            errors.append(f"Hunk {i}: 'description' must be a non-empty string.")
        if not isinstance(h.get("search_block"), str):
            errors.append(f"Hunk {i}: 'search_block' must be a string.")
        if not isinstance(h.get("replace_block"), str):
            errors.append(f"Hunk {i}: 'replace_block' must be a string.")
        if not isinstance(h.get("use_patch_indent"), bool):
            errors.append(f"Hunk {i}: 'use_patch_indent' must be boolean (true/false).")

    return (len(errors) == 0), errors

def check_search_blocks_exist(target_text: str, patch_obj: dict):
    found = []
    missing = []
    hunks = patch_obj.get("hunks", [])
    for i, h in enumerate(hunks):
        sb = h.get("search_block", "")
        if sb and sb in target_text:
            found.append(i)
        else:
            missing.append(i)
    return found, missing

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\runner.py
--------------------------------------------------------------------------------
import json

from src._microservices.ollama_client import OllamaClient
from src._microservices.template_engine import resolve_template
from src._microservices.patch_validators import validate_patch_schema_strict, check_search_blocks_exist

_client = OllamaClient()

def _set_by_path(state: dict, path: str, value):
    # path like "working.candidate_patch" or "outputs.final_patch"
    parts = path.split(".")
    cur = state
    for p in parts[:-1]:
        cur = cur.setdefault(p, {})
    cur[parts[-1]] = value

def _get_by_path(state: dict, path: str):
    parts = path.split(".")
    cur = state
    for p in parts:
        if not isinstance(cur, dict) or p not in cur:
            return None
        cur = cur[p]
    return cur

def _run_validators(state: dict, validators: list[str], produced_text: str, produced_obj):
    # produced_text is raw model output; produced_obj is parsed JSON if applicable
    errors = []

    for v in validators:
        if v == "json_parse":
            try:
                json.loads(produced_text)
            except Exception as e:
                errors.append(f"json_parse failed: {e}")

        elif v == "schema_strict":
            ok, errs = validate_patch_schema_strict(produced_text)
            if not ok:
                errors.extend(errs)

        elif v == "match_search_blocks":
            # requires schema-valid + target file
            ok, errs = validate_patch_schema_strict(produced_text)
            if not ok:
                errors.extend(errs)
            else:
                patch_obj = json.loads(produced_text)
                target = state["inputs"]["target_file_text"]
                found, missing = check_search_blocks_exist(target, patch_obj)
                if missing:
                    errors.append(f"search_block not found for hunks: {missing} (found: {found})")

        else:
            errors.append(f"Unknown validator: {v}")

    return errors

def run_tasklist(state: dict, tasklist: dict) -> dict:
    """
    Executes enabled steps in order. Each step is a single Ollama call.
    HITL: tasklist is provided by UI and can be edited by user.

    The runner is intentionally strict:
    - If a step claims to output patch_json, we validate schema.
    - Final output is stored into state['outputs']['final_patch'] as a dict.
    """
    steps = tasklist.get("steps", [])
    for step in steps:
        if not step.get("enabled", True):
            continue

        model = step["model"]
        system = step["system_prompt"]
        template = step["user_prompt_template"]
        options = step.get("ollama_options") or {}
        expects = step.get("expects", "text")
        output_key = step.get("output_key", "working.notes")
        validators = step.get("validators", [])
        on_fail = step.get("on_fail", "continue")

        prompt = resolve_template(template, state)
        raw = _client.generate(model=model, system=system, prompt=prompt, options=options)
        raw_stripped = raw.strip()

        produced_obj = None
        if expects in ("json", "patch_json"):
            # model should emit JSON only; attempt parse
            produced_obj = json.loads(raw_stripped)

        # validators operate on raw text
        errs = _run_validators(state, validators, raw_stripped, produced_obj)
        if errs:
            # record
            state["working"].setdefault("notes", []).append({
                "step": step["id"],
                "name": step["name"],
                "errors": errs
            })
            if on_fail == "retry":
                # naive retry once with same prompt (prototype)
                raw = _client.generate(model=model, system=system, prompt=prompt, options=options)
                raw_stripped = raw.strip()
                produced_obj = json.loads(raw_stripped) if expects in ("json", "patch_json") else None
                errs2 = _run_validators(state, validators, raw_stripped, produced_obj)
                if errs2:
                    raise RuntimeError(f"Step {step['id']} failed after retry:\n" + "\n".join(errs2))
            elif on_fail == "stop":
                raise RuntimeError(f"Step {step['id']} failed:\n" + "\n".join(errs))
            # continue means fall through

        # store outputs
        if expects == "patch_json":
            # store as dict in state, but keep raw also if you want later
            _set_by_path(state, output_key, produced_obj)
        elif expects == "json":
            _set_by_path(state, output_key, produced_obj)
        else:
            _set_by_path(state, output_key, raw_stripped)

    # If outputs.final_patch is dict, keep it; if itâ€™s text, normalize
    fp = _get_by_path(state, "outputs.final_patch")
    if isinstance(fp, str):
        state["outputs"]["final_patch"] = json.loads(fp)

    return state

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\state.py
--------------------------------------------------------------------------------
def new_state() -> dict:
    return {
        "mode": "validate_patch",
        "inputs": {
            "target_file_text": "",
            "snippet_text": "",
            "existing_patch_json": "",
            "error_log_text": "",
            "file_path": "",
            "language_hint": "unknown"
        },
        "working": {
            "candidate_patch": None,
            "validation": {},
            "match_test": {},
            "notes": []
        },
        "outputs": {
            "final_patch": None
        }
    }

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\tasklists.py
--------------------------------------------------------------------------------
def get_tasklist_names(mode: str):
    tl = _TASKLISTS.get(mode, {})
    return list(tl.keys())

def load_tasklist_by_name(mode: str, name: str) -> dict:
    return _TASKLISTS[mode][name]

_TASKLISTS = {
    "validate_patch": {
        "validate_patch_v0": {
            "name": "validate_patch_v0",
            "mode": "validate_patch",
            "steps": [
                {
                    "id": "V1",
                    "name": "Normalize patch JSON",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.0},
                    "system_prompt": "You are a strict JSON normalizer. Output ONLY valid JSON. No commentary.",
                    "user_prompt_template": "PATCH_JSON_INPUT:\n{{state.inputs.existing_patch_json}}\n\nReturn valid JSON only.",
                    "expects": "json",
                    "output_key": "working.candidate_patch",
                    "validators": ["json_parse"],
                    "on_fail": "retry"
                },
                {
                    "id": "V2",
                    "name": "Enforce schema and output final patch JSON",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.0},
                    "system_prompt": "Output ONLY JSON that matches EXACT schema: {hunks:[{description,search_block,replace_block,use_patch_indent}]}. No extra keys. hunks non-empty. use_patch_indent boolean.",
                    "user_prompt_template": "CANDIDATE:\n{{state.working.candidate_patch}}\n\nReturn schema-valid patch JSON only.",
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict"],
                    "on_fail": "retry"
                }
            ]
        }
    },
    "repair_patch": {
        "repair_patch_v0": {
            "name": "repair_patch_v0",
            "mode": "repair_patch",
            "steps": [
                {
                    "id": "R1",
                    "name": "Rewrite hunks to match current file",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.2},
                    "system_prompt": (
                        "You are a patch surgeon for TokenizingPATCHER.\n"
                        "MUST output ONLY schema-valid patch JSON.\n"
                        "Rules:\n"
                        "- Every search_block MUST appear verbatim in TARGET_FILE.\n"
                        "- replace_block must be concrete (no placeholders).\n"
                        "- No extra keys."
                    ),
                    "user_prompt_template": (
                        "TARGET_FILE:\n{{state.inputs.target_file_text}}\n\n"
                        "FAILING_PATCH_JSON:\n{{state.inputs.existing_patch_json}}\n\n"
                        "ERROR_LOG:\n{{state.inputs.error_log_text}}\n\n"
                        "Produce corrected patch JSON."
                    ),
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict", "match_search_blocks"],
                    "on_fail": "retry"
                }
            ]
        }
    },
    "create_patch": {
        "create_patch_v0": {
            "name": "create_patch_v0",
            "mode": "create_patch",
            "steps": [
                {
                    "id": "C1",
                    "name": "Generate patch from snippet + file",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.2},
                    "system_prompt": (
                        "Generate TokenizingPATCHER patch JSON.\n"
                        "Hard rules:\n"
                        "- Output ONLY schema-valid patch JSON.\n"
                        "- Every search_block MUST be verbatim substring from TARGET_FILE.\n"
                        "- replace_block must be concrete and placeholder-free.\n"
                        "- No extra keys."
                    ),
                    "user_prompt_template": (
                        "TARGET_FILE:\n{{state.inputs.target_file_text}}\n\n"
                        "CHANGE_SNIPPET:\n{{state.inputs.snippet_text}}\n\n"
                        "Create patch JSON."
                    ),
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict", "match_search_blocks"],
                    "on_fail": "retry"
                }
            ]
        }
    }
}

--------------------------------------------------------------------------------
FILE: _PatchWRIGHT\src\_microservices\template_engine.py
--------------------------------------------------------------------------------
def resolve_template(template: str, state: dict) -> str:
    """
    Minimal {{state.path.to.key}} templating.
    Only supports read access, no function calls.
    """
    out = template

    # very small & safe on purpose
    # pattern scanning without regex to keep it obvious
    while True:
        start = out.find("{{")
        if start == -1:
            break
        end = out.find("}}", start)
        if end == -1:
            break
        expr = out[start+2:end].strip()

        val = ""
        if expr.startswith("state."):
            path = expr[len("state."):].split(".")
            cur = state
            ok = True
            for p in path:
                if isinstance(cur, dict) and p in cur:
                    cur = cur[p]
                else:
                    ok = False
                    break
            if ok:
                val = cur if isinstance(cur, str) else str(cur)

        out = out[:start] + val + out[end+2:]
    return out

--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
--------------------------------------------------------------------------------
I am refactoring a collection of legacy Python scripts into a unified "Systems Thinker" ecosystem managed by a central launcher. I need you to act as a Refactoring Engine.

Here is the Architecture Contract you must follow for this session:

1. THE GOAL:
Convert the raw code I provide into a standardized package structure compatible with a `scripts_menu.py` launcher that executes via `python -m src.app`.

2. THE TARGET STRUCTURE:
Project Root: C:\Users\foo_user_name\Documents\_foo_project_folder\_BoilerPlatePythonTEMPLATE <-- Sample location
Generated: YYYY-MM-DD HH:MM:SS
Global Default Folder Exclusions: .git, .idea, .mypy_cache, .venv, .vscode, Debug, Release, __pycache__, _logs, bin, build, dist, logs, node_modules, obj, out, target
Predefined Filename Exclusions: *.pyc, *.pyo, *.swo, *.swp, .DS_Store, Thumbs.db, package-lock.json, yarn.lock
Dynamic Filename Exclusions: None

[X] _BoilerPlatePythonTEMPLATE/ (Project Root)
  â”œâ”€â”€ [ ] _logs/
  â”œâ”€â”€ [X] assets/
  â”œâ”€â”€ [X] src/
  â”‚   â”œâ”€â”€ ðŸ“„ __init__.py <--Empty
  â”‚   â””â”€â”€ ðŸ“„ app.py  <--The Hybrid Entry Point
  â”œâ”€â”€ ðŸ“„ AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
  â”œâ”€â”€ ðŸ“„ LICENSE.md
  â”œâ”€â”€ ðŸ“„ README.md
  â”œâ”€â”€ ðŸ“„ requirements.txt
  â””â”€â”€ ðŸ“„ setup_env.bat


3. THE CODE PATTERN (Hybrid Entry Point):
The `src/app.py` must use the following pattern to support both CLI utility and a GUI Showcase mode:

    import sys
    import argparse
    import tkinter as tk

    # --- CORE LOGIC (Importable) ---
    def core_logic(...):
        pass

    # --- GUI MODE (Default / Showcase) ---
    def run_gui():
        # A simple Tkinter window to demonstrate the tool works
        # Must not crash if launched with no args
        pass

    # --- CLI MODE (Utility) ---
    def run_cli():
        # Uses argparse
        # Only runs if sys.argv has arguments
        pass

    def main():
        if len(sys.argv) > 1:
            run_cli()
        else:
            run_gui()

    if __name__ == "__main__":
        main()

4. OUTPUT PROTOCOL (CRITICAL):
You must choose the correct output format based on the complexity of the change.

A. FOR INITIAL REFACTOR / LARGE CHANGES / CONFUSION:
   - Always provide the **FULL GENERATED FILE** content.
   - If a surgical patch failed or risks mangling the file, fallback to a full file dump immediately.

B. FOR SURGICAL PATCHES (Small Logic Tweaks):
   - If the file exists and the change is small/isolated, use the following JSON schema:
   ```json
   {
     "hunks": [
       {
         "description": "Short human description",
         "search_block": "exact text to find\n(can span multiple lines)",
         "replace_block": "replacement text\n(same or different length)",
         "use_patch_indent": false
       }
     ]
   }

NOTE:
Do not remove core functionality, but wrap it cleanly. Only remove functionality if actively altering the app with the user after integrating into the boilerplate.

Are you ready for the source code?
--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\requirements.txt
--------------------------------------------------------------------------------
tk>=0.1.0
--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\src\app.py
--------------------------------------------------------------------------------
import sys
import argparse
import tkinter as tk
from tkinter import filedialog, scrolledtext, ttk, messagebox
import tkinter.font as tkFont
from pathlib import Path
from datetime import datetime
import subprocess
import platform
import threading
import queue
import traceback
import fnmatch
import os
import json
import tarfile

# ==============================================================================
# 0. PYTHONW SAFETY CHECK
# ==============================================================================
# Fixes issues where pythonw crashes because it has no stdout/stderr attached
if sys.stdout is None:
    sys.stdout = open(os.devnull, "w")
if sys.stderr is None:
    sys.stderr = open(os.devnull, "w")

# ==============================================================================
# 1. CORE CONFIGURATION & CONSTANTS
# ==============================================================================

APP_DIR = Path(__file__).resolve().parent
DEFAULT_ROOT_DIR = APP_DIR

# --- Exclusions ---
EXCLUDED_FOLDERS = {
    "node_modules", ".git", "__pycache__", ".venv", ".mypy_cache",
    "_logs", "dist", "build", ".vscode", ".idea", "target", "out",
    "bin", "obj", "Debug", "Release", "logs"
}
PREDEFINED_EXCLUDED_FILENAMES = {
    "package-lock.json", "yarn.lock", ".DS_Store", "Thumbs.db",
    "*.pyc", "*.pyo", "*.swp", "*.swo"
}

# --- Binary Extensions (for skipping in dump) ---
FORCE_BINARY_EXTENSIONS_FOR_DUMP = {
    ".tar.gz", ".gz", ".zip", ".rar", ".7z", ".bz2", ".xz", ".tgz",
    ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".webp", ".tif", ".tiff",
    ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a",
    ".mp4", ".mkv", ".avi", ".mov", ".webm", ".flv", ".wmv",
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".odt", ".ods",
    ".exe", ".dll", ".so", ".o", ".a", ".lib", ".app", ".dmg", ".deb", ".rpm",
    ".db", ".sqlite", ".mdb", ".accdb", ".dat", ".idx", ".pickle", ".joblib",
    ".pyc", ".pyo", ".class", ".jar", ".wasm",
    ".ttf", ".otf", ".woff", ".woff2",
    ".iso", ".img", ".bin", ".bak", ".data", ".asset", ".pak"
}

# --- Log Configuration ---
LOG_ROOT_NAME = "_logs"
PROJECT_CONFIG_FILENAME = "_project_mapper_config.json"

# --- State Constants ---
S_CHECKED = "checked"
S_UNCHECKED = "unchecked"

# ==============================================================================
# 2. HELPER FUNCTIONS (Pure Logic / Stateless)
# ==============================================================================

def is_binary(file_path: Path) -> bool:
    """Check if a file is binary by reading the first chunk."""
    try:
        with open(file_path, 'rb') as f:
            return b'\0' in f.read(1024)
    except (IOError, PermissionError):
        return True
    except Exception:
        return True

def get_folder_size_bytes(folder_path: Path) -> int:
    """Recursively calculate folder size."""
    total_size = 0
    try:
        for entry in os.scandir(folder_path):
            if entry.is_file(follow_symlinks=False):
                try: total_size += entry.stat(follow_symlinks=False).st_size
                except OSError: pass
            elif entry.is_dir(follow_symlinks=False):
                try: total_size += get_folder_size_bytes(Path(entry.path))
                except OSError: pass
    except OSError: pass
    return total_size

def format_display_size(size_bytes: int) -> str:
    """Format bytes into readable string."""
    if size_bytes < 1024: return f"{size_bytes} B"
    size_kb = size_bytes / 1024
    if size_kb < 1024: return f"{size_kb:.1f} KB"
    size_mb = size_kb / 1024
    if size_mb < 1024: return f"{size_mb:.1f} MB"
    size_gb = size_mb / 1024
    return f"{size_gb:.2f} GB"

# ==============================================================================
# 3. GUI COMPONENTS & PROGRESS POPUP
# ==============================================================================

class ProgressPopup:
    """A popup window that streams activity and allows cancellation."""
    def __init__(self, parent, title="Processing", on_cancel=None):
        self.top = tk.Toplevel(parent)
        self.top.title(title)
        self.top.geometry("500x300")
        self.top.configure(bg="#252526")
        self.top.transient(parent)
        self.top.grab_set()
        
        self.top.protocol("WM_DELETE_WINDOW", self._on_close_attempt)

        self.on_cancel = on_cancel
        self.is_cancelled = False

        # UI Elements
        lbl = tk.Label(self.top, text=f"{title}...", fg="white", bg="#252526", font=("Arial", 12, "bold"))
        lbl.pack(pady=10)

        self.log_display = scrolledtext.ScrolledText(self.top, height=10, bg="#1e1e1e", fg="#00ff00", font=("Consolas", 9))
        self.log_display.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        btn_frame = tk.Frame(self.top, bg="#252526")
        btn_frame.pack(fill=tk.X, pady=10)

        self.cancel_btn = tk.Button(btn_frame, text="CANCEL OPERATION", bg="#c23621", fg="white", 
                                    font=("Arial", 10, "bold"), command=self.trigger_cancel)
        self.cancel_btn.pack()

    def update_text(self, text):
        self.log_display.insert(tk.END, text + "\n")
        self.log_display.see(tk.END)

    def trigger_cancel(self):
        self.is_cancelled = True
        self.log_display.insert(tk.END, "\n!!! CANCELLATION REQUESTED - STOPPING !!!\n")
        self.log_display.see(tk.END)
        self.cancel_btn.config(state=tk.DISABLED, text="Stopping...")
        if self.on_cancel:
            self.on_cancel()

    def _on_close_attempt(self):
        if not self.is_cancelled:
            self.trigger_cancel()
        
    def close(self):
        self.top.destroy()


class ProjectMapperApp:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.gui_queue = queue.Queue()

        # Application State
        self.folder_item_states = {}
        self.dynamic_global_excluded_filenames = set()
        self.running_tasks = set()
        self._tree_is_ready = False
        
        # Threading Safety
        self.state_lock = threading.RLock()
        self.stop_event = threading.Event()

        # References
        self.widgets = {}
        self.current_progress_popup = None

        self.glyphs = {S_UNCHECKED: "[ ]", S_CHECKED: "[X]"}

        self._setup_styles()
        self._setup_ui()
        self.process_gui_queue()
        
        self._activity_blinker()

        # Initial Actions
        self.root.after(100, lambda: self.run_threaded_action(self._load_conda_info_impl, task_id='load_conda'))
        self.root.after(200, self._rescan_project_tree)

    # --- UI Setup ---
    def _setup_styles(self):
        style = ttk.Style()
        if "clam" in style.theme_names(): style.theme_use("clam")
        
        self.default_ui_font = "Arial"
        if "DejaVu Sans" in tkFont.families(): self.default_ui_font = "DejaVu Sans"

        tree_font = tkFont.Font(family=self.default_ui_font, size=11)
        
        self.widgets['tree_bg_normal'] = "#252526"
        self.widgets['tree_bg_disabled'] = "#3a3a3a"
        
        style.configure("Treeview", background=self.widgets['tree_bg_normal'], 
                        foreground="lightgray", fieldbackground=self.widgets['tree_bg_normal'],
                        borderwidth=0, font=tree_font, rowheight=24)
        style.map("Treeview", background=[('selected', '#007ACC')], foreground=[('selected', 'white')])
        style.configure("Treeview.Heading", background="#333333", foreground="white", relief=tk.FLAT)
        
        style.configure('TCombobox', fieldbackground='#2a2a3f', background='#4a4a5a', foreground='white')

    def _setup_ui(self):
        self.root.title("Project Mapper - Systems Thinker Edition")
        self.root.configure(bg="#1e1e2f")
        self.root.geometry("1200x850")

        # 1. Top Bar
        top_frame = tk.Frame(self.root, bg="#1e1e2f")
        top_frame.pack(fill=tk.X, padx=10, pady=8)

        tk.Label(top_frame, text="Project Root:", bg="#1e1e2f", fg="white").pack(side=tk.LEFT)
        
        self.widgets['selected_root_var'] = tk.StringVar(value=str(DEFAULT_ROOT_DIR))
        self.widgets['project_path_entry'] = tk.Entry(top_frame, textvariable=self.widgets['selected_root_var'], 
                                                      bg="#2a2a3f", fg="lightblue", width=60)
        self.widgets['project_path_entry'].pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.widgets['project_path_entry'].bind("<Return>", self._on_project_root_commit)

        tk.Button(top_frame, text="Choose...", command=self._on_choose_project_directory, bg="#4a4a5a", fg="white").pack(side=tk.RIGHT)
        tk.Button(top_frame, text="â†‘", command=self._on_click_up_dir, bg="#4a4a5a", fg="white").pack(side=tk.RIGHT, padx=5)

        # 2. Main Split (Changed to VERTICAL for pythonw layout stability)
        paned = ttk.PanedWindow(self.root, orient=tk.VERTICAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Top Pane: Tree
        left_frame = tk.Frame(paned, bg="#1e1e2f")
        self.widgets['folder_tree'] = ttk.Treeview(left_frame, show="tree", columns=("size"), selectmode="none")
        self.widgets['folder_tree'].column("#0", width=800)
        self.widgets['folder_tree'].column("size", width=100, anchor="e")
        self.widgets['folder_tree'].heading("size", text="Size")
        
        vsb = ttk.Scrollbar(left_frame, orient="vertical", command=self.widgets['folder_tree'].yview)
        self.widgets['folder_tree'].configure(yscrollcommand=vsb.set)
        
        self.widgets['folder_tree'].pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        self.widgets['folder_tree'].bind("<ButtonRelease-1>", self.on_tree_item_click)
        
        paned.add(left_frame, weight=3) # Give tree more initial weight

        # Bottom Pane: Actions & Logs
        right_frame = tk.Frame(paned, bg="#1e1e2f")
        
        # Action Buttons Grid
        btn_grid = tk.Frame(right_frame, bg="#1e1e2f")
        btn_grid.pack(fill=tk.X, pady=5)
        
        self.widgets['buttons'] = {}
        actions = [
            ("Map Project Tree", self.build_folder_tree_impl, True),
            ("Dump Source Files", self.dump_files_impl, True),
            ("Backup Project (Zip)", self.backup_project_impl, True),
            ("Audit System Info", self.audit_system_impl, False)
        ]

        for idx, (lbl, func, save) in enumerate(actions):
            r, c = divmod(idx, 4) # Spread buttons horizontally
            b = tk.Button(btn_grid, text=lbl, bg="#007ACC", fg="white", font=("Arial", 11, "bold"), pady=8)
            task_id = lbl.split()[0].lower()
            b.config(command=lambda f=func, t=task_id, s=save: self.run_threaded_action(f, task_id=t, save_config_after=s, use_popup=True))
            b.grid(row=r, column=c, sticky="ew", padx=5, pady=5)
            btn_grid.columnconfigure(c, weight=1)
            self.widgets['buttons'][task_id] = b

        # Controls & Utility Section
        util_frame = tk.Frame(right_frame, bg="#1e1e2f")
        util_frame.pack(fill=tk.X, pady=5)

        # -- Timestamp Checkbox --
        self.widgets['use_timestamps'] = tk.BooleanVar(value=False)
        ts_chk = tk.Checkbutton(util_frame, text="Append Timestamps to Filenames", variable=self.widgets['use_timestamps'],
                                bg="#1e1e2f", fg="white", selectcolor="#252526", activebackground="#1e1e2f")
        ts_chk.pack(side=tk.LEFT, padx=10)

        # -- Conda --
        tk.Label(util_frame, text="| Env:", bg="#1e1e2f", fg="gray").pack(side=tk.LEFT)
        self.widgets['conda_env_var'] = tk.StringVar()
        self.widgets['conda_env_combo'] = ttk.Combobox(util_frame, textvariable=self.widgets['conda_env_var'], state="readonly", width=15)
        self.widgets['conda_env_combo'].pack(side=tk.LEFT, padx=5)
        tk.Button(util_frame, text="Audit", bg="#4a4a5a", fg="white", font=("Arial", 8),
                  command=lambda: self.run_threaded_action(self.audit_conda_impl, task_id='audit_conda', use_popup=True)).pack(side=tk.LEFT)

        # -- Utility --
        tk.Button(util_frame, text="Open Logs", command=self.open_main_log_directory, bg="#4a4a5a", fg="white").pack(side=tk.RIGHT, padx=5)
        tk.Button(util_frame, text="Exclusions", command=self.manage_dynamic_exclusions_popup, bg="#007a7a", fg="white").pack(side=tk.RIGHT, padx=5)
        
        # -- Quick Add Exclusion --
        tk.Button(util_frame, text="Add", command=lambda: self.add_excluded_filename(self.exc_entry), bg="#007ACC", fg="white", font=("Arial", 8)).pack(side=tk.RIGHT, padx=5)
        self.exc_entry = tk.Entry(util_frame, bg="#3a3a4a", fg="white", width=15)
        self.exc_entry.pack(side=tk.RIGHT, padx=5)
        tk.Label(util_frame, text="Excl. Pattern:", bg="#1e1e2f", fg="gray").pack(side=tk.RIGHT)

        # Log Box
        self.widgets['log_box'] = scrolledtext.ScrolledText(right_frame, bg="#151521", fg="#E0E0E0", font=("Consolas", 9), state=tk.DISABLED, height=10)
        self.widgets['log_box'].pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        paned.add(right_frame, weight=1)

        # Status Bar
        self.widgets['status_var'] = tk.StringVar(value="Ready.")
        self.widgets['status_bar'] = tk.Label(self.root, textvariable=self.widgets['status_var'], bg="#111111", fg="#90EE90", anchor="w")
        self.widgets['status_bar'].pack(fill=tk.X, side=tk.BOTTOM)

    # --- Threading & Activity Logic ---
    def _activity_blinker(self):
        if self.running_tasks:
            current_color = self.widgets['status_bar'].cget("bg")
            next_color = "#333333" if current_color == "#111111" else "#111111"
            self.widgets['status_bar'].config(bg=next_color)
            task_names = ", ".join(self.running_tasks)
            self.widgets['status_var'].set(f"[ACTIVE] Processing: {task_names}")
        else:
            self.widgets['status_bar'].config(bg="#111111")
            
        self.root.after(500, self._activity_blinker)

    def cancel_current_operations(self):
        self.stop_event.set()
        self.log_message("Stop signal sent to background threads.", "WARNING")

    def run_threaded_action(self, target_function_impl, task_id: str, widgets_to_disable=None, save_config_after=False, use_popup=False):
        if task_id in self.running_tasks:
            self.log_message(f"Task '{task_id}' is already running.", "WARNING")
            return

        if use_popup:
            self.current_progress_popup = ProgressPopup(self.root, title=f"Working: {task_id}", on_cancel=self.cancel_current_operations)

        def thread_target_wrapper():
            self.running_tasks.add(task_id)
            self.stop_event.clear()
            
            try:
                target_function_impl()
                if save_config_after:
                    path = self._get_current_project_path()
                    if path: self.save_project_config(path)
            except Exception as e:
                err_msg = f"CRASH in {task_id}: {e}\n{traceback.format_exc()}"
                self.schedule_log_message(err_msg, "CRITICAL")
            finally:
                if task_id in self.running_tasks:
                    self.running_tasks.remove(task_id)
                if use_popup and self.current_progress_popup:
                    self.gui_queue.put(self.current_progress_popup.close)
                    self.current_progress_popup = None
                self.schedule_log_message(f"Task '{task_id}' finished.", "INFO")

        threading.Thread(target=thread_target_wrapper, daemon=True).start()

    def schedule_log_message(self, msg: str, level: str = "INFO"):
        self.gui_queue.put(lambda: self.log_message(msg, level))
        def _update_popup_safely():
            if self.current_progress_popup:
                self.current_progress_popup.update_text(f"[{level}] {msg}")
        self.gui_queue.put(_update_popup_safely)

    def log_message(self, msg: str, level: str = "INFO"):
        ts = datetime.now().strftime("[%H:%M:%S]")
        full_msg = f"{ts} [{level}] {msg}\n"
        lb = self.widgets.get('log_box')
        if lb:
            lb.config(state=tk.NORMAL)
            lb.insert(tk.END, full_msg)
            lb.config(state=tk.DISABLED)
            lb.see(tk.END)
        self.widgets['status_var'].set(f"{ts} {msg}")

    def process_gui_queue(self):
        while not self.gui_queue.empty():
            try:
                cb = self.gui_queue.get_nowait()
                try: cb()
                except Exception: pass
            except queue.Empty: pass
        self.root.after(100, self.process_gui_queue)

    # --- Project Management Logic ---
    def _on_choose_project_directory(self):
        d = filedialog.askdirectory()
        if d:
            self.widgets['selected_root_var'].set(d)
            self._rescan_project_tree()

    def _on_project_root_commit(self, event=None):
        self._rescan_project_tree()

    def _on_click_up_dir(self):
        p = self._get_current_project_path()
        if p:
            self.widgets['selected_root_var'].set(str(p.parent))
            self._rescan_project_tree()

    def _get_current_project_path(self) -> Path | None:
        p_str = self.widgets['selected_root_var'].get()
        if p_str:
            p = Path(p_str)
            if p.is_dir(): return p
        return None

    def _rescan_project_tree(self):
        path = self._get_current_project_path()
        tree = self.widgets['folder_tree']
        for i in tree.get_children(): tree.delete(i)
        
        if not path:
            tree.insert("", "end", text="Invalid Root Path")
            return
            
        tree.insert("", "end", text="Scanning...")
        self.run_threaded_action(lambda: self._initial_tree_load_impl(path), task_id='load_tree')

    def _initial_tree_load_impl(self, root_path: Path):
        with self.state_lock:
            self.folder_item_states.clear()
        
        self.load_project_config(root_path)
        tree_data = []

        def _recurse(current: Path, parent_iid: str):
            if self.stop_event.is_set(): return
            try:
                items = sorted([x for x in current.iterdir() if x.is_dir()], key=lambda x: x.name.lower())
                for p in items:
                    path_str = str(p.resolve())
                    state = S_CHECKED
                    if path_str in self.folder_item_states: state = self.folder_item_states[path_str]
                    elif p.name in EXCLUDED_FOLDERS: state = S_UNCHECKED
                    
                    with self.state_lock: self.folder_item_states[path_str] = state
                    tree_data.append({'parent': parent_iid, 'iid': path_str, 'text': f" {p.name}"})
                    _recurse(p, path_str)
            except PermissionError: pass

        root_str = str(root_path.resolve())
        with self.state_lock: self.folder_item_states[root_str] = S_CHECKED
        tree_data.append({'parent': '', 'iid': root_str, 'text': f" {root_path.name}", 'open': True})
        
        _recurse(root_path, root_str)
        self.gui_queue.put(lambda: self._populate_tree(tree_data))

    def _populate_tree(self, data):
        tree = self.widgets['folder_tree']
        for i in tree.get_children(): tree.delete(i)
        for d in data:
            tree.insert(d['parent'], "end", iid=d['iid'], text=d['text'], open=d.get('open', False))
            tree.set(d['iid'], "size", "...")
        
        self.refresh_tree_visuals()
        root_path = self._get_current_project_path()
        if root_path:
             threading.Thread(target=self._calc_sizes_async, args=(str(root_path),), daemon=True).start()

    def _calc_sizes_async(self, root_iid):
        tree = self.widgets['folder_tree']
        q = [root_iid]
        while q:
            if self.stop_event.is_set(): break
            iid = q.pop(0)
            try:
                if not tree.exists(iid): continue
                sz = get_folder_size_bytes(Path(iid))
                fmt = format_display_size(sz)
                self.gui_queue.put(lambda i=iid, s=fmt: (tree.set(i, "size", s), self.refresh_tree_visuals(i)))
                q.extend(tree.get_children(iid))
            except: pass

    def refresh_tree_visuals(self, start_node=None):
        tree = self.widgets['folder_tree']
        def _refresh(iid):
            if not tree.exists(iid): return
            with self.state_lock:
                st = self.folder_item_states.get(iid, S_UNCHECKED)
            glyph = self.glyphs.get(st, "[?]")
            name = Path(iid).name
            display = f"{glyph} {name}"
            tree.item(iid, text=display)
            for child in tree.get_children(iid): _refresh(child)
        
        if start_node: _refresh(start_node)
        else:
            root = self._get_current_project_path()
            if root: _refresh(str(root.resolve()))

    def on_tree_item_click(self, event):
        tree = event.widget
        iid = tree.identify_row(event.y)
        if not iid: return
        with self.state_lock:
            curr = self.folder_item_states.get(iid, S_UNCHECKED)
            new = S_CHECKED if curr != S_CHECKED else S_UNCHECKED
            self.folder_item_states[iid] = new
        self.refresh_tree_visuals(iid)

    def is_selected(self, path: Path, project_root: Path) -> bool:
        try: p = path.resolve()
        except: return False
        root = project_root.resolve()
        if p != root and not str(p).startswith(str(root)): return False
        curr = p
        while True:
            st = self.folder_item_states.get(str(curr))
            if st == S_UNCHECKED: return False
            if curr == root: return st != S_UNCHECKED
            if curr.parent == curr: break
            curr = curr.parent
        return True

    def should_exclude_file(self, filename: str) -> bool:
        with self.state_lock:
            pats = PREDEFINED_EXCLUDED_FILENAMES.union(self.dynamic_global_excluded_filenames)
        return any(fnmatch.fnmatch(filename, p) for p in pats)

    # --- Core Actions ---
    def get_log_dir(self, root: Path) -> Path | None:
        if not root: return None
        # CHANGED: All logs go directly to _logs, no subdirectories
        d = root / LOG_ROOT_NAME
        try: d.mkdir(parents=True, exist_ok=True)
        except: return None
        return d

    def _generate_filename(self, root_name: str, base_suffix: str, extension: str) -> str:
        # CHANGED: Naming convention logic
        # Default: FolderName_suffix.ext
        # If timestamp enabled: FolderName_suffix_timestamp.ext
        name = f"{root_name}_{base_suffix}"
        if self.widgets['use_timestamps'].get():
            ts = datetime.now().strftime('%Y%m%d_%H%M%S')
            name += f"_{ts}"
        name += extension
        return name

    def build_folder_tree_impl(self):
        root = self._get_current_project_path()
        if not root: return
        
        out_dir = self.get_log_dir(root)
        fname = self._generate_filename(root.name, "project_folder_tree", ".txt")
        out_file = out_dir / fname
        
        lines = [f"Project Tree: {root}\nGenerated: {datetime.now()}\n"]
        
        def _write_recurse(curr, prefix):
            if self.stop_event.is_set(): 
                lines.append(f"{prefix}!!! CANCELLED !!!")
                return

            try: items = sorted(list(curr.iterdir()), key=lambda x: (x.is_file(), x.name.lower()))
            except: return
            
            for i, item in enumerate(items):
                is_last = (i == len(items) - 1)
                conn = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
                
                if item.is_dir():
                    if self.is_selected(item, root):
                        lines.append(f"{prefix}{conn}ðŸ“ {item.name}/")
                        _write_recurse(item, prefix + ("    " if is_last else "â”‚   "))
                else:
                    if not self.should_exclude_file(item.name) and self.is_selected(item.parent, root):
                         lines.append(f"{prefix}{conn}ðŸ“„ {item.name}")
        
        _write_recurse(root, "")
        
        with open(out_file, "w", encoding="utf-8") as f: f.write("\n".join(lines))
        self.schedule_log_message(f"Tree saved: {fname}")

    def dump_files_impl(self):
        root = self._get_current_project_path()
        if not root: return
        
        out_dir = self.get_log_dir(root)
        fname = self._generate_filename(root.name, "filedump", ".txt")
        out_file = out_dir / fname
        
        count = 0
        with open(out_file, "w", encoding="utf-8") as f_out:
            f_out.write(f"Dump: {root}\n\n")
            
            for r, d, f in os.walk(root):
                if self.stop_event.is_set(): 
                    f_out.write("\n\n!!! DUMP CANCELLED BY USER !!!")
                    break
                
                curr = Path(r)
                d[:] = [x for x in d if self.is_selected(curr/x, root)]
                if not self.is_selected(curr, root): continue
                
                for fname_item in f:
                    if self.stop_event.is_set(): break
                    if self.should_exclude_file(fname_item): continue
                    
                    fpath = curr / fname_item
                    if fpath.stat().st_size > 1_000_000: continue
                    if is_binary(fpath) or "".join(fpath.suffixes).lower() in FORCE_BINARY_EXTENSIONS_FOR_DUMP: continue
                    
                    rel = fpath.relative_to(root)
                    if count % 5 == 0: self.schedule_log_message(f"Dumping: {rel}", "DEBUG")
                    
                    try:
                        f_out.write(f"\n{'-'*80}\nFILE: {rel}\n{'-'*80}\n")
                        with open(fpath, "r", encoding="utf-8", errors="ignore") as f_in:
                            f_out.write(f_in.read())
                        count += 1
                    except Exception as e:
                        f_out.write(f"\n[ERROR READING FILE: {e}]\n")
        
        self.schedule_log_message(f"Dump saved: {fname} ({count} files)")

    def backup_project_impl(self):
        root = self._get_current_project_path()
        if not root: return
        
        out_dir = self.get_log_dir(root)
        fname = self._generate_filename(root.name, "backup", ".tar.gz")
        out_file = out_dir / fname
        
        count = 0
        with tarfile.open(out_file, "w:gz") as tar:
            for r, d, f in os.walk(root):
                if self.stop_event.is_set(): break
                curr = Path(r)
                d[:] = [x for x in d if self.is_selected(curr/x, root)]
                if not self.is_selected(curr, root): continue
                for fname_item in f:
                    if self.should_exclude_file(fname_item): continue
                    fpath = curr / fname_item
                    tar.add(fpath, arcname=fpath.relative_to(root))
                    count += 1
                    if count % 10 == 0: self.schedule_log_message(f"Archiving: {fname_item}", "DEBUG")

        if self.stop_event.is_set():
            self.schedule_log_message("Backup Cancelled.", "WARNING")
        else:
            self.schedule_log_message(f"Backup saved: {fname}")

    def audit_system_impl(self):
        root = self._get_current_project_path() or DEFAULT_ROOT_DIR
        out_dir = self.get_log_dir(root)
        fname = self._generate_filename(root.name, "system_audit", ".txt")
        out_file = out_dir / fname
        
        lines = [f"System Audit: {datetime.now()}", f"Platform: {platform.platform()}"]
        lines.append(f"Python: {sys.version}")
        lines.append("\nEnvironment Variables (Keys only):")
        for k in os.environ.keys(): lines.append(f"  {k}")
        
        with open(out_file, "w") as f: f.write("\n".join(lines))
        self.schedule_log_message(f"System audit saved: {fname}")

    def audit_conda_impl(self):
        env_name = self.widgets['conda_env_var'].get()
        if not env_name: return
        root = self._get_current_project_path() or DEFAULT_ROOT_DIR
        out_dir = self.get_log_dir(root)
        fname = self._generate_filename(f"conda_{env_name}", "audit", ".txt")
        out_file = out_dir / fname
        
        self.schedule_log_message(f"Auditing Conda Env: {env_name}...")
        try:
            res = subprocess.run(["conda", "list", "-n", env_name], capture_output=True, text=True, shell=True)
            with open(out_file, "w") as f: f.write(res.stdout)
            self.schedule_log_message(f"Conda audit saved: {fname}")
        except Exception as e:
            self.schedule_log_message(f"Conda audit failed: {e}", "ERROR")

    def _load_conda_info_impl(self):
        try:
            res = subprocess.run(["conda", "env", "list", "--json"], capture_output=True, text=True, shell=True)
            data = json.loads(res.stdout)
            envs = [Path(p).name for p in data.get('envs', [])]
            self.gui_queue.put(lambda: self.widgets['conda_env_combo'].config(values=envs))
            if envs: self.gui_queue.put(lambda: self.widgets['conda_env_combo'].current(0))
        except: pass

    # --- Persistence ---
    def save_project_config(self, root: Path):
        cfg = self.get_log_dir(root) / PROJECT_CONFIG_FILENAME
        rel_states = {}
        with self.state_lock:
            for k, v in self.folder_item_states.items():
                try: rel_states[str(Path(k).relative_to(root))] = v
                except: pass
            data = {
                "folder_states": rel_states,
                "dynamic_exclusions": list(self.dynamic_global_excluded_filenames)
            }
        with open(cfg, "w") as f: json.dump(data, f, indent=2)

    def load_project_config(self, root: Path):
        cfg = self.get_log_dir(root) / PROJECT_CONFIG_FILENAME
        if not cfg.exists(): return
        try:
            with open(cfg, "r") as f: data = json.load(f)
            for k, v in data.get("folder_states", {}).items():
                self.folder_item_states[str((root / k).resolve())] = v
            self.dynamic_global_excluded_filenames.update(data.get("dynamic_exclusions", []))
        except: pass

    # --- Dynamic Exclusions ---
    def add_excluded_filename(self, entry):
        val = entry.get().strip()
        if val:
            self.dynamic_global_excluded_filenames.add(val)
            entry.delete(0, tk.END)
            self.schedule_log_message(f"Added exclusion: {val}")

    def manage_dynamic_exclusions_popup(self):
        top = tk.Toplevel(self.root)
        top.title("Exclusions")
        lb = tk.Listbox(top)
        lb.pack(fill=tk.BOTH, expand=True)
        for x in self.dynamic_global_excluded_filenames: lb.insert(tk.END, x)
        def _rem():
            sel = lb.curselection()
            if not sel: return
            val = lb.get(sel[0])
            self.dynamic_global_excluded_filenames.remove(val)
            top.destroy()
            self.manage_dynamic_exclusions_popup()
        tk.Button(top, text="Remove Selected", command=_rem).pack()

    def open_main_log_directory(self):
        p = self._get_current_project_path()
        if not p: return
        d = self.get_log_dir(p)
        if platform.system() == "Windows": os.startfile(d)
        elif platform.system() == "Darwin": subprocess.run(["open", d])
        else: subprocess.run(["xdg-open", d])


# ==============================================================================
# 4. ENTRY POINTS
# ==============================================================================

def run_gui():
    root = tk.Tk()
    app = ProjectMapperApp(root)
    root.mainloop()

def run_cli():
    parser = argparse.ArgumentParser(description="ProjectMapper CLI")
    parser.add_argument("path", nargs="?", default=".", help="Root path to map")
    args = parser.parse_args()
    
    target = Path(args.path).resolve()
    print(f"--- Project Mapper CLI ---\nMapping: {target}\n")
    
    if not target.is_dir():
        print("Error: Invalid directory.")
        sys.exit(1)
        
    for item in target.rglob("*"):
        depth = len(item.relative_to(target).parts)
        indent = "  " * depth
        print(f"{indent}{item.name}")
        
    print("\nDone. For full features (backup, dumping, config), use GUI mode.")

def main():
    if len(sys.argv) > 1 and sys.argv[1] not in ["-m", "src.app"]:
        run_cli()
    else:
        run_gui()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: _ProjectMAPPER\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\requirements.txt
--------------------------------------------------------------------------------
# Patchwright (TokenizingPATCHER) Prototype
# Uses only Python stdlib + Tkinter (bundled with standard Windows Python installs).
# No external dependencies required.

# (empty)
--------------------------------------------------------------------------------
FILE: _TasklistWORKER\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\app.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
== Tasklist Chat Prototype (Tkinter + Ollama) ==

A basic chat interface with:
- chat transcript
- tasklist editor popup (add/edit/remove steps)
- thought bubbles side panel (helper model summaries per step)

Entry:
- GUI (default): py -m src.app
- CLI (optional later): py -m src.app --help
"""

import sys
import argparse
import tkinter as tk
from tkinter import ttk, messagebox

from src._microservices.runner import run_tasklist


# -----------------------------
# Core (importable)
# -----------------------------

def new_state() -> dict:
    return {
        "chat": {
            "history": [],
            "last_user": "",
            "last_response": ""
        },
        "working": {
            "step_outputs": {},
            "thoughts": [],
            "notes": []
        },
        "outputs": {
            "final": ""
        }
    }


def default_tasklist() -> dict:
    """
    Start with something that demonstrates chaining + thought bubbles.
    """
    return {
        "name": "default_v0",
        "steps": [
            {
                "id": "S1",
                "name": "Draft answer",
                "enabled": True,
                "model": "",  # empty -> use selected chat model
                "ollama_options": {"temperature": 0.4},
                "system_prompt": "You are a helpful assistant. Answer clearly.",
                "user_prompt_template": "{{state.chat.last_user}}",
                "chain_mode": "none",
                "expects": "text",
                "output_key": "working.step_outputs.S1",
                "thought_enabled": True
            },
            {
                "id": "S2",
                "name": "Refine / tighten",
                "enabled": True,
                "model": "",  # empty -> use selected chat model
                "ollama_options": {"temperature": 0.2},
                "system_prompt": "Rewrite the prior answer to be tighter and more actionable.",
                "user_prompt_template": "Improve the following answer:\n\n{{last}}",
                "chain_mode": "replace",
                "expects": "text",
                "output_key": "outputs.final",
                "thought_enabled": True
            }
        ]
    }


# -----------------------------
# Tkinter UI
# -----------------------------

DARK_BG = "#0f1115"
PANEL_BG = "#141822"
ENTRY_BG = "#0b0e14"
FG = "#e7e7e7"
ACCENT = "#2a6ef2"


class TasklistEditor(tk.Toplevel):
    """
    Minimal â€œform-likeâ€ editor:
    - list of steps
    - add/edit/remove
    """
    def __init__(self, master, tasklist: dict):
        super().__init__(master)
        self.title("Tasklist Editor")
        self.configure(bg=DARK_BG)
        self.geometry("900x500")
        self.transient(master)
        self.grab_set()

        self.tasklist = tasklist

        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)

        frame = ttk.Frame(self, style="Panel.TFrame")
        frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(frame, columns=("enabled", "name", "chain"), show="headings")
        self.tree.heading("enabled", text="On")
        self.tree.heading("name", text="Name")
        self.tree.heading("chain", text="Chain")
        self.tree.column("enabled", width=50, anchor="center")
        self.tree.column("name", width=350)
        self.tree.column("chain", width=120, anchor="center")
        self.tree.grid(row=0, column=0, sticky="nsew")

        btns = ttk.Frame(frame, style="Panel.TFrame")
        btns.grid(row=1, column=0, sticky="ew", pady=(10, 0))
        btns.columnconfigure(5, weight=1)

        ttk.Button(btns, text="Add Step", command=self.add_step).grid(row=0, column=0, padx=5)
        ttk.Button(btns, text="Edit Step", command=self.edit_selected).grid(row=0, column=1, padx=5)
        ttk.Button(btns, text="Remove", command=self.remove_selected).grid(row=0, column=2, padx=5)
        ttk.Button(btns, text="Close", command=self.destroy).grid(row=0, column=6, padx=5)

        self.refresh()

    def refresh(self):
        for i in self.tree.get_children():
            self.tree.delete(i)
        for step in self.tasklist.get("steps", []):
            self.tree.insert(
                "",
                "end",
                iid=step["id"],
                values=("âœ“" if step.get("enabled", True) else "", step.get("name", ""), step.get("chain_mode", "none"))
            )

    def add_step(self):
        step_id = f"S{len(self.tasklist.get('steps', [])) + 1}"
        self.tasklist["steps"].append({
            "id": step_id,
            "name": f"Step {step_id}",
            "enabled": True,
            "model": "",
            "ollama_options": {"temperature": 0.3},
            "system_prompt": "",
            "user_prompt_template": "{{last}}",
            "chain_mode": "replace",
            "expects": "text",
            "output_key": f"working.step_outputs.{step_id}",
            "thought_enabled": True
        })
        self.refresh()

    def _get_selected_step(self):
        sel = self.tree.selection()
        if not sel:
            return None
        sid = sel[0]
        for step in self.tasklist.get("steps", []):
            if step.get("id") == sid:
                return step
        return None

    def edit_selected(self):
        step = self._get_selected_step()
        if not step:
            return

        StepEditor(self, step, on_save=self.refresh)

    def remove_selected(self):
        step = self._get_selected_step()
        if not step:
            return
        self.tasklist["steps"] = [s for s in self.tasklist.get("steps", []) if s.get("id") != step.get("id")]
        self.refresh()


class StepEditor(tk.Toplevel):
    def __init__(self, master, step: dict, on_save):
        super().__init__(master)
        self.title(f"Edit Step: {step.get('id')}")
        self.configure(bg=DARK_BG)
        self.geometry("820x560")
        self.transient(master)
        self.grab_set()

        self.step = step
        self.on_save = on_save

        self.columnconfigure(0, weight=1)
        self.rowconfigure(3, weight=1)
        self.rowconfigure(5, weight=2)

        top = ttk.Frame(self, style="Panel.TFrame")
        top.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        top.columnconfigure(1, weight=1)

        self.enabled_var = tk.BooleanVar(value=step.get("enabled", True))
        ttk.Checkbutton(top, text="Enabled", variable=self.enabled_var).grid(row=0, column=0, sticky="w", padx=5)

        ttk.Label(top, text="Name:").grid(row=1, column=0, sticky="w", padx=5, pady=(8, 0))
        self.name_var = tk.StringVar(value=step.get("name", ""))
        ttk.Entry(top, textvariable=self.name_var).grid(row=1, column=1, sticky="ew", padx=5, pady=(8, 0))

        ttk.Label(top, text="Chain Mode:").grid(row=2, column=0, sticky="w", padx=5, pady=(8, 0))
        self.chain_var = tk.StringVar(value=step.get("chain_mode", "replace"))
        ttk.Combobox(top, textvariable=self.chain_var, values=("none", "last", "replace"), state="readonly").grid(
            row=2, column=1, sticky="w", padx=5, pady=(8, 0)
        )

        ttk.Label(self, text="System Prompt:", style="Header.TLabel").grid(row=1, column=0, sticky="w", padx=12)
        self.sys_txt = tk.Text(self, height=6, bg=ENTRY_BG, fg=FG, insertbackground=FG, wrap="word")
        self.sys_txt.grid(row=2, column=0, sticky="ew", padx=12)
        self.sys_txt.insert("1.0", step.get("system_prompt", ""))

        ttk.Label(self, text="User Prompt Template:", style="Header.TLabel").grid(row=3, column=0, sticky="nw", padx=12)
        self.tpl_txt = tk.Text(self, bg=ENTRY_BG, fg=FG, insertbackground=FG, wrap="word")
        self.tpl_txt.grid(row=4, column=0, sticky="nsew", padx=12)
        self.tpl_txt.insert("1.0", step.get("user_prompt_template", ""))

        ttk.Label(self, text="Thought Bubble Template (helper):", style="Header.TLabel").grid(row=5, column=0, sticky="nw", padx=12, pady=(10, 0))
        self.thought_txt = tk.Text(self, bg=ENTRY_BG, fg=FG, insertbackground=FG, wrap="word", height=8)
        self.thought_txt.grid(row=6, column=0, sticky="nsew", padx=12, pady=(0, 10))
        self.thought_txt.insert("1.0", step.get("thought_prompt_template", "STEP: {{step_name}}\n\nOUTPUT:\n{{step_output}}\n\nReturn 1-3 bullets."))

        bottom = ttk.Frame(self, style="Panel.TFrame")
        bottom.grid(row=7, column=0, sticky="ew", padx=10, pady=(0, 10))
        bottom.columnconfigure(0, weight=1)

        ttk.Button(bottom, text="Save", command=self.save).grid(row=0, column=1, padx=5)
        ttk.Button(bottom, text="Cancel", command=self.destroy).grid(row=0, column=2, padx=5)

    def save(self):
        self.step["enabled"] = bool(self.enabled_var.get())
        self.step["name"] = self.name_var.get().strip() or self.step.get("id", "")
        self.step["chain_mode"] = self.chain_var.get().strip().lower()
        self.step["system_prompt"] = self.sys_txt.get("1.0", "end-1c")
        self.step["user_prompt_template"] = self.tpl_txt.get("1.0", "end-1c")
        self.step["thought_prompt_template"] = self.thought_txt.get("1.0", "end-1c")
        self.on_save()
        self.destroy()


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Tasklist Chat Prototype")
        self.configure(bg=DARK_BG)
        self.geometry("1300x780")

        self._build_style()

        self.state_obj = new_state()
        self.tasklist = default_tasklist()

        # models are just strings here; you can wire in /api/tags later
        self.chat_model = tk.StringVar(value="qwen2.5:7b")     # set to whatever you have locally
        self.helper_model = tk.StringVar(value="qwen2.5:1.5b") # small summarizer

        self._build_layout()

    def _build_style(self):
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except tk.TclError:
            pass

        style.configure("TFrame", background=DARK_BG)
        style.configure("Panel.TFrame", background=PANEL_BG)
        style.configure("TLabel", background=PANEL_BG, foreground=FG)
        style.configure("Header.TLabel", background=PANEL_BG, foreground=FG, font=("Segoe UI", 11, "bold"))
        style.configure("TButton", font=("Segoe UI", 10))

    def _build_layout(self):
        self.columnconfigure(0, weight=4)
        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)

        left = ttk.Frame(self, style="Panel.TFrame")
        left.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        left.columnconfigure(0, weight=1)
        left.rowconfigure(1, weight=1)

        header = ttk.Frame(left, style="Panel.TFrame")
        header.grid(row=0, column=0, sticky="ew")
        header.columnconfigure(6, weight=1)

        ttk.Label(header, text="Chat Model:").grid(row=0, column=0, padx=(5, 2))
        ttk.Entry(header, textvariable=self.chat_model, width=22).grid(row=0, column=1, padx=2)

        ttk.Label(header, text="Helper Model:").grid(row=0, column=2, padx=(10, 2))
        ttk.Entry(header, textvariable=self.helper_model, width=22).grid(row=0, column=3, padx=2)

        ttk.Button(header, text="Edit Tasklist", command=self.open_tasklist_editor).grid(row=0, column=4, padx=(10, 2))
        ttk.Button(header, text="Clear", command=self.clear_all).grid(row=0, column=5, padx=2)

        self.chat_txt = tk.Text(left, bg=ENTRY_BG, fg=FG, insertbackground=FG, wrap="word")
        self.chat_txt.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)

        entry_bar = ttk.Frame(left, style="Panel.TFrame")
        entry_bar.grid(row=2, column=0, sticky="ew", padx=5, pady=(0, 5))
        entry_bar.columnconfigure(0, weight=1)

        self.user_entry = ttk.Entry(entry_bar)
        self.user_entry.grid(row=0, column=0, sticky="ew", padx=(0, 6))
        self.user_entry.bind("<Return>", lambda e: self.send())

        ttk.Button(entry_bar, text="Send / Run Tasklist", command=self.send).grid(row=0, column=1)

        # Right thoughts panel
        right = ttk.Frame(self, style="Panel.TFrame")
        right.grid(row=0, column=1, sticky="nsew", padx=(0, 10), pady=10)
        right.columnconfigure(0, weight=1)
        right.rowconfigure(1, weight=1)

        ttk.Label(right, text="Thoughts", style="Header.TLabel").grid(row=0, column=0, sticky="w", padx=8, pady=(8, 0))
        self.thoughts_txt = tk.Text(right, bg=ENTRY_BG, fg=FG, insertbackground=FG, wrap="word")
        self.thoughts_txt.grid(row=1, column=0, sticky="nsew", padx=8, pady=8)

    def open_tasklist_editor(self):
        TasklistEditor(self, self.tasklist)

    def clear_all(self):
        self.state_obj = new_state()
        self.chat_txt.delete("1.0", "end")
        self.thoughts_txt.delete("1.0", "end")

    def _append_chat(self, role: str, content: str):
        self.chat_txt.insert("end", f"{role.upper()}:\n{content}\n\n")
        self.chat_txt.see("end")

    def _render_thoughts(self):
        self.thoughts_txt.delete("1.0", "end")
        for t in self.state_obj["working"].get("thoughts", []):
            self.thoughts_txt.insert("end", f"{t.get('step_id')} â€” {t.get('name')}\n{t.get('summary')}\n\n")
        self.thoughts_txt.see("end")

    def send(self):
        user_text = self.user_entry.get().strip()
        if not user_text:
            return

        self.user_entry.delete(0, "end")

        # store user message
        self.state_obj["chat"]["last_user"] = user_text
        self.state_obj["chat"]["history"].append({"role": "user", "content": user_text})
        self._append_chat("user", user_text)

        try:
            self.state_obj = run_tasklist(
                state=self.state_obj,
                tasklist=self.tasklist,
                chat_model_default=self.chat_model.get().strip(),
                helper_model_default=self.helper_model.get().strip(),
            )
        except Exception as e:
            messagebox.showerror("Run failed", str(e))
            return

        final = self.state_obj["outputs"].get("final") or self.state_obj["chat"].get("last_response") or ""
        self.state_obj["chat"]["history"].append({"role": "assistant", "content": final})
        self._append_chat("assistant", final)

        self._render_thoughts()


# -----------------------------
# CLI / Entrypoint
# -----------------------------

def main():
    parser = argparse.ArgumentParser(description="Tasklist Chat Prototype (GUI by default).")
    parser.add_argument("--nogui", action="store_true", help="Do not launch GUI (placeholder for future CLI mode).")
    args = parser.parse_args()

    if args.nogui:
        print("CLI mode not implemented yet. Run without --nogui to launch the GUI.")
        return 0

    app = App()
    app.mainloop()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\_microservices\ollama_client.py
--------------------------------------------------------------------------------
import json
import urllib.request
import urllib.error


class OllamaClient:
    def __init__(self, base_url: str = "http://localhost:11434"):
        self.base_url = base_url.rstrip("/")

    # -----------------------------
    # Low-level helpers
    # -----------------------------

    def _read_json(self, resp) -> dict:
        raw = resp.read().decode("utf-8", errors="replace")
        try:
            return json.loads(raw)
        except Exception as e:
            raise RuntimeError(f"Ollama returned non-JSON response: {e}\nRAW:\n{raw}")

    def _request_json(self, method: str, path: str, payload: dict | None = None, timeout: int = 60) -> dict:
        url = f"{self.base_url}{path}"

        data = None
        headers = {}
        if payload is not None:
            data = json.dumps(payload).encode("utf-8")
            headers["Content-Type"] = "application/json"

        req = urllib.request.Request(url, data=data, headers=headers, method=method)

        try:
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                return self._read_json(resp)
        except urllib.error.HTTPError as e:
            # HTTPError is also a file-like object; it may contain JSON
            try:
                body = e.read().decode("utf-8", errors="replace")
            except Exception:
                body = "<unable to read body>"
            raise RuntimeError(f"Ollama HTTPError {e.code} for {method} {path}: {e.reason}\nBODY:\n{body}")
        except urllib.error.URLError as e:
            raise RuntimeError(f"Ollama URLError for {method} {path}: {e}")

    # -----------------------------
    # Public API
    # -----------------------------

    def list_models(self) -> list[str]:
        """Return list of installed model names via Ollama /api/tags."""
        obj = self._request_json("GET", "/api/tags", payload=None, timeout=30)
        models = []
        for m in obj.get("models", []) or []:
            name = m.get("name")
            if name:
                models.append(name)
        return models

    def generate(self, model: str, system: str, prompt: str, options: dict | None = None) -> str:
        """Uses Ollama /api/generate with system+prompt. Returns response text."""
        payload = {
            "model": model,
            "prompt": prompt,
            "system": system,
            "stream": False
        }
        if options:
            payload["options"] = options

        obj = self._request_json("POST", "/api/generate", payload=payload, timeout=300)
        return obj.get("response", "")


--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\_microservices\runner.py
--------------------------------------------------------------------------------
import json
from typing import Any, Dict, List, Optional, Tuple

from src._microservices.ollama_client import OllamaClient
from src._microservices.template_engine import resolve_template

_client = OllamaClient()


def _set_by_path(state: dict, path: str, value):
    # path like "working.step_outputs.S1" or "chat.last_response"
    parts = path.split(".")
    cur = state
    for p in parts[:-1]:
        cur = cur.setdefault(p, {})
    cur[parts[-1]] = value


def _get_by_path(state: dict, path: str):
    parts = path.split(".")
    cur = state
    for p in parts:
        if not isinstance(cur, dict) or p not in cur:
            return None
        cur = cur[p]
    return cur


def _ensure_state_defaults(state: dict) -> dict:
    """
    Runner-friendly defaults so UI can pass a minimal state in.
    """
    state.setdefault("chat", {})
    state["chat"].setdefault("history", [])          # list[{role, content}]
    state["chat"].setdefault("last_user", "")
    state["chat"].setdefault("last_response", "")

    state.setdefault("working", {})
    state["working"].setdefault("step_outputs", {})  # dict step_id -> output
    state["working"].setdefault("thoughts", [])      # list[{step_id, name, summary, errors?}]
    state["working"].setdefault("notes", [])         # list[{step_id, name, errors}]

    state.setdefault("outputs", {})
    state["outputs"].setdefault("final", "")

    return state


def _chain_prompt(base_prompt: str, chain_mode: str, last: str) -> str:
    """
    chain_mode:
      - "none": base_prompt only
      - "last": base_prompt + "\n\n---\nLAST_OUTPUT:\n" + last
      - "replace": replace occurrences of "{{last}}" in base_prompt
    """
    last = last or ""
    chain_mode = (chain_mode or "none").strip().lower()

    if chain_mode == "none":
        return base_prompt
    if chain_mode == "last":
        if not last:
            return base_prompt
        return f"{base_prompt}\n\n---\nLAST_OUTPUT:\n{last}"
    if chain_mode == "replace":
        return base_prompt.replace("{{last}}", last)

    # unknown -> safe default
    return base_prompt


def _safe_json_loads(text: str) -> Tuple[Optional[Any], Optional[str]]:
    try:
        return json.loads(text), None
    except Exception as e:
        return None, str(e)


def _run_helper_summary(
    helper_model: str,
    helper_system: str,
    helper_template: str,
    step_name: str,
    step_output: str,
    state: dict,
    options: Optional[dict] = None
) -> str:
    """
    Summarize what happened in this step. The template can reference:
      - {{state....}} via template_engine
      - {{step_name}}
      - {{step_output}}
    """
    tmp_state = dict(state)
    tmp_state.setdefault("_step_ctx", {})
    tmp_state["_step_ctx"]["step_name"] = step_name
    tmp_state["_step_ctx"]["step_output"] = step_output

    # allow easy placeholders without complicating template_engine:
    prompt = helper_template.replace("{{step_name}}", step_name).replace("{{step_output}}", step_output)
    prompt = resolve_template(prompt, tmp_state)

    raw = _client.generate(
        model=helper_model,
        system=helper_system,
        prompt=prompt,
        options=options or {"temperature": 0.2}
    )
    return (raw or "").strip()


def run_tasklist(
    state: dict,
    tasklist: dict,
    chat_model_default: str,
    helper_model_default: str,
) -> dict:
    """
    Generic tasklist runner.

    Each step:
      - builds a prompt from user_prompt_template (+ optional chaining)
      - calls an Ollama model
      - stores output to output_key
      - optionally runs helper summary (thought bubble)

    Expected step fields (minimal):
      - id (str)
      - name (str)
      - enabled (bool)
      - model (optional; defaults to chat_model_default)
      - system_prompt (str)
      - user_prompt_template (str)
      - chain_mode ("none" | "last" | "replace") optional
      - output_key (defaults to "working.step_outputs.<id>")
      - expects ("text" | "json") optional
      - thought_enabled (bool) optional
      - thought_model (optional; defaults helper_model_default)
      - thought_system_prompt (optional)
      - thought_prompt_template (optional)
    """
    state = _ensure_state_defaults(state)

    steps = tasklist.get("steps", [])
    last = state["chat"].get("last_response", "")

    for step in steps:
        if not step.get("enabled", True):
            continue

        step_id = step.get("id", "STEP?")
        step_name = step.get("name", step_id)

        model = step.get("model") or chat_model_default
        system = step.get("system_prompt", "")
        template = step.get("user_prompt_template", "")
        options = step.get("ollama_options") or {}

        chain_mode = step.get("chain_mode", "none")
        expects = step.get("expects", "text").strip().lower()

        output_key = step.get("output_key") or f"working.step_outputs.{step_id}"

        # 1) build prompt
        base_prompt = resolve_template(template, state)
        prompt = _chain_prompt(base_prompt, chain_mode, last)

        # 2) call model
        raw = _client.generate(model=model, system=system, prompt=prompt, options=options)
        raw_stripped = (raw or "").strip()

        # 3) parse/store
        produced_obj = None
        if expects == "json":
            produced_obj, err = _safe_json_loads(raw_stripped)
            if err:
                state["working"]["notes"].append({
                    "step_id": step_id,
                    "name": step_name,
                    "errors": [f"json_parse failed: {err}"]
                })
                # fall back to raw text storage
                _set_by_path(state, output_key, raw_stripped)
                last = raw_stripped
            else:
                _set_by_path(state, output_key, produced_obj)
                last = json.dumps(produced_obj, ensure_ascii=False)
        else:
            _set_by_path(state, output_key, raw_stripped)
            last = raw_stripped

        # record runner-level last_response
        state["chat"]["last_response"] = last

        # 4) thought bubble (helper model)
        if step.get("thought_enabled", True):
            helper_model = step.get("thought_model") or helper_model_default
            helper_system = step.get("thought_system_prompt") or (
                "Summarize what happened in this step in 1-3 bullet points. "
                "Be concrete. No fluff. No preamble."
            )
            helper_template = step.get("thought_prompt_template") or (
                "STEP: {{step_name}}\n\nOUTPUT:\n{{step_output}}\n\n"
                "Return 1-3 bullets: what changed / what was decided / what to do next."
            )

            try:
                summary = _run_helper_summary(
                    helper_model=helper_model,
                    helper_system=helper_system,
                    helper_template=helper_template,
                    step_name=step_name,
                    step_output=last,
                    state=state,
                    options={"temperature": 0.2}
                )
            except Exception as e:
                summary = f"- Thought summary failed: {e}"

            state["working"]["thoughts"].append({
                "step_id": step_id,
                "name": step_name,
                "summary": summary
            })

    state["outputs"]["final"] = state["chat"].get("last_response", "")
    return state

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\_microservices\state.py
--------------------------------------------------------------------------------
def new_state() -> dict:
    """Create a fresh state object for the Tasklist Chat Prototype.

    Structure notes:
      - chat: conversational inputs + last outputs
      - working: per-step artifacts (outputs, thought bubbles, errors)
      - outputs: final result produced by the tasklist runner
    """
    return {
        "chat": {
            "history": [],            # list of {"role": "user"|"assistant", "content": str}
            "last_user": "",          # last user message
            "last_response": ""       # last model output (string form)
        },
        "working": {
            "step_outputs": {},       # dict step_id -> output (text or parsed json)
            "thoughts": [],           # list of {step_id, name, summary}
            "notes": []               # list of {step_id, name, errors:[...]}
        },
        "outputs": {
            "final": ""              # final assistant message to display in chat
        }
    }


--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\_microservices\tasklists.py
--------------------------------------------------------------------------------
def get_tasklist_names(mode: str):
    tl = _TASKLISTS.get(mode, {})
    return list(tl.keys())

def load_tasklist_by_name(mode: str, name: str) -> dict:
    return _TASKLISTS[mode][name]

_TASKLISTS = {
    "validate_patch": {
        "validate_patch_v0": {
            "name": "validate_patch_v0",
            "mode": "validate_patch",
            "steps": [
                {
                    "id": "V1",
                    "name": "Normalize patch JSON",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.0},
                    "system_prompt": "You are a strict JSON normalizer. Output ONLY valid JSON. No commentary.",
                    "user_prompt_template": "PATCH_JSON_INPUT:\n{{state.inputs.existing_patch_json}}\n\nReturn valid JSON only.",
                    "expects": "json",
                    "output_key": "working.candidate_patch",
                    "validators": ["json_parse"],
                    "on_fail": "retry"
                },
                {
                    "id": "V2",
                    "name": "Enforce schema and output final patch JSON",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.0},
                    "system_prompt": "Output ONLY JSON that matches EXACT schema: {hunks:[{description,search_block,replace_block,use_patch_indent}]}. No extra keys. hunks non-empty. use_patch_indent boolean.",
                    "user_prompt_template": "CANDIDATE:\n{{state.working.candidate_patch}}\n\nReturn schema-valid patch JSON only.",
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict"],
                    "on_fail": "retry"
                }
            ]
        }
    },
    "repair_patch": {
        "repair_patch_v0": {
            "name": "repair_patch_v0",
            "mode": "repair_patch",
            "steps": [
                {
                    "id": "R1",
                    "name": "Rewrite hunks to match current file",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.2},
                    "system_prompt": (
                        "You are a patch surgeon for TokenizingPATCHER.\n"
                        "MUST output ONLY schema-valid patch JSON.\n"
                        "Rules:\n"
                        "- Every search_block MUST appear verbatim in TARGET_FILE.\n"
                        "- replace_block must be concrete (no placeholders).\n"
                        "- No extra keys."
                    ),
                    "user_prompt_template": (
                        "TARGET_FILE:\n{{state.inputs.target_file_text}}\n\n"
                        "FAILING_PATCH_JSON:\n{{state.inputs.existing_patch_json}}\n\n"
                        "ERROR_LOG:\n{{state.inputs.error_log_text}}\n\n"
                        "Produce corrected patch JSON."
                    ),
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict", "match_search_blocks"],
                    "on_fail": "retry"
                }
            ]
        }
    },
    "create_patch": {
        "create_patch_v0": {
            "name": "create_patch_v0",
            "mode": "create_patch",
            "steps": [
                {
                    "id": "C1",
                    "name": "Generate patch from snippet + file",
                    "enabled": True,
                    "model": "qwen2.5:7b-coder",
                    "ollama_options": {"temperature": 0.2},
                    "system_prompt": (
                        "Generate TokenizingPATCHER patch JSON.\n"
                        "Hard rules:\n"
                        "- Output ONLY schema-valid patch JSON.\n"
                        "- Every search_block MUST be verbatim substring from TARGET_FILE.\n"
                        "- replace_block must be concrete and placeholder-free.\n"
                        "- No extra keys."
                    ),
                    "user_prompt_template": (
                        "TARGET_FILE:\n{{state.inputs.target_file_text}}\n\n"
                        "CHANGE_SNIPPET:\n{{state.inputs.snippet_text}}\n\n"
                        "Create patch JSON."
                    ),
                    "expects": "patch_json",
                    "output_key": "outputs.final_patch",
                    "validators": ["schema_strict", "match_search_blocks"],
                    "on_fail": "retry"
                }
            ]
        }
    }
}

--------------------------------------------------------------------------------
FILE: _TasklistWORKER\src\_microservices\template_engine.py
--------------------------------------------------------------------------------
def resolve_template(template: str, state: dict) -> str:
    """
    Minimal {{state.path.to.key}} templating.
    Only supports read access, no function calls.
    """
    out = template

    # very small & safe on purpose
    # pattern scanning without regex to keep it obvious
    while True:
        start = out.find("{{")
        if start == -1:
            break
        end = out.find("}}", start)
        if end == -1:
            break
        expr = out[start+2:end].strip()

        val = ""
        if expr.startswith("state."):
            path = expr[len("state."):].split(".")
            cur = state
            ok = True
            for p in path:
                if isinstance(cur, dict) and p in cur:
                    cur = cur[p]
                else:
                    ok = False
                    break
            if ok:
                val = cur if isinstance(cur, str) else str(cur)

        out = out[:start] + val + out[end+2:]
    return out

--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
--------------------------------------------------------------------------------
I am refactoring a collection of legacy Python scripts into a unified "Systems Thinker" ecosystem managed by a central launcher. I need you to act as a Refactoring Engine.

Here is the Architecture Contract you must follow for this session:

1. THE GOAL:
Convert the raw code I provide into a standardized package structure compatible with a `scripts_menu.py` launcher that executes via `python -m src.app`.

2. THE TARGET STRUCTURE:
Project Root: C:\Users\foo_user_name\Documents\_foo_project_folder\_BoilerPlatePythonTEMPLATE <-- Sample location
Generated: YYYY-MM-DD HH:MM:SS
Global Default Folder Exclusions: .git, .idea, .mypy_cache, .venv, .vscode, Debug, Release, __pycache__, _logs, bin, build, dist, logs, node_modules, obj, out, target
Predefined Filename Exclusions: *.pyc, *.pyo, *.swo, *.swp, .DS_Store, Thumbs.db, package-lock.json, yarn.lock
Dynamic Filename Exclusions: None

[X] _BoilerPlatePythonTEMPLATE/ (Project Root)
  â”œâ”€â”€ [ ] _logs/
  â”œâ”€â”€ [X] assets/
  â”œâ”€â”€ [X] src/
  â”‚   â”œâ”€â”€ ðŸ“„ __init__.py <--Empty
  â”‚   â””â”€â”€ ðŸ“„ app.py  <--The Hybrid Entry Point
  â”œâ”€â”€ ðŸ“„ AI_AGENT_BOILERPLATE_INSTRUCTIONS.md
  â”œâ”€â”€ ðŸ“„ LICENSE.md
  â”œâ”€â”€ ðŸ“„ README.md
  â”œâ”€â”€ ðŸ“„ requirements.txt
  â””â”€â”€ ðŸ“„ setup_env.bat


3. THE CODE PATTERN (Hybrid Entry Point):
The `src/app.py` must use the following pattern to support both CLI utility and a GUI Showcase mode:

    import sys
    import argparse
    import tkinter as tk

    # --- CORE LOGIC (Importable) ---
    def core_logic(...):
        pass

    # --- GUI MODE (Default / Showcase) ---
    def run_gui():
        # A simple Tkinter window to demonstrate the tool works
        # Must not crash if launched with no args
        pass

    # --- CLI MODE (Utility) ---
    def run_cli():
        # Uses argparse
        # Only runs if sys.argv has arguments
        pass

    def main():
        if len(sys.argv) > 1:
            run_cli()
        else:
            run_gui()

    if __name__ == "__main__":
        main()

4. OUTPUT PROTOCOL (CRITICAL):
You must choose the correct output format based on the complexity of the change.

A. FOR INITIAL REFACTOR / LARGE CHANGES / CONFUSION:
   - Always provide the **FULL GENERATED FILE** content.
   - If a surgical patch failed or risks mangling the file, fallback to a full file dump immediately.

B. FOR SURGICAL PATCHES (Small Logic Tweaks):
   - If the file exists and the change is small/isolated, use the following JSON schema:
   ```json
   {
     "hunks": [
       {
         "description": "Short human description",
         "search_block": "exact text to find\n(can span multiple lines)",
         "replace_block": "replacement text\n(same or different length)",
         "use_patch_indent": false
       }
     ]
   }

NOTE:
Do not remove core functionality, but wrap it cleanly. Only remove functionality if actively altering the app with the user after integrating into the boilerplate.

Are you ready for the source code?
--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\requirements.txt
--------------------------------------------------------------------------------
tk>=0.1.0
--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\src\app.py
--------------------------------------------------------------------------------
import sys
import argparse
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import os
import json
import re
import datetime
import difflib
from dataclasses import dataclass, field

# ==============================================================================
# INTERNAL UI HELPERS (Dependency Replacement)
# ==============================================================================

@dataclass
class ButtonConfig:
    text: str
    command: callable
    bg_color: str
    active_bg_color: str
    fg_color: str = "#FFFFFF"

@dataclass
class LinkConfig:
    """Configuration for the 'Linked' state (The Trap)"""
    trap_bg: str = "#7C3AED"    # Deep Purple
    btn_bg: str = "#8B5CF6"     # Lighter Purple
    text_color: str = "#FFFFFF"

class LocalUnifiedButtonGroup(tk.Frame):
    """
    The robust 'UnifiedButtonGroup' that supports linking actions (The Trap).
    """
    def __init__(self, parent, left_btn: ButtonConfig, right_btn: ButtonConfig, link_config: LinkConfig = None, **kwargs):
        super().__init__(parent, **kwargs)
        
        self.left_cfg = left_btn
        self.right_cfg = right_btn
        self.link_cfg = link_config or LinkConfig()
        
        self.is_linked = False
        # Try to grab parent bg, default to dark theme if failing
        try: 
            self.default_bg = parent.cget("bg")
        except: 
            self.default_bg = "#0f172a"

        self._setup_ui()
        self._update_state()

    def _setup_ui(self):
        self.config(padx=4, pady=4)
        
        # Base style for buttons
        common_style = {"relief": "flat", "font": ("Segoe UI", 9, "bold"), "bd": 0, "cursor": "hand2", "padx": 15, "pady": 5}
        link_style = {"relief": "flat", "font": ("Segoe UI", 10, "bold"), "bd": 0, "cursor": "hand2"}

        # 1. Left Button
        self.btn_left = tk.Button(self, command=lambda: self._execute("left"), **common_style)
        self.btn_left.pack(side="left", fill="y", padx=(0, 2))

        # 2. Link Toggle (The Chain)
        self.btn_link = tk.Button(self, text="&", width=3, command=self._toggle_link, **link_style)
        self.btn_link.pack(side="left", fill="y", padx=(0, 2))

        # 3. Right Button
        self.btn_right = tk.Button(self, command=lambda: self._execute("right"), **common_style)
        self.btn_right.pack(side="left", fill="y")

    def _toggle_link(self):
        self.is_linked = not self.is_linked
        self._update_state()

    def _update_state(self):
        if self.is_linked:
            # --- LINKED STATE (The Trap) ---
            self.config(bg=self.link_cfg.trap_bg)
            
            # Both buttons look identical in the "Trap"
            for btn in (self.btn_left, self.btn_right, self.btn_link):
                btn.config(bg=self.link_cfg.btn_bg, fg=self.link_cfg.text_color, activebackground=self.link_cfg.trap_bg)
            
            # Keep original text
            self.btn_left.config(text=self.left_cfg.text)
            self.btn_right.config(text=self.right_cfg.text)

        else:
            # --- INDEPENDENT STATE ---
            self.config(bg=self.default_bg)

            # Restore Left Button
            self.btn_left.config(
                text=self.left_cfg.text, 
                bg=self.left_cfg.bg_color, 
                fg=self.left_cfg.fg_color,
                activebackground=self.left_cfg.active_bg_color
            )

            # Restore Right Button
            self.btn_right.config(
                text=self.right_cfg.text, 
                bg=self.right_cfg.bg_color, 
                fg=self.left_cfg.fg_color,
                activebackground=self.right_cfg.active_bg_color
            )

            # Restore Link Button (Neutral Gray/Dark)
            self.btn_link.config(bg="#334155", fg="#94a3b8", activebackground="#475569")

    def _execute(self, source):
        if self.is_linked:
            # Chain them: Left then Right
            self.left_cfg.command()
            self.right_cfg.command()
        else:
            if source == "left": self.left_cfg.command()
            elif source == "right": self.right_cfg.command()

# ==============================================================================
# CORE LOGIC (Headless/Shared)
# ==============================================================================

class PatchError(Exception):
    pass

class StructuredLine:
    """Represents a single line split into indent + content + trailing whitespace."""
    __slots__ = ["indent", "content", "trailing", "original"]

    def __init__(self, line: str):
        self.original = line
        # Capture leading whitespace, core content, and trailing whitespace
        m = re.match(r"(^[ \t]*)(.*?)([ \t]*$)", line, re.DOTALL)
        if m:
            self.indent, self.content, self.trailing = m.group(1), m.group(2), m.group(3)
        else:
            self.indent, self.content, self.trailing = "", line, ""

    def reconstruct(self) -> str:
        return f"{self.indent}{self.content}{self.trailing}"

def tokenize_text(text: str):
    """Tokenize the raw file into StructuredLine objects and detect newline style."""
    if "\r\n" in text:
        newline = "\r\n"
    elif "\n" in text:
        newline = "\n"
    else:
        newline = "\n"

    raw_lines = text.splitlines()
    lines = [StructuredLine(l) for l in raw_lines]
    return lines, newline

def locate_hunk(file_lines, search_lines, floating=False):
    """Locate the hunk's search_lines inside file_lines."""
    if not search_lines:
        return []

    matches = []
    max_start = len(file_lines) - len(search_lines)
    for start in range(max_start + 1):
        ok = True
        for i, s in enumerate(search_lines):
            f = file_lines[start + i]
            if floating:
                # Compare logical content only
                if f.content != s.content:
                    ok = False
                    break
            else:
                # Compare fully reconstructed lines
                if f.reconstruct() != s.reconstruct():
                    ok = False
                    break
        if ok:
            matches.append(start)

    return matches

def apply_patch_text(original_text: str, patch_obj: dict, global_force_indent: bool = False) -> str:
    """Apply a patch schema instance to original_text and return the new text."""
    if not isinstance(patch_obj, dict) or "hunks" not in patch_obj:
        raise PatchError("Patch must be a dict with a 'hunks' list.")

    hunks = patch_obj.get("hunks", [])
    if not isinstance(hunks, list):
        raise PatchError("'hunks' must be a list.")

    file_lines, newline = tokenize_text(original_text)

    # First pass: compute all applications (start/end/replacements)
    applications = []
    for idx, hunk in enumerate(hunks, start=1):
        search_block = hunk.get("search_block")
        replace_block = hunk.get("replace_block")
        use_patch_indent = hunk.get("use_patch_indent", global_force_indent)

        if search_block is None or replace_block is None:
            raise PatchError(f"Hunk {idx}: Missing 'search_block' or 'replace_block'.")

        s_lines = [StructuredLine(l) for l in search_block.splitlines()]
        r_lines = [StructuredLine(l) for l in replace_block.splitlines()]

        # 1. Strict match
        matches = locate_hunk(file_lines, s_lines, floating=False)
        # 2. Fallback: content-only match
        if not matches:
            matches = locate_hunk(file_lines, s_lines, floating=True)

        if not matches:
            raise PatchError(f"Hunk {idx}: Search block not found.")
        if len(matches) > 1:
            raise PatchError(f"Hunk {idx}: Ambiguous match ({len(matches)} found).")

        start = matches[0]
        applications.append(
            {
                "start": start,
                "end": start + len(s_lines),
                "replace_lines": r_lines,
                "use_patch_indent": bool(use_patch_indent),
                "id": idx,
            }
        )

    # Collision check: ensure no overlapping edit ranges
    applications.sort(key=lambda a: a["start"])
    for i in range(len(applications) - 1):
        if applications[i]["end"] > applications[i + 1]["start"]:
            raise PatchError(
                f"Hunks {applications[i]['id']} and {applications[i+1]['id']} overlap in the target file."
            )

    # Apply from bottom up
    for app in reversed(applications):
        start = app["start"]
        end = app["end"]
        r_lines = app["replace_lines"]
        use_patch_indent = app["use_patch_indent"]

        base_indent = ""
        # Get the indentation of the anchor point in the FILE
        if 0 <= start < len(file_lines):
            base_indent = file_lines[start].indent

        # Get the indentation of the anchor point in the PATCH (First non-empty line)
        patch_base_indent = ""
        for rl in r_lines:
            if rl.content.strip():
                patch_base_indent = rl.indent
                break

        final_block = []
        for rl in r_lines:
            # If we are strictly using patch indent, do nothing.
            # Otherwise, calculate relative indentation.
            if not use_patch_indent:
                if rl.content.strip():
                    # 1. Remove the patch's baseline indent from this line
                    #    (Careful: this assumes rl.indent starts with patch_base_indent)
                    if rl.indent.startswith(patch_base_indent):
                        relative_indent = rl.indent[len(patch_base_indent):]
                    else:
                        # Fallback: if patch is weirdly dedented, keep original
                        relative_indent = rl.indent
                    
                    # 2. Add the file's base indent + the relative indent
                    rl.indent = base_indent + relative_indent
                
                # OPTIONAL: Handle empty lines (copy base indent or leave empty?)
                # Usually leaving them empty (just \n) is safer for git/linting.

            final_block.append(rl)

        file_lines[start:end] = final_block

    return newline.join([l.reconstruct() for l in file_lines])


# ==============================================================================
# GUI MODE (Default / Showcase)
# ==============================================================================

class App:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("_TokenizingPATCHER v4.3 [System Ecosystem]")
        self.root.geometry("1100x850")
        self.root.configure(bg="#0f172a")

        self.loaded_filepath = None

        # State variables
        self.version_enabled_var = tk.BooleanVar(value=False)
        self.version_suffix_var = tk.StringVar(value="_v1.0")
        self.force_indent_var = tk.BooleanVar(value=False)
        self.is_blinking = False

        # Validation / diff preview state
        self.validation_preview_text = None
        self.validation_valid = False
        self.diff_view_var = tk.BooleanVar(value=False)

        self.setup_styles()
        self.build_ui()

    def setup_styles(self):
        style = ttk.Style()
        style.theme_use("clam")
        style.configure(
            "TButton",
            padding=6,
            relief="flat",
            background="#334155",
            foreground="white",
        )
        style.map("TButton", background=[("active", "#475569")])

        self.colors = {
            "bg": "#0f172a",
            "panel_bg": "#1e293b",
            "text": "#e2e8f0",
            "accent": "#6366f1",
            "success": "#22c55e",
            "error": "#ef4444",
            "working": "#facc15",
            "log_bg": "#020617",
            "log_fg": "#94a3b8",
        }

    def build_ui(self):
        # --- Top Toolbar ---
        toolbar = tk.Frame(self.root, bg=self.colors["bg"])
        toolbar.pack(fill="x", padx=15, pady=10)

        # File operations
        tk.Button(
            toolbar,
            text="ðŸ“‚ Load File",
            command=self.load_file,
            bg="#334155",
            fg="white",
            relief="flat",
        ).pack(side="left", padx=(0, 5))

        tk.Button(
            toolbar,
            text="ðŸ’¾ Save Result",
            command=self.save_file,
            bg="#334155",
            fg="white",
            relief="flat",
        ).pack(side="left", padx=5)

        # Versioning controls
        v_frame = tk.Frame(toolbar, bg=self.colors["bg"])
        v_frame.pack(side="left", padx=15)

        chk_ver = tk.Checkbutton(
            v_frame,
            text="Version",
            variable=self.version_enabled_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
        )
        chk_ver.pack(side="left")

        tk.Label(
            v_frame,
            text="Suffix:",
            bg=self.colors["bg"],
            fg="#64748b",
        ).pack(side="left", padx=(10, 5))

        tk.Entry(
            v_frame,
            textvariable=self.version_suffix_var,
            width=10,
        ).pack(side="left")

        # --- Main Paned Layout ---
        paned = tk.PanedWindow(
            self.root,
            orient="horizontal",
            sashrelief="raised",
            bg=self.colors["bg"],
        )
        paned.pack(fill="both", expand=True, padx=15, pady=5)

        # LEFT PANE
        left_frame = tk.Frame(paned, bg=self.colors["panel_bg"])
        l_hdr = tk.Frame(left_frame, bg=self.colors["panel_bg"])
        l_hdr.pack(fill="x", padx=5, pady=5)

        self.lbl_left_title = tk.Label(
            l_hdr,
            text="TARGET SOURCE CODE",
            fg="#94a3b8",
            bg=self.colors["panel_bg"],
            font=("Segoe UI", 8, "bold"),
        )
        self.lbl_left_title.pack(side="left")

        self.txt_file = scrolledtext.ScrolledText(
            left_frame,
            bg=self.colors["panel_bg"],
            fg=self.colors["text"],
            insertbackground="white",
            borderwidth=0,
        )
        self.txt_file.pack(fill="both", expand=True)

        paned.add(left_frame)

        # RIGHT PANE
        right_frame = tk.Frame(paned, bg=self.colors["panel_bg"])
        r_hdr = tk.Frame(right_frame, bg=self.colors["panel_bg"])
        r_hdr.pack(fill="x", padx=5, pady=5)

        self.lbl_patch_title = tk.Label(
            r_hdr,
            text="Patch: UNVALIDATED",
            fg="#94a3b8",
            bg=self.colors["panel_bg"],
            font=("Segoe UI", 8, "bold"),
        )
        self.lbl_patch_title.pack(side="left")

        tk.Button(
            r_hdr,
            text="ðŸ“‹ Schema",
            command=self.copy_schema_to_clipboard,
            bg="#334155",
            fg="white",
            font=("Segoe UI", 8),
            relief="flat",
        ).pack(side="right", padx=5)

        self.txt_patch = scrolledtext.ScrolledText(
            right_frame,
            bg="#020617",
            fg="#cbd5e1",
            insertbackground="white",
            borderwidth=0,
        )
        self.txt_patch.pack(fill="both", expand=True)
        self.txt_patch.insert("1.0", self.get_schema_template())

        paned.add(right_frame)

        # --- Action Footer ---
        footer = tk.Frame(self.root, bg=self.colors["bg"])
        footer.pack(fill="x", padx=15, pady=10)

        chk_indent = tk.Checkbutton(
            footer,
            text="Force Patch Indentation (Strict Whitespace)",
            variable=self.force_indent_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
        )
        chk_indent.pack(side="left")

        chk_diff = tk.Checkbutton(
            footer,
            text="Show Diff Preview",
            variable=self.diff_view_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
            command=self.on_diff_toggle,
        )
        chk_diff.pack(side="left", padx=(10, 0))

        # Unified Validate / Apply group
        btn_val_config = ButtonConfig(
            text="Validate",
            command=self.validate_patch,
            bg_color="#10B981",  # Emerald Green
            active_bg_color="#059669"
        )

        btn_apply_config = ButtonConfig(
            text="Apply",
            command=self.apply_patch,
            bg_color="#2563EB",  # Royal Blue
            active_bg_color="#1D4ED8"
        )

        # Using the Local replacement here
        self.button_group = LocalUnifiedButtonGroup(
            parent=footer,
            left_btn=btn_val_config,
            right_btn=btn_apply_config
        )
        self.button_group.pack(side="right")

        # --- Log Window ---
        self.debug_out = scrolledtext.ScrolledText(
            self.root,
            height=6,
            bg=self.colors["log_bg"],
            fg=self.colors["log_fg"],
            insertbackground="white",
            borderwidth=0,
            font=("Consolas", 9),
        )
        self.debug_out.pack(fill="x", padx=15, pady=(0, 5))

        # --- Status Bar (Blinking) ---
        self.status_bar = tk.Label(
            self.root,
            text="Ready",
            bg=self.colors["bg"],
            fg=self.colors["success"],
            font=("Consolas", 10),
            anchor="w",
            padx=15,            pady=5,
        )
        self.status_bar.pack(fill="x", side="bottom")

    # --- Status / Blink Helpers ---

    def set_status(self, msg, state="info"):
        colors = {
            "info": self.colors["success"],
            "error": self.colors["error"],
            "working": self.colors["working"],
        }
        color = colors.get(state, self.colors["success"])

        # 1. Status label text
        self.status_bar.config(text=msg, fg=color)
        if state == "working":
            self.start_blink()
        else:
            self.stop_blink()

        # 2. Log window
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        prefix = "ERROR: " if state == "error" else ""
        log_entry = f"[{timestamp}] {prefix}{msg}\n"
        self.debug_out.insert(tk.END, log_entry)
        self.debug_out.see(tk.END)

    def start_blink(self):
        self.is_blinking = True
        self._blink_loop()

    def stop_blink(self):
        self.is_blinking = False
        # Reset to working color when stopping from blink
        try:
            self.status_bar.config(fg=self.colors["success"])
        except Exception:
            pass

    def _blink_loop(self):
        if not self.is_blinking:
            return
        current_fg = self.status_bar.cget("foreground")
        next_fg = self.colors["bg"] if current_fg == self.colors["working"] else self.colors["working"]
        self.status_bar.config(fg=next_fg)
        self.root.after(600, self._blink_loop)

    # --- File Logic & Diff Preview ---

    def load_file(self):
        path = filedialog.askopenfilename()
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", content)
            self.loaded_filepath = path

            # Reset panel titles
            self.lbl_left_title.config(text="TARGET SOURCE CODE")
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")

            # Reset validation / diff state
            self.validation_preview_text = None
            self.validation_valid = False
            self.diff_view_var.set(False)

            self.set_status(f"Loaded: {path}", "info")
        except Exception as e:
            self.set_status(f"Error loading file: {e}", "error")

    def save_file(self):
        orig = self.loaded_filepath
        if orig and self.version_enabled_var.get():
            d, f = os.path.split(orig)
            base, ext = os.path.splitext(f)
            suffix = self.version_suffix_var.get()
            if suffix and not suffix.startswith("_"):
                suffix = "_" + suffix
            filename = f"{base}{suffix}{ext}"
            path = os.path.join(d, filename)
        elif orig:
            path = orig
        else:
            path = filedialog.asksaveasfilename(defaultextension=".txt")

        if not path:
            return

        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(self.txt_file.get("1.0", tk.END))
            self.set_status(f"Saved to: {os.path.basename(path)}", "info")
        except Exception as e:
            self.set_status(f"Save failed: {e}", "error")

    def get_schema_template(self):
        return (
            "{\n"
            "  \"hunks\": [\n"
            "    {\n"
            "      \"description\": \"Short human description\",\n"
            "      \"search_block\": \"exact text to find\\n(can span multiple lines)\",\n"
            "      \"replace_block\": \"replacement text\\n(same or different length)\",\n"
            "      \"use_patch_indent\": false\n"
            "    }\n"
            "  ]\n"
            "}\n"
        )

    def copy_schema_to_clipboard(self):
        self.root.clipboard_clear()
        self.root.clipboard_append(self.get_schema_template())
        self.set_status("Schema copied to clipboard.", "info")

    def _show_diff_view(self, original_text: str, preview_text: str):
        orig_lines = original_text.splitlines()
        new_lines = preview_text.splitlines()
        diff_lines = difflib.unified_diff(
            orig_lines,
            new_lines,
            fromfile="original",
            tofile="preview",
            lineterm="",
        )
        diff_text = "\n".join(diff_lines) or "(No differences)\n"
        self.txt_file.delete("1.0", tk.END)
        self.txt_file.insert("1.0", diff_text)

    def on_diff_toggle(self):
        # Only meaningful if we have a valid preview
        if not self.validation_valid or not self.validation_preview_text:
            return

        current_source = self.txt_file.get("1.0", tk.END)
        # If diff is being turned on, show diff between current source and preview
        if self.diff_view_var.get():
            self._show_diff_view(current_source, self.validation_preview_text)
        else:
            # Restore plain source view (just show current source as-is)
            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", current_source)

    # --- Validate / Apply ---

    def validate_patch(self):
        original_text = self.txt_file.get("1.0", tk.END)
        patch_text = self.txt_patch.get("1.0", tk.END)
        force = self.force_indent_var.get()

        try:
            patch_obj = json.loads(patch_text)
            preview_text = apply_patch_text(
                original_text,
                patch_obj,
                global_force_indent=force,
            )

            self.validation_preview_text = preview_text
            self.validation_valid = True

            self.lbl_patch_title.config(text="Patch: VALIDATED (DRY RUN)")
            self.set_status("Validation succeeded (dry run).", "info")

            if self.diff_view_var.get():
                self._show_diff_view(original_text, preview_text)
            else:
                # Ensure left panel shows the original text
                self.txt_file.delete("1.0", tk.END)
                self.txt_file.insert("1.0", original_text)

        except json.JSONDecodeError:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status("Error: Invalid JSON. Check formatting.", "error")

        except PatchError as e:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"Patch Error during validation: {e}", "error")

        except Exception as e:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(
                f"System Error during validation: {e}",
                "error",
            )

    def apply_patch(self):
        target_text = self.txt_file.get("1.0", tk.END)
        patch_text = self.txt_patch.get("1.0", tk.END)
        force = self.force_indent_var.get()

        try:
            if self.validation_valid and self.validation_preview_text:
                new_text = self.validation_preview_text
            else:
                patch_obj = json.loads(patch_text)
                new_text = apply_patch_text(
                    target_text,
                    patch_obj,
                    global_force_indent=force,
                )

            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", new_text)

            # Clear validation/diff state after commit
            self.validation_preview_text = None
            self.validation_valid = False
            self.diff_view_var.set(False)

            self.lbl_left_title.config(text="PATCHED SOURCE CODE")
            self.lbl_patch_title.config(text="Patch: VALIDATED & APPLIED")
            self.set_status("Success: Patch Applied.", "info")

        except json.JSONDecodeError:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status("Error: Invalid JSON.", "error")

        except PatchError as e:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"Patch Error: {e}", "error")

        except Exception as e:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"System Error: {e}", "error")

    def start(self):
        self.root.mainloop()

def run_gui():
    print("Launching GUI Mode...")
    app = App()
    app.start()

# ==============================================================================
# CLI MODE (Utility)
# ==============================================================================

def run_cli():
    """
    Command Line Interface Entry Point.
    """
    parser = argparse.ArgumentParser(description="_TokenizingPATCHER CLI")
    parser.add_argument("target", help="Path to the target source file")
    parser.add_argument("patch", help="Path to the JSON patch file")
    parser.add_argument("--output", "-o", help="Path to save the result (defaults to print stdout)")
    parser.add_argument("--force-indent", action="store_true", help="Force patch indentation")
    parser.add_argument("--dry-run", action="store_true", help="Validate only, do not write")
    
    args = parser.parse_args()
    
    # 1. Read Target
    try:
        with open(args.target, "r", encoding="utf-8") as f:
            target_text = f.read()
    except FileNotFoundError:
        print(f"Error: Target file not found: {args.target}")
        sys.exit(1)

    # 2. Read Patch
    try:
        with open(args.patch, "r", encoding="utf-8") as f:
            patch_obj = json.load(f)
    except FileNotFoundError:
        print(f"Error: Patch file not found: {args.patch}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Patch file is not valid JSON.")
        sys.exit(1)

    # 3. Apply
    try:
        new_text = apply_patch_text(target_text, patch_obj, global_force_indent=args.force_indent)
        
        if args.dry_run:
            print("Dry Run Successful. Patch applies cleanly.")
        else:
            if args.output:
                with open(args.output, "w", encoding="utf-8") as f:
                    f.write(new_text)
                print(f"Success: Patched file written to {args.output}")
            else:
                print(new_text)
                
    except PatchError as e:
        print(f"Patch Failed: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected Error: {e}")
        sys.exit(1)

# ==============================================================================
# HYBRID ENTRY POINT
# ==============================================================================

def main():
    if len(sys.argv) > 1:
        run_cli()
    else:
        run_gui()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\src\_TokenizingPATCHER_app.py
--------------------------------------------------------------------------------
import sys
import argparse
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import os
import json
import re
import datetime
import difflib
from dataclasses import dataclass, field

# ==============================================================================
# INTERNAL UI HELPERS (Dependency Replacement)
# ==============================================================================

@dataclass
class ButtonConfig:
    text: str
    command: callable
    bg_color: str
    active_bg_color: str
    fg_color: str = "#FFFFFF"

@dataclass
class LinkConfig:
    """Configuration for the 'Linked' state (The Trap)"""
    trap_bg: str = "#7C3AED"    # Deep Purple
    btn_bg: str = "#8B5CF6"     # Lighter Purple
    text_color: str = "#FFFFFF"

class LocalUnifiedButtonGroup(tk.Frame):
    """
    The robust 'UnifiedButtonGroup' that supports linking actions (The Trap).
    """
    def __init__(self, parent, left_btn: ButtonConfig, right_btn: ButtonConfig, link_config: LinkConfig = None, **kwargs):
        super().__init__(parent, **kwargs)
        
        self.left_cfg = left_btn
        self.right_cfg = right_btn
        self.link_cfg = link_config or LinkConfig()
        
        self.is_linked = False
        # Try to grab parent bg, default to dark theme if failing
        try: 
            self.default_bg = parent.cget("bg")
        except: 
            self.default_bg = "#0f172a"

        self._setup_ui()
        self._update_state()

    def _setup_ui(self):
        self.config(padx=4, pady=4)
        
        # Base style for buttons
        common_style = {"relief": "flat", "font": ("Segoe UI", 9, "bold"), "bd": 0, "cursor": "hand2", "padx": 15, "pady": 5}
        link_style = {"relief": "flat", "font": ("Segoe UI", 10, "bold"), "bd": 0, "cursor": "hand2"}

        # 1. Left Button
        self.btn_left = tk.Button(self, command=lambda: self._execute("left"), **common_style)
        self.btn_left.pack(side="left", fill="y", padx=(0, 2))

        # 2. Link Toggle (The Chain)
        self.btn_link = tk.Button(self, text="&", width=3, command=self._toggle_link, **link_style)
        self.btn_link.pack(side="left", fill="y", padx=(0, 2))

        # 3. Right Button
        self.btn_right = tk.Button(self, command=lambda: self._execute("right"), **common_style)
        self.btn_right.pack(side="left", fill="y")

    def _toggle_link(self):
        self.is_linked = not self.is_linked
        self._update_state()

    def _update_state(self):
        if self.is_linked:
            # --- LINKED STATE (The Trap) ---
            self.config(bg=self.link_cfg.trap_bg)
            
            # Both buttons look identical in the "Trap"
            for btn in (self.btn_left, self.btn_right, self.btn_link):
                btn.config(bg=self.link_cfg.btn_bg, fg=self.link_cfg.text_color, activebackground=self.link_cfg.trap_bg)
            
            # Keep original text
            self.btn_left.config(text=self.left_cfg.text)
            self.btn_right.config(text=self.right_cfg.text)

        else:
            # --- INDEPENDENT STATE ---
            self.config(bg=self.default_bg)

            # Restore Left Button
            self.btn_left.config(
                text=self.left_cfg.text, 
                bg=self.left_cfg.bg_color, 
                fg=self.left_cfg.fg_color,
                activebackground=self.left_cfg.active_bg_color
            )

            # Restore Right Button
            self.btn_right.config(
                text=self.right_cfg.text, 
                bg=self.right_cfg.bg_color, 
                fg=self.left_cfg.fg_color,
                activebackground=self.right_cfg.active_bg_color
            )

            # Restore Link Button (Neutral Gray/Dark)
            self.btn_link.config(bg="#334155", fg="#94a3b8", activebackground="#475569")

    def _execute(self, source):
        if self.is_linked:
            # Chain them: Left then Right
            self.left_cfg.command()
            self.right_cfg.command()
        else:
            if source == "left": self.left_cfg.command()
            elif source == "right": self.right_cfg.command()

# ==============================================================================
# CORE LOGIC (Headless/Shared)
# ==============================================================================

class PatchError(Exception):
    pass

class StructuredLine:
    """Represents a single line split into indent + content + trailing whitespace."""
    __slots__ = ["indent", "content", "trailing", "original"]

    def __init__(self, line: str):
        self.original = line
        # Capture leading whitespace, core content, and trailing whitespace
        m = re.match(r"(^[ \t]*)(.*?)([ \t]*$)", line, re.DOTALL)
        if m:
            self.indent, self.content, self.trailing = m.group(1), m.group(2), m.group(3)
        else:
            self.indent, self.content, self.trailing = "", line, ""

    def reconstruct(self) -> str:
        return f"{self.indent}{self.content}{self.trailing}"

def tokenize_text(text: str):
    """Tokenize the raw file into StructuredLine objects and detect newline style."""
    if "\r\n" in text:
        newline = "\r\n"
    elif "\n" in text:
        newline = "\n"
    else:
        newline = "\n"

    raw_lines = text.splitlines()
    lines = [StructuredLine(l) for l in raw_lines]
    return lines, newline

def locate_hunk(file_lines, search_lines, floating=False):
    """Locate the hunk's search_lines inside file_lines."""
    if not search_lines:
        return []

    matches = []
    max_start = len(file_lines) - len(search_lines)
    for start in range(max_start + 1):
        ok = True
        for i, s in enumerate(search_lines):
            f = file_lines[start + i]
            if floating:
                # Compare logical content only
                if f.content != s.content:
                    ok = False
                    break
            else:
                # Compare fully reconstructed lines
                if f.reconstruct() != s.reconstruct():
                    ok = False
                    break
        if ok:
            matches.append(start)

    return matches

def apply_patch_text(original_text: str, patch_obj: dict, global_force_indent: bool = False) -> str:
    """Apply a patch schema instance to original_text and return the new text."""
    if not isinstance(patch_obj, dict) or "hunks" not in patch_obj:
        raise PatchError("Patch must be a dict with a 'hunks' list.")

    hunks = patch_obj.get("hunks", [])
    if not isinstance(hunks, list):
        raise PatchError("'hunks' must be a list.")

    file_lines, newline = tokenize_text(original_text)

    # First pass: compute all applications (start/end/replacements)
    applications = []
    for idx, hunk in enumerate(hunks, start=1):
        search_block = hunk.get("search_block")
        replace_block = hunk.get("replace_block")
        use_patch_indent = hunk.get("use_patch_indent", global_force_indent)

        if search_block is None or replace_block is None:
            raise PatchError(f"Hunk {idx}: Missing 'search_block' or 'replace_block'.")

        s_lines = [StructuredLine(l) for l in search_block.splitlines()]
        r_lines = [StructuredLine(l) for l in replace_block.splitlines()]

        # 1. Strict match
        matches = locate_hunk(file_lines, s_lines, floating=False)
        # 2. Fallback: content-only match
        if not matches:
            matches = locate_hunk(file_lines, s_lines, floating=True)

        if not matches:
            raise PatchError(f"Hunk {idx}: Search block not found.")
        if len(matches) > 1:
            raise PatchError(f"Hunk {idx}: Ambiguous match ({len(matches)} found).")

        start = matches[0]
        applications.append(
            {
                "start": start,
                "end": start + len(s_lines),
                "replace_lines": r_lines,
                "use_patch_indent": bool(use_patch_indent),
                "id": idx,
            }
        )

    # Collision check: ensure no overlapping edit ranges
    applications.sort(key=lambda a: a["start"])
    for i in range(len(applications) - 1):
        if applications[i]["end"] > applications[i + 1]["start"]:
            raise PatchError(
                f"Hunks {applications[i]['id']} and {applications[i+1]['id']} overlap in the target file."
            )

    # Apply from bottom up
    for app in reversed(applications):
        start = app["start"]
        end = app["end"]
        r_lines = app["replace_lines"]
        use_patch_indent = app["use_patch_indent"]

        base_indent = ""
        # Get the indentation of the anchor point in the FILE
        if 0 <= start < len(file_lines):
            base_indent = file_lines[start].indent

        # Get the indentation of the anchor point in the PATCH (First non-empty line)
        patch_base_indent = ""
        for rl in r_lines:
            if rl.content.strip():
                patch_base_indent = rl.indent
                break

        final_block = []
        for rl in r_lines:
            # If we are strictly using patch indent, do nothing.
            # Otherwise, calculate relative indentation.
            if not use_patch_indent:
                if rl.content.strip():
                    # 1. Remove the patch's baseline indent from this line
                    #    (Careful: this assumes rl.indent starts with patch_base_indent)
                    if rl.indent.startswith(patch_base_indent):
                        relative_indent = rl.indent[len(patch_base_indent):]
                    else:
                        # Fallback: if patch is weirdly dedented, keep original
                        relative_indent = rl.indent
                    
                    # 2. Add the file's base indent + the relative indent
                    rl.indent = base_indent + relative_indent
                
                # OPTIONAL: Handle empty lines (copy base indent or leave empty?)
                # Usually leaving them empty (just \n) is safer for git/linting.

            final_block.append(rl)

        file_lines[start:end] = final_block

    return newline.join([l.reconstruct() for l in file_lines])


# ==============================================================================
# GUI MODE (Default / Showcase)
# ==============================================================================

class App:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("_TokenizingPATCHER v4.3 [System Ecosystem]")
        self.root.geometry("1100x850")
        self.root.configure(bg="#0f172a")

        self.loaded_filepath = None

        # State variables
        self.version_enabled_var = tk.BooleanVar(value=False)
        self.version_suffix_var = tk.StringVar(value="_v1.0")
        self.force_indent_var = tk.BooleanVar(value=False)
        self.is_blinking = False

        # Validation / diff preview state
        self.validation_preview_text = None
        self.validation_valid = False
        self.diff_view_var = tk.BooleanVar(value=False)

        self.setup_styles()
        self.build_ui()

    def setup_styles(self):
        style = ttk.Style()
        style.theme_use("clam")
        style.configure(
            "TButton",
            padding=6,
            relief="flat",
            background="#334155",
            foreground="white",
        )
        style.map("TButton", background=[("active", "#475569")])

        self.colors = {
            "bg": "#0f172a",
            "panel_bg": "#1e293b",
            "text": "#e2e8f0",
            "accent": "#6366f1",
            "success": "#22c55e",
            "error": "#ef4444",
            "working": "#facc15",
            "log_bg": "#020617",
            "log_fg": "#94a3b8",
        }

    def build_ui(self):
        # --- Top Toolbar ---
        toolbar = tk.Frame(self.root, bg=self.colors["bg"])
        toolbar.pack(fill="x", padx=15, pady=10)

        # File operations
        tk.Button(
            toolbar,
            text="ðŸ“‚ Load File",
            command=self.load_file,
            bg="#334155",
            fg="white",
            relief="flat",
        ).pack(side="left", padx=(0, 5))

        tk.Button(
            toolbar,
            text="ðŸ’¾ Save Result",
            command=self.save_file,
            bg="#334155",
            fg="white",
            relief="flat",
        ).pack(side="left", padx=5)

        # Versioning controls
        v_frame = tk.Frame(toolbar, bg=self.colors["bg"])
        v_frame.pack(side="left", padx=15)

        chk_ver = tk.Checkbutton(
            v_frame,
            text="Version",
            variable=self.version_enabled_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
        )
        chk_ver.pack(side="left")

        tk.Label(
            v_frame,
            text="Suffix:",
            bg=self.colors["bg"],
            fg="#64748b",
        ).pack(side="left", padx=(10, 5))

        tk.Entry(
            v_frame,
            textvariable=self.version_suffix_var,
            width=10,
        ).pack(side="left")

        # --- Main Paned Layout ---
        paned = tk.PanedWindow(
            self.root,
            orient="horizontal",
            sashrelief="raised",
            bg=self.colors["bg"],
        )
        paned.pack(fill="both", expand=True, padx=15, pady=5)

        # LEFT PANE
        left_frame = tk.Frame(paned, bg=self.colors["panel_bg"])
        l_hdr = tk.Frame(left_frame, bg=self.colors["panel_bg"])
        l_hdr.pack(fill="x", padx=5, pady=5)

        self.lbl_left_title = tk.Label(
            l_hdr,
            text="TARGET SOURCE CODE",
            fg="#94a3b8",
            bg=self.colors["panel_bg"],
            font=("Segoe UI", 8, "bold"),
        )
        self.lbl_left_title.pack(side="left")

        self.txt_file = scrolledtext.ScrolledText(
            left_frame,
            bg=self.colors["panel_bg"],
            fg=self.colors["text"],
            insertbackground="white",
            borderwidth=0,
        )
        self.txt_file.pack(fill="both", expand=True)

        paned.add(left_frame)

        # RIGHT PANE
        right_frame = tk.Frame(paned, bg=self.colors["panel_bg"])
        r_hdr = tk.Frame(right_frame, bg=self.colors["panel_bg"])
        r_hdr.pack(fill="x", padx=5, pady=5)

        self.lbl_patch_title = tk.Label(
            r_hdr,
            text="Patch: UNVALIDATED",
            fg="#94a3b8",
            bg=self.colors["panel_bg"],
            font=("Segoe UI", 8, "bold"),
        )
        self.lbl_patch_title.pack(side="left")

        tk.Button(
            r_hdr,
            text="ðŸ“‹ Schema",
            command=self.copy_schema_to_clipboard,
            bg="#334155",
            fg="white",
            font=("Segoe UI", 8),
            relief="flat",
        ).pack(side="right", padx=5)

        self.txt_patch = scrolledtext.ScrolledText(
            right_frame,
            bg="#020617",
            fg="#cbd5e1",
            insertbackground="white",
            borderwidth=0,
        )
        self.txt_patch.pack(fill="both", expand=True)
        self.txt_patch.insert("1.0", self.get_schema_template())

        paned.add(right_frame)

        # --- Action Footer ---
        footer = tk.Frame(self.root, bg=self.colors["bg"])
        footer.pack(fill="x", padx=15, pady=10)

        chk_indent = tk.Checkbutton(
            footer,
            text="Force Patch Indentation (Strict Whitespace)",
            variable=self.force_indent_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
        )
        chk_indent.pack(side="left")

        chk_diff = tk.Checkbutton(
            footer,
            text="Show Diff Preview",
            variable=self.diff_view_var,
            bg=self.colors["bg"],
            fg="#cbd5e1",
            selectcolor=self.colors["bg"],
            activebackground=self.colors["bg"],
            activeforeground="white",
            command=self.on_diff_toggle,
        )
        chk_diff.pack(side="left", padx=(10, 0))

        # Unified Validate / Apply group
        btn_val_config = ButtonConfig(
            text="Validate",
            command=self.validate_patch,
            bg_color="#10B981",  # Emerald Green
            active_bg_color="#059669"
        )

        btn_apply_config = ButtonConfig(
            text="Apply",
            command=self.apply_patch,
            bg_color="#2563EB",  # Royal Blue
            active_bg_color="#1D4ED8"
        )

        # Using the Local replacement here
        self.button_group = LocalUnifiedButtonGroup(
            parent=footer,
            left_btn=btn_val_config,
            right_btn=btn_apply_config
        )
        self.button_group.pack(side="right")

        # --- Log Window ---
        self.debug_out = scrolledtext.ScrolledText(
            self.root,
            height=6,
            bg=self.colors["log_bg"],
            fg=self.colors["log_fg"],
            insertbackground="white",
            borderwidth=0,
            font=("Consolas", 9),
        )
        self.debug_out.pack(fill="x", padx=15, pady=(0, 5))

        # --- Status Bar (Blinking) ---
        self.status_bar = tk.Label(
            self.root,
            text="Ready",
            bg=self.colors["bg"],
            fg=self.colors["success"],
            font=("Consolas", 10),
            anchor="w",
            padx=15,            pady=5,
        )
        self.status_bar.pack(fill="x", side="bottom")

    # --- Status / Blink Helpers ---

    def set_status(self, msg, state="info"):
        colors = {
            "info": self.colors["success"],
            "error": self.colors["error"],
            "working": self.colors["working"],
        }
        color = colors.get(state, self.colors["success"])

        # 1. Status label text
        self.status_bar.config(text=msg, fg=color)
        if state == "working":
            self.start_blink()
        else:
            self.stop_blink()

        # 2. Log window
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        prefix = "ERROR: " if state == "error" else ""
        log_entry = f"[{timestamp}] {prefix}{msg}\n"
        self.debug_out.insert(tk.END, log_entry)
        self.debug_out.see(tk.END)

    def start_blink(self):
        self.is_blinking = True
        self._blink_loop()

    def stop_blink(self):
        self.is_blinking = False
        # Reset to working color when stopping from blink
        try:
            self.status_bar.config(fg=self.colors["success"])
        except Exception:
            pass

    def _blink_loop(self):
        if not self.is_blinking:
            return
        current_fg = self.status_bar.cget("foreground")
        next_fg = self.colors["bg"] if current_fg == self.colors["working"] else self.colors["working"]
        self.status_bar.config(fg=next_fg)
        self.root.after(600, self._blink_loop)

    # --- File Logic & Diff Preview ---

    def load_file(self):
        path = filedialog.askopenfilename()
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", content)
            self.loaded_filepath = path

            # Reset panel titles
            self.lbl_left_title.config(text="TARGET SOURCE CODE")
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")

            # Reset validation / diff state
            self.validation_preview_text = None
            self.validation_valid = False
            self.diff_view_var.set(False)

            self.set_status(f"Loaded: {path}", "info")
        except Exception as e:
            self.set_status(f"Error loading file: {e}", "error")

    def save_file(self):
        orig = self.loaded_filepath
        if orig and self.version_enabled_var.get():
            d, f = os.path.split(orig)
            base, ext = os.path.splitext(f)
            suffix = self.version_suffix_var.get()
            if suffix and not suffix.startswith("_"):
                suffix = "_" + suffix
            filename = f"{base}{suffix}{ext}"
            path = os.path.join(d, filename)
        elif orig:
            path = orig
        else:
            path = filedialog.asksaveasfilename(defaultextension=".txt")

        if not path:
            return

        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(self.txt_file.get("1.0", tk.END))
            self.set_status(f"Saved to: {os.path.basename(path)}", "info")
        except Exception as e:
            self.set_status(f"Save failed: {e}", "error")

    def get_schema_template(self):
        return (
            "{\n"
            "  \"hunks\": [\n"
            "    {\n"
            "      \"description\": \"Short human description\",\n"
            "      \"search_block\": \"exact text to find\\n(can span multiple lines)\",\n"
            "      \"replace_block\": \"replacement text\\n(same or different length)\",\n"
            "      \"use_patch_indent\": false\n"
            "    }\n"
            "  ]\n"
            "}\n"
        )

    def copy_schema_to_clipboard(self):
        self.root.clipboard_clear()
        self.root.clipboard_append(self.get_schema_template())
        self.set_status("Schema copied to clipboard.", "info")

    def _show_diff_view(self, original_text: str, preview_text: str):
        orig_lines = original_text.splitlines()
        new_lines = preview_text.splitlines()
        diff_lines = difflib.unified_diff(
            orig_lines,
            new_lines,
            fromfile="original",
            tofile="preview",
            lineterm="",
        )
        diff_text = "\n".join(diff_lines) or "(No differences)\n"
        self.txt_file.delete("1.0", tk.END)
        self.txt_file.insert("1.0", diff_text)

    def on_diff_toggle(self):
        # Only meaningful if we have a valid preview
        if not self.validation_valid or not self.validation_preview_text:
            return

        current_source = self.txt_file.get("1.0", tk.END)
        # If diff is being turned on, show diff between current source and preview
        if self.diff_view_var.get():
            self._show_diff_view(current_source, self.validation_preview_text)
        else:
            # Restore plain source view (just show current source as-is)
            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", current_source)

    # --- Validate / Apply ---

    def validate_patch(self):
        original_text = self.txt_file.get("1.0", tk.END)
        patch_text = self.txt_patch.get("1.0", tk.END)
        force = self.force_indent_var.get()

        try:
            patch_obj = json.loads(patch_text)
            preview_text = apply_patch_text(
                original_text,
                patch_obj,
                global_force_indent=force,
            )

            self.validation_preview_text = preview_text
            self.validation_valid = True

            self.lbl_patch_title.config(text="Patch: VALIDATED (DRY RUN)")
            self.set_status("Validation succeeded (dry run).", "info")

            if self.diff_view_var.get():
                self._show_diff_view(original_text, preview_text)
            else:
                # Ensure left panel shows the original text
                self.txt_file.delete("1.0", tk.END)
                self.txt_file.insert("1.0", original_text)

        except json.JSONDecodeError:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status("Error: Invalid JSON. Check formatting.", "error")

        except PatchError as e:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"Patch Error during validation: {e}", "error")

        except Exception as e:
            self.validation_preview_text = None
            self.validation_valid = False
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(
                f"System Error during validation: {e}",
                "error",
            )

    def apply_patch(self):
        target_text = self.txt_file.get("1.0", tk.END)
        patch_text = self.txt_patch.get("1.0", tk.END)
        force = self.force_indent_var.get()

        try:
            if self.validation_valid and self.validation_preview_text:
                new_text = self.validation_preview_text
            else:
                patch_obj = json.loads(patch_text)
                new_text = apply_patch_text(
                    target_text,
                    patch_obj,
                    global_force_indent=force,
                )

            self.txt_file.delete("1.0", tk.END)
            self.txt_file.insert("1.0", new_text)

            # Clear validation/diff state after commit
            self.validation_preview_text = None
            self.validation_valid = False
            self.diff_view_var.set(False)

            self.lbl_left_title.config(text="PATCHED SOURCE CODE")
            self.lbl_patch_title.config(text="Patch: VALIDATED & APPLIED")
            self.set_status("Success: Patch Applied.", "info")

        except json.JSONDecodeError:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status("Error: Invalid JSON.", "error")

        except PatchError as e:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"Patch Error: {e}", "error")

        except Exception as e:
            self.lbl_patch_title.config(text="Patch: UNVALIDATED")
            self.set_status(f"System Error: {e}", "error")

    def start(self):
        self.root.mainloop()

def run_gui():
    print("Launching GUI Mode...")
    app = App()
    app.start()

# ==============================================================================
# CLI MODE (Utility)
# ==============================================================================

def run_cli():
    """
    Command Line Interface Entry Point.
    """
    parser = argparse.ArgumentParser(description="_TokenizingPATCHER CLI")
    parser.add_argument("target", help="Path to the target source file")
    parser.add_argument("patch", help="Path to the JSON patch file")
    parser.add_argument("--output", "-o", help="Path to save the result (defaults to print stdout)")
    parser.add_argument("--force-indent", action="store_true", help="Force patch indentation")
    parser.add_argument("--dry-run", action="store_true", help="Validate only, do not write")
    
    args = parser.parse_args()
    
    # 1. Read Target
    try:
        with open(args.target, "r", encoding="utf-8") as f:
            target_text = f.read()
    except FileNotFoundError:
        print(f"Error: Target file not found: {args.target}")
        sys.exit(1)

    # 2. Read Patch
    try:
        with open(args.patch, "r", encoding="utf-8") as f:
            patch_obj = json.load(f)
    except FileNotFoundError:
        print(f"Error: Patch file not found: {args.patch}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Patch file is not valid JSON.")
        sys.exit(1)

    # 3. Apply
    try:
        new_text = apply_patch_text(target_text, patch_obj, global_force_indent=args.force_indent)
        
        if args.dry_run:
            print("Dry Run Successful. Patch applies cleanly.")
        else:
            if args.output:
                with open(args.output, "w", encoding="utf-8") as f:
                    f.write(new_text)
                print(f"Success: Patched file written to {args.output}")
            else:
                print(new_text)
                
    except PatchError as e:
        print(f"Patch Failed: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected Error: {e}")
        sys.exit(1)

# ==============================================================================
# HYBRID ENTRY POINT
# ==============================================================================

def main():
    if len(sys.argv) > 1:
        run_cli()
    else:
        run_gui()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: _TokenizingPATCHER\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\requirements.txt
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\app.pyw
--------------------------------------------------------------------------------
import json
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog


# ---------- Data model ----------

@dataclass
class AppConfig:
    name: str
    folder: Path              # absolute
    python_cmd: Optional[str] = None  # interpreter or "py"
    env: Dict[str, str] = field(default_factory=dict)

    @property
    def has_src_app(self) -> bool:
        return (self.folder / "src" / "app.py").is_file()

    def resolve_python(self) -> List[str]:
        """
        Determine the Python command list to run for this app.
        Priority:
        1. Explicit python_cmd (absolute or relative to folder, or just 'py').
        2. .venv inside app folder.
        3. 'py' (on Windows) or sys.executable elsewhere.
        """
        # 1. Explicit config
        if self.python_cmd:
            cmd = self.python_cmd
            # If relative path, resolve to inside app folder
            if os.path.sep in cmd or "/" in cmd:
                python_path = (self.folder / cmd).resolve()
                return [str(python_path)]
            else:
                # e.g., "py" or "python"
                return [cmd]

        # 2. Local venv
        win_candidate = self.folder / ".venv" / "Scripts" / "pythonw.exe"
        win_fallback = self.folder / ".venv" / "Scripts" / "python.exe"
        nix_candidate = self.folder / ".venv" / "bin" / "python"

        if win_candidate.is_file():
            return [str(win_candidate.resolve())]
        if win_fallback.is_file():
            return [str(win_fallback.resolve())]
        if nix_candidate.is_file():
            return [str(nix_candidate.resolve())]

        # 3. Fallback to system
        if os.name == "nt":
            return ["pyw"]
        return [sys.executable]


# ---------- Config discovery ----------

# Go up 3 levels: src -> _UsefulHelperScriptsMENU -> _UsefulHelperSCRIPTS (Root)
ROOT_DIR = Path(__file__).resolve().parent.parent.parent
CONFIG_FILE = ROOT_DIR / "helper_apps.json"


def load_config_file() -> Dict[str, AppConfig]:
    """
    Load helper_apps.json if it exists.
    Returns a mapping of folder (resolved) -> AppConfig
    """
    configs: Dict[str, AppConfig] = {}

    if not CONFIG_FILE.is_file():
        return configs

    try:
        raw = json.load(CONFIG_FILE.open("r", encoding="utf-8"))
    except Exception as e:
        print(f"[WARN] Failed to load {CONFIG_FILE}: {e}")
        return configs

    for entry in raw:
        folder = ROOT_DIR / entry["folder"]
        name = entry.get("name", folder.name)
        python_cmd = entry.get("python")
        env = entry.get("env", {})

        cfg = AppConfig(
            name=name,
            folder=folder,
            python_cmd=python_cmd,
            env=env,
        )
        configs[str(folder.resolve())] = cfg

    return configs


def discover_apps() -> List[AppConfig]:
    """
    Discover app folders that contain src/app.py.
    Merge with config entries when present.
    """
    configs_by_folder = load_config_file()
    apps: Dict[str, AppConfig] = {}

    # 1. From config (even if src/app.py missing, we keep but mark missing)
    for folder_key, cfg in configs_by_folder.items():
        apps[folder_key] = cfg

    # 2. Auto-discover any dir with src/app.py (one level deep by default)
    for child in ROOT_DIR.iterdir():
        if not child.is_dir():
            continue
        candidate = child / "src" / "app.py"
        if candidate.is_file():
            key = str(child.resolve())
            if key not in apps:
                apps[key] = AppConfig(name=child.name, folder=child)

    # Filter out ones that truly have no src/app.py AND werenâ€™t meant to be virtual
    # (We keep them though, but you can choose to hide them instead).
    return list(apps.values())


# ---------- Launcher logic ----------

def launch_app(app_cfg: AppConfig):
    if not app_cfg.has_src_app:
        messagebox.showerror(
            "Missing app.py",
            f"Could not find src/app.py in:\n{app_cfg.folder}",
        )
        return

    python_cmd = app_cfg.resolve_python()

    cmd = python_cmd + ["-m", "src.app"]

    env = os.environ.copy()
    env.update(app_cfg.env)

    try:
        if os.name == "nt":
            # Spawn in a new console on Windows
            subprocess.Popen(
                cmd,
                cwd=str(app_cfg.folder),
                env=env,
                # creationflags=subprocess.CREATE_NEW_CONSOLE,
            )
        else:
            # On Linux/macOS, normal Popen is usually fine
            subprocess.Popen(
                cmd,
                cwd=str(app_cfg.folder),
                env=env,
            )
    except Exception as e:
        messagebox.showerror(
            "Launch failed",
            f"Failed to launch {app_cfg.name}:\n\n{e}",
        )


# ---------- Tkinter UI ----------

class AppLauncherUI:
    def __init__(self, root: tk.Tk, apps: List[AppConfig]):
        self.root = root
        # Fix: Ensure apps are sorted safely even if empty
        self.apps = sorted(apps, key=lambda a: a.name.lower())
        self.app_by_name = {a.name: a for a in self.apps}

        self.root.title("Useful Helper Apps Launcher")
        self.root.geometry("600x400")

        self._build_widgets()

    def _build_widgets(self):
        # FIX: Added proper indentation here
        main_frame = ttk.Frame(self.root, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Left: app list
        left_frame = ttk.Frame(main_frame)
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=False)

        ttk.Label(left_frame, text="Available Apps").pack(anchor="w")

        self.app_listbox = tk.Listbox(left_frame, height=20)
        self.app_listbox.pack(fill=tk.BOTH, expand=True)
        self.app_listbox.bind("<Double-1>", self._on_double_click)

        for app in self.apps:
            suffix = "" if app.has_src_app else " (missing src/app.py)"
            self.app_listbox.insert(tk.END, f"{app.name}{suffix}")

        # Right: details + launch
        right_frame = ttk.Frame(main_frame, padding=(10, 0))
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.details_text = tk.Text(
            right_frame, height=10, wrap="word", state="disabled"
        )
        self.details_text.pack(fill=tk.BOTH, expand=True)

        btn_frame = ttk.Frame(right_frame)
        btn_frame.pack(fill=tk.X, pady=(10, 0))

        self.launch_button = ttk.Button(
            btn_frame, text="Launch Selected App", command=self._on_launch_clicked
        )
        self.launch_button.pack(side=tk.LEFT)

        self.create_button = ttk.Button(
            btn_frame, text="Create New", command=self._on_create_clicked
        )
        self.create_button.pack(side=tk.LEFT, padx=(5, 0))

        self.refresh_button = ttk.Button(
            btn_frame, text="Refresh Apps", command=self._on_refresh_clicked
        )
        self.refresh_button.pack(side=tk.LEFT, padx=(5, 0))

        # --- New Tools (Right Aligned) ---
        self.btn_ps = ttk.Button(
            btn_frame, text="PS", width=3, command=self._on_open_powershell
        )
        self.btn_ps.pack(side=tk.RIGHT, padx=(5, 0))

        self.btn_cmd = ttk.Button(
            btn_frame, text="CMD", width=4, command=self._on_open_cmd
        )
        self.btn_cmd.pack(side=tk.RIGHT, padx=(5, 0))

        self.btn_explore = ttk.Button(
            btn_frame, text="Folder", command=self._on_open_folder
        )
        self.btn_explore.pack(side=tk.RIGHT, padx=(5, 0))

        self.app_listbox.bind("<<ListboxSelect>>", self._on_select)

    def _on_create_clicked(self):
        name = simpledialog.askstring("New App", "Enter name for new app (Folder Name):")
        if not name:
            return
        
        # Basic sanitization
        safe_name = "".join(c for c in name if c.isalnum() or c in ('_', '-')).strip()
        if not safe_name:
            messagebox.showerror("Error", "Invalid name.")
            return

        target_dir = ROOT_DIR / safe_name
        if target_dir.exists():
            messagebox.showerror("Error", f"Folder '{safe_name}' already exists.")
            return

        try:
            self._write_boilerplate(target_dir)
            self._on_refresh_clicked()
            messagebox.showinfo("Success", f"Created {safe_name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to create app: {e}")

    def _write_boilerplate(self, root_path: Path):
        # Define the master template path
        template_source = ROOT_DIR / "_BoilerPlatePythonTEMPLATE"

        if template_source.is_dir():
            # OPTION A: Copy from your existing template folder
            # shutil.copytree requires the destination to NOT exist, but we created 
            # root_path logic earlier. So we copy contents manually or use dirs_exist_ok.
            try:
                shutil.copytree(template_source, root_path, dirs_exist_ok=True)
                print(f"[Info] Cloned template from {template_source}")
                return
            except Exception as e:
                messagebox.showerror("Template Error", f"Failed to copy template:\n{e}")
                return
        
        # OPTION B: Fallback (If template folder is missing)
        # This ensures the launcher still works even if you move the template folder.
        messagebox.showwarning("Template Missing", 
            f"Could not find '{template_source.name}'.\nUsing minimal fallback.")
        
        root_path.mkdir(parents=True, exist_ok=True)
        (root_path / "src").mkdir(exist_ok=True)
        (root_path / "requirements.txt").touch()
        (root_path / "src" / "__init__.py").touch()
        
        # Minimal app.py so it runs
        with (root_path / "src" / "app.py").open("w", encoding="utf-8") as f:
            f.write("def main():\n    print('Template folder missing! This is a fallback.')\n\nif __name__ == '__main__':\n    main()")

    def _on_refresh_clicked(self):
        """Re-discover apps and refresh the listbox/details without restarting the launcher."""
        # FIX: Added proper indentation here
        self.apps = sorted(discover_apps(), key=lambda a: a.name.lower())
        self.app_by_name = {a.name: a for a in self.apps}

        # Repopulate listbox
        self.app_listbox.delete(0, tk.END)
        for app in self.apps:
            suffix = "" if app.has_src_app else " (missing src/app.py)"
            self.app_listbox.insert(tk.END, f"{app.name}{suffix}")

        # Reset details panel
        self.details_text.config(state="normal")
        self.details_text.delete("1.0", tk.END)
        self.details_text.insert(
            "1.0",
            "Refreshed app list.\n\nSelect an app to see details.",
        )
        self.details_text.config(state="disabled")

    def _on_open_folder(self):
        app = self._get_selected_app()
        if app and app.folder.is_dir():
            if os.name == "nt":
                os.startfile(app.folder)
            else:
                # Linux/Mac fallback
                subprocess.Popen(["xdg-open", str(app.folder)])

    def _on_open_cmd(self):
        app = self._get_selected_app()
        if app and app.folder.is_dir():
            if os.name == "nt":
                subprocess.Popen(["start", "cmd"], shell=True, cwd=app.folder)

    def _on_open_powershell(self):
        app = self._get_selected_app()
        if app and app.folder.is_dir():
            if os.name == "nt":
                subprocess.Popen(["start", "powershell"], shell=True, cwd=app.folder)

    def _get_selected_app(self) -> Optional[AppConfig]:
        selection = self.app_listbox.curselection()
        if not selection:
            return None
        idx = selection[0]
        name_with_suffix = self.app_listbox.get(idx)
        name = name_with_suffix.split(" (missing")[0]
        return self.app_by_name.get(name)

    def _on_select(self, event=None):
        app = self._get_selected_app()
        if not app:
            return
        self._update_details(app)

    def _update_details(self, app: AppConfig):
        folder_display = str(app.folder)
        python_cmd = " ".join(app.resolve_python())
        has_app = "Yes" if app.has_src_app else "No"

        env_lines = "\n".join(
            [f"  {k}={v}" for k, v in app.env.items()]
        ) or "  (none)"

        text = (
            f"Name: {app.name}\n"
            f"Folder: {folder_display}\n"
            f"Has src/app.py: {has_app}\n"
            f"Python command: {python_cmd}\n"
            f"Extra env vars:\n{env_lines}\n"
        )

        self.details_text.config(state="normal")
        self.details_text.delete("1.0", tk.END)
        self.details_text.insert("1.0", text)
        self.details_text.config(state="disabled")

    def _on_launch_clicked(self):
        app = self._get_selected_app()
        if not app:
            messagebox.showinfo("No selection", "Please select an app to launch.")
            return
        launch_app(app)

    def _on_double_click(self, event=None):
        self._on_launch_clicked()


def main():
    apps = discover_apps()
    
    # FIX: Initialize root immediately
    root = tk.Tk()
    
    # FIX: If no apps, just show a message or launch empty. 
    # Do NOT return silently.
    if not apps:
        # Option A: Show error then open empty UI
        messagebox.showinfo(
            "No Apps Found", 
            "No apps were found in subfolders.\n\nThe launcher will open empty. "
            "Add folders with 'src/app.py' and click Refresh."
        )
        # Or Option B: Just pass empty list to UI (which is what we do below)

    AppLauncherUI(root, apps)
    root.mainloop()


if __name__ == "__main__":
    main()






--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\requirements.txt
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\src\app.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
== Generic Python Module/CLI Boilerplate ==

This is a generic template for a Python file that can be:
1.  Imported as a module by other scripts (e.g., `import generic_module`).
2.  Run as a standalone command-line script (e.g., `$ python generic_module.py --input data.txt`).

How to use this template:
1.  Rename this file to match your new tool (e.g., `my_data_processor.py`).
2.  Update this docstring to describe what your tool does.
3.  Fill in the "CORE FUNCTIONALITY" section with your app's logic.
4.  Go to the `main()` function to define your CLI arguments.
5.  In `main()`, add the code to call your core functions using the parsed arguments.
"""

# 1. IMPORTS
# Standard library imports
import sys
import os
import argparse  # For parsing command-line arguments

# Third-party imports (if any)
# e.g., import requests

# Local/application imports (if any)
# e.g., from . import my_other_module


# 2. CONSTANTS
# TODO: Define any constants your application needs.
SOME_DEFAULT_SETTING = "default_value"


# 3. CORE FUNCTIONALITY (The "Importable" Module)
#
# These functions make up the "core logic" of your application.
# They can be imported and used by other Python scripts.
# They should be self-contained and not rely on command-line arguments.

def core_logic_function(data: any, setting: str = SOME_DEFAULT_SETTING) -> any:
    """
    TODO: Replace this with your main logic function.
    
    This function should perform the primary task of your module.
    
    Args:
        data (any): The input data to process.
        setting (str, optional): An example of an optional setting.
                                 Defaults to SOME_DEFAULT_SETTING.

    Returns:
        any: The processed data.
    """
    print(f"[Core Logic] Processing data with setting: {setting}")
    
    # --- TODO: Your actual logic goes here ---
    # Example:
    try:
        processed_data = f"Processed data: {str(data).upper()}"
        print("[Core Logic] Processing complete.")
        return processed_data
    except Exception as e:
        print(f"[Core Logic] Error during processing: {e}", file=sys.stderr)
        # Re-raise the exception to be handled by the caller
        raise


def helper_function(value: int) -> str:
    """
    TODO: Add any helper functions your core logic needs.
    
    This is an example of a helper that might be called by
    core_logic_function or also be importable.
    
    Args:
        value (int): An input value.

    Returns:
        str: A formatted string.
    """
    return f"Helper processed value: {value * 2}"


# 4. CLI (Command-Line Interface) LOGIC
#
# This code only runs when the script is executed directly.
# It should handle parsing arguments and calling the core functions.

def main():
    """
    Main function to run the script from the command line.
    
    It parses arguments, calls core functions, and handles CLI-specific
    input/output and error handling.
    """
    
    # --- Argument Parsing ---
    # Set up the argument parser
    # TODO: Update the description to match your tool.
    parser = argparse.ArgumentParser(
        description="A generic CLI tool. TODO: Describe your tool here.",
        epilog="Example: python generic_module.py my_input.txt -o my_output.txt -v"
    )
    
    # --- TODO: Define your arguments ---
    
    # Example of a required positional argument
    parser.add_argument(
        "input_path",  # The name of the argument
        type=str,
        help="TODO: Describe this required input (e.g., path to an input file)."
    )
    
    # Example of an optional argument (e.g., -o or --output)
    parser.add_argument(
        "-o", "--output",
        type=str,
        default=None,  # Default to None if not provided
        help="TODO: Describe this optional argument (e.g., path to an output file)."
    )
    
    # Example of a "flag" argument (stores True if present)
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",  # This makes it a boolean flag
        help="Enable verbose output."
    )
    
    # Parse the arguments from the command line (e.g., sys.argv)
    args = parser.parse_args()

    # --- Main Application Flow ---
    
    # Use the 'verbose' flag to control print statements
    if args.verbose:
        print("Verbose mode enabled.", file=sys.stderr)
        print(f"Arguments received: {args}", file=sys.stderr)

    try:
        # 1. Load data (CLI-specific task)
        #    TODO: Replace this with your actual data loading
        if args.verbose:
            print(f"Loading data from {args.input_path}...", file=sys.stderr)
        # This is just an example. You'd likely load a file here.
        input_data = f"Content of {args.input_path}" 

        # 2. Call core logic (the "importable" part)
        if args.verbose:
            print("Calling core logic...", file=sys.stderr)
        
        # Here we pass the CLI arguments to the core function
        processed_data = core_logic_function(input_data)
        
        # 3. Handle output (CLI-specific task)
        if args.output:
            # Save to a file
            if args.verbose:
                print(f"Saving processed data to {args.output}...", file=sys.stderr)
            # TODO: Add file-saving logic here
            # with open(args.output, 'w') as f:
            #     f.write(processed_data)
            print(f"Success: Output saved to {args.output}")
        else:
            # Print to standard output
            if args.verbose:
                print("Printing processed data to stdout:", file=sys.stderr)
            print(processed_data)
        
        # Exit with a success code
        sys.exit(0)

    except FileNotFoundError as e:
        print(f"\nError: Input file not found.", file=sys.stderr)
        print(f"Details: {e}", file=sys.stderr)
        sys.exit(1) # Exit with a non-zero error code
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)


# This "magic" line is the key to the whole pattern:
#
# - If you run `python generic_module.py ...`, Python sets
#   __name__ = "__main__", and the main() function is called.
#
# - If you `import generic_module` in another script, __name__
#   is "generic_module", so this block is SKIPPED.
#
if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
FILE: _UsefulHelperScriptsMENU\src\_BoilerPlatePythonTEMPLATE\src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\README.md
--------------------------------------------------------------------------------
Here is the **Official `README.md`** for your project.

It documents the tool as a serious engineering utility, explaining exactly how the "Colon Guard" works so that future-you (or other developers) understands why the engine makes the decisions it does.

### **File: `README.md`**

````markdown
# IndentArchitect // The Python Normalization Protocol

> **Status:** Active / Stable
> **Version:** 1.0.0
> **Core Logic:** Deterministic Structural Parsing (No Fuzzy Matching)

IndentArchitect is a precision tool designed to repair, normalize, and enforce strict indentation hierarchies in Python codebases. Unlike standard formatters (Black/YAPF) which assume the code is parseable, IndentArchitect is designed to ingest **broken, unparseable code** (mixed tabs/spaces, "staircase" indentation, lost blocks) and reconstruct a valid syntax tree based on visual structure.

---

## ðŸ— The Architecture

Standard parsers (AST) crash on broken indentation. IndentArchitect uses a custom **Concrete Syntax Graph** approach:

1.  **The Granular Map:** Every line is tokenized into `[Indent_Type, Indent_Width, Content, Trailing]`.
2.  **The Relative Stack:** Instead of calculating depth by division (e.g., `spaces / 4`), the engine learns the indentation level dynamically by comparing the current line to the previous one.
3.  **The Colon Guard:** The heuristic engine enforces a strict rule: **"A new indentation block is only valid if the previous line ended with a colon (`:`)."**
    * *Result:* This automatically flattens "Staircase Effect" errors where code drifts to the right without a logical parent.

---

## ðŸš€ Installation & Setup

This project follows the **Systems Thinker** boilerplate. It includes a self-bootstrapping environment script.

1.  **Clone/Unzip** the repository.
2.  **Run `setup_env.bat`** (Windows).
    * Checks for Python.
    * Creates `.venv`.
    * Installs dependencies (Tkinter is standard lib; no external networking required).
3.  **Launch:**
    ```batch
    python -m src.app
    ```

---

## ðŸ–¥ Usage Guide

### GUI Mode (Default)
Launch the app without arguments to open the **Normalization Dashboard**.

* **Left Pane (Dirty):** Paste broken code or load a file.
* **Middle Pane (Clean):** See the normalized preview. Ghost whitespace is stripped; hierarchy is flattened.
* **Right Pane (Patch):** Generates a JSON Patch Schema compatible with the `PatchMechanic` ecosystem.
* **Controls:**
    * **Format:** Toggle Tabs vs Spaces (Default: 4 Spaces).
    * **Save/Version:** Check "Add Suffix" to save as `filename_clean.py` instead of overwriting.

### CLI Mode (Headless)
Integrate IndentArchitect into CI/CD pipelines or batch scripts.

```bash
# Print normalized code to stdout
python -m src.app my_broken_script.py

# Overwrite the file in place
python -m src.app my_broken_script.py --write

# Output JSON Patch only (for external patchers)
python -m src.app my_broken_script.py --json

# Force Tab indentation
python -m src.app my_broken_script.py --write --tabs
````

-----

## ðŸ§  The "Colon Guard" Logic

If you see the tool "flattening" code you thought was nested, it is likely the **Colon Guard** at work.

**Example of "Staircase Error":**

```python
x = 1
  y = 2  <-- Engine sees: Previous line 'x=1' has NO colon.
    z = 3    Therefore, 'y' and 'z' are NOT children.
```

**Normalization Result:**

```python
x = 1
y = 2  <-- Snapped back to parent level.
z = 3
```

This behavior is intentional. It assumes that indentation without a logical block opener (def, if, loop, class) is a formatting error and corrects it to the nearest valid parent.

-----

## ðŸ“‚ Project Structure

```text
.
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ app.py            # The Hybrid Entry Point (GUI + CLI + Engine)
â”œâ”€â”€ requirements.txt      # Minimal dependencies
â”œâ”€â”€ setup_env.bat         # Auto-installer
â”œâ”€â”€ README.md             # You are here
â””â”€â”€ LICENSE.md            # MIT License
```

-----

*Generated by the Systems Thinker Refactoring Engine.*

```

--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\requirements.txt
--------------------------------------------------------------------------------
# --- Runtime Dependencies ---
# None. Uses Python Standard Library (tkinter, json, re, argparse).

# --- Build Tools ---
# Uncomment if you want to build a standalone .exe later
# pyinstaller>=6.0.0
--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\src\app.py
--------------------------------------------------------------------------------
import sys
import os
import argparse
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import json
import re

# ==============================================================================
# 1. CORE ENGINE (Business Logic)
# ==============================================================================
class WhitespaceEngine:
    """
    Parses code into a granular map of (Indent + Content + Trailing).
    Can Normalize structure and generate 'Hunk' patches.
    """
    def __init__(self):
        self.raw_lines = []
        self.nodes = []
        self.normalized_text = ""
        self.patch_data = {"hunks": []}
        self.current_filepath = None # Track the currently loaded file

    def load_source(self, text, filepath=None):
        self.raw_lines = text.splitlines()
        self.nodes = []
        self.current_filepath = filepath
        
        # State trackers
        indent_stack = [0] # Stack of indentation widths
        last_line_was_block_starter = False # Did previous line end with ':'?
        
        for i, line in enumerate(self.raw_lines):
            # 1. Parse content
            match = re.match(r"^([ \t]*)(.*?)([ \t]*)$", line)
            if not match:
                self.nodes.append({"id": i, "indent": "", "content": line, "depth": 0, "is_empty": True})
                continue
            
            indent, content, trailing = match.groups()
            is_empty = (len(content) == 0)
            
            # 2. Calculate Raw Width (Tab = 4 spaces)
            current_width = 0
            for char in indent:
                current_width += 4 if char == '\t' else 1

            # 3. Determine Depth
            if is_empty:
                # Empty lines preserve the current context
                depth = len(indent_stack) - 1
            else:
                # --- THE COLON GUARD ---
                # We only allow PUSHING a new level if the previous line opened a block.
                # Otherwise, we treat extra indent as just "bad formatting" and clamp it.
                
                # Logic: Should we indent deeper?
                if current_width > indent_stack[-1]:
                    if last_line_was_block_starter:
                        # Legitimate block entry
                        indent_stack.append(current_width)
                    else:
                        # "False Nesting" detected (Staircase Effect). 
                        pass 

                # Logic: Should we dedent?
                # We always respect dedents (moving back out)
                while len(indent_stack) > 1 and current_width < indent_stack[-1]:
                    indent_stack.pop()
                
                depth = len(indent_stack) - 1
                
                # Update tracker for NEXT line
                clean_content = content.split("#")[0].strip()
                last_line_was_block_starter = clean_content.endswith(":")

            self.nodes.append({
                "id": i,
                "raw_indent": indent,
                "depth": depth, 
                "content": content,
                "trailing": trailing,
                "is_empty": is_empty
            })

    def normalize(self, use_tabs=False, space_count=4):
        """Reconstructs the code with strict indentation rules."""
        char = "\t" if use_tabs else (" " * space_count)
        clean_lines = []
        
        for node in self.nodes:
            if node["is_empty"]:
                clean_lines.append("") # Strip whitespace on empty lines
            else:
                new_indent = char * node["depth"]
                clean_lines.append(f"{new_indent}{node['content']}")
        
        self.normalized_text = "\n".join(clean_lines)
        return self.normalized_text

    def generate_patch(self):
        """
        Compares Raw vs Normalized and generates the JSON Schema Hunks.
        """
        clean_lines = self.normalized_text.splitlines()
        if not clean_lines: 
            return {"hunks": []}

        hunks = []
        current_hunk = None
        
        for i, (raw, clean) in enumerate(zip(self.raw_lines, clean_lines)):
            if raw != clean:
                if current_hunk is None:
                    current_hunk = {
                        "start_line": i,
                        "raw_block": [raw],
                        "clean_block": [clean]
                    }
                else:
                    # Check continuity
                    if i == current_hunk["start_line"] + len(current_hunk["raw_block"]):
                        current_hunk["raw_block"].append(raw)
                        current_hunk["clean_block"].append(clean)
                    else:
                        self._finalize_hunk(hunks, current_hunk)
                        current_hunk = {
                            "start_line": i,
                            "raw_block": [raw],
                            "clean_block": [clean]
                        }
            else:
                if current_hunk:
                    self._finalize_hunk(hunks, current_hunk)
                    current_hunk = None

        if current_hunk:
            self._finalize_hunk(hunks, current_hunk)

        self.patch_data = {"hunks": hunks}
        return self.patch_data

    def _finalize_hunk(self, hunks_list, hunk_data):
        search_txt = "\n".join(hunk_data["raw_block"])
        replace_txt = "\n".join(hunk_data["clean_block"])
        schema_hunk = {
            "description": f"Normalize indentation (Lines {hunk_data['start_line']}-{hunk_data['start_line'] + len(hunk_data['raw_block'])})",
            "search_block": search_txt,
            "replace_block": replace_txt,
            "use_patch_indent": False
        }
        hunks_list.append(schema_hunk)

# ==============================================================================
# 2. GUI LAYER (The Visual Cortex)
# ==============================================================================
class AppGUI:
    def __init__(self, root, engine):
        self.root = root
        self.engine = engine
        
        self.root.title("IndentArchitect // Normalization Protocol")
        self.root.geometry("1400x850")
        self.root.configure(bg="#1e1e1e")

        # Styles
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("TButton", background="#333", foreground="#eee", borderwidth=1)
        style.map("TButton", background=[("active", "#444")])
        style.configure("TCheckbutton", background="#252526", foreground="#eee")
        style.configure("TLabel", background="#252526", foreground="#eee")
        
        self.font_mono = ("Consolas", 10)
        self.font_ui = ("Segoe UI", 9)

        # Variables
        self.var_use_tabs = tk.BooleanVar(value=False)
        self.var_space_count = tk.IntVar(value=4)
        self.var_use_suffix = tk.BooleanVar(value=True)
        self.var_suffix = tk.StringVar(value="_clean")
        
        self.setup_layout()

    def setup_layout(self):
        # --- HEADER / TOOLBAR ---
        header = tk.Frame(self.root, bg="#252526", height=50)
        header.pack(fill=tk.X, pady=(0, 2))
        
        # Section 1: Branding & Load
        f_load = tk.Frame(header, bg="#252526")
        f_load.pack(side=tk.LEFT, padx=10)
        tk.Label(f_load, text="INDENT ARCHITECT", bg="#252526", fg="#007acc", font=("Segoe UI", 11, "bold")).pack(side=tk.LEFT, padx=(0, 10))
        tk.Button(f_load, text="Load File...", command=self.load_file, bg="#3c3c3c", fg="white", relief=tk.FLAT).pack(side=tk.LEFT)

        # Separator
        ttk.Separator(header, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        # Section 2: Indentation Settings
        f_settings = tk.Frame(header, bg="#252526")
        f_settings.pack(side=tk.LEFT)
        
        tk.Label(f_settings, text="Format:", font=self.font_ui).pack(side=tk.LEFT, padx=(0,5))
        
        self.chk_tabs = ttk.Checkbutton(f_settings, text="Use Tabs", variable=self.var_use_tabs, command=self.run_normalization)
        self.chk_tabs.pack(side=tk.LEFT, padx=5)
        
        tk.Label(f_settings, text="Spaces:", font=self.font_ui).pack(side=tk.LEFT, padx=(5,2))
        self.spin_spaces = tk.Spinbox(f_settings, from_=1, to=8, textvariable=self.var_space_count, width=3, bg="#333", fg="white", buttonbackground="#444")
        self.spin_spaces.pack(side=tk.LEFT)
        # Re-run norm when spinbox changes (bind release/enter)
        self.spin_spaces.bind("<KeyRelease>", lambda e: self.run_normalization())
        self.spin_spaces.bind("<ButtonRelease-1>", lambda e: self.run_normalization())

        # Separator
        ttk.Separator(header, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        # Section 3: Action & Save
        f_action = tk.Frame(header, bg="#252526")
        f_action.pack(side=tk.LEFT)

        tk.Button(f_action, text="Re-Normalize", command=self.run_normalization, bg="#0e639c", fg="white", relief=tk.FLAT).pack(side=tk.LEFT, padx=5)
        
        # Versioning Controls
        f_ver = tk.Frame(f_action, bg="#2d2d2d", padx=5, pady=2) # Slightly darker grouping
        f_ver.pack(side=tk.LEFT, padx=10)
        
        ttk.Checkbutton(f_ver, text="Add Suffix:", variable=self.var_use_suffix).pack(side=tk.LEFT)
        tk.Entry(f_ver, textvariable=self.var_suffix, width=8, bg="#333", fg="#888", insertbackground="white").pack(side=tk.LEFT, padx=2)
        
        # Save Buttons
        tk.Button(f_action, text="Save", command=self.save_file, bg="#2da042", fg="white", relief=tk.FLAT).pack(side=tk.LEFT, padx=5)
        tk.Button(f_action, text="Save As...", command=self.save_as_file, bg="#333", fg="white", relief=tk.FLAT).pack(side=tk.LEFT, padx=0)

        # --- MAIN PANE ---
        paned = tk.PanedWindow(self.root, orient=tk.HORIZONTAL, bg="#1e1e1e", sashwidth=4)
        paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Pane 1: Dirty Input
        f1 = tk.LabelFrame(paned, text="Raw Input (Dirty)", bg="#1e1e1e", fg="#888")
        paned.add(f1, minsize=350)
        self.txt_input = scrolledtext.ScrolledText(f1, bg="#1e1e1e", fg="#d4d4d4", font=self.font_mono, insertbackground="white", undo=True)
        self.txt_input.pack(fill=tk.BOTH, expand=True)

        # Pane 2: Clean Output
        f2 = tk.LabelFrame(paned, text="Normalized Output (Preview)", bg="#1e1e1e", fg="#888")
        paned.add(f2, minsize=350)
        self.txt_clean = scrolledtext.ScrolledText(f2, bg="#1e1e1e", fg="#a6e22e", font=self.font_mono, insertbackground="white")
        self.txt_clean.pack(fill=tk.BOTH, expand=True)

        # Pane 3: JSON Patch
        f3 = tk.LabelFrame(paned, text="Patch Logic (JSON)", bg="#1e1e1e", fg="#888")
        paned.add(f3, minsize=300)
        self.txt_json = scrolledtext.ScrolledText(f3, bg="#2d2d2d", fg="#66d9ef", font=self.font_mono)
        self.txt_json.pack(fill=tk.BOTH, expand=True)

        # --- STATUS BAR ---
        self.status_var = tk.StringVar(value="Ready.")
        sb = tk.Label(self.root, textvariable=self.status_var, bg="#007acc", fg="white", anchor="w", font=self.font_ui)
        sb.pack(side=tk.BOTTOM, fill=tk.X)

    def load_file(self):
        path = filedialog.askopenfilename(filetypes=[("Python Files", "*.py"), ("All Files", "*.*")])
        if path:
            try:
                with open(path, "r", encoding="utf-8") as f:
                    content = f.read()
                self.txt_input.delete("1.0", tk.END)
                self.txt_input.insert("1.0", content)
                
                # Load into engine with filepath awareness
                self.engine.load_source(content, filepath=path)
                self.status_var.set(f"Loaded: {path}")
                
                # Auto-normalize on load
                self.run_normalization()
            except Exception as e:
                messagebox.showerror("Error", str(e))

    def run_normalization(self):
        raw_text = self.txt_input.get("1.0", tk.END).strip("\n")
        
        # Load text again (in case user edited the dirty pane)
        self.engine.load_source(raw_text, filepath=self.engine.current_filepath)
        
        # Get Settings
        use_tabs = self.var_use_tabs.get()
        try:
            space_count = int(self.var_space_count.get())
        except ValueError:
            space_count = 4

        clean_text = self.engine.normalize(use_tabs=use_tabs, space_count=space_count)
        patch_data = self.engine.generate_patch()

        # Update GUI
        self.txt_clean.delete("1.0", tk.END)
        self.txt_clean.insert("1.0", clean_text)
        
        self.txt_json.delete("1.0", tk.END)
        self.txt_json.insert("1.0", json.dumps(patch_data, indent=2))
        
        self.status_var.set(f"Normalized: {len(patch_data['hunks'])} adjustments made.")

    def save_file(self):
        """Smart Save: Overwrites or Versions based on checkbox."""
        content = self.txt_clean.get("1.0", tk.END).strip("\n")
        if not content:
            messagebox.showwarning("Warning", "Nothing to save!")
            return

        original_path = self.engine.current_filepath
        if not original_path:
            self.save_as_file()
            return

        target_path = original_path
        
        # Versioning Logic
        if self.var_use_suffix.get():
            directory, filename = os.path.split(original_path)
            name, ext = os.path.splitext(filename)
            suffix = self.var_suffix.get()
            target_path = os.path.join(directory, f"{name}{suffix}{ext}")

        try:
            with open(target_path, "w", encoding="utf-8") as f:
                f.write(content)
            self.status_var.set(f"Saved to: {target_path}")
            messagebox.showinfo("Success", f"File saved:\n{target_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not save file:\n{e}")

    def save_as_file(self):
        content = self.txt_clean.get("1.0", tk.END).strip("\n")
        target_path = filedialog.asksaveasfilename(
            defaultextension=".py",
            filetypes=[("Python Files", "*.py"), ("All Files", "*.*")]
        )
        if target_path:
            try:
                with open(target_path, "w", encoding="utf-8") as f:
                    f.write(content)
                self.status_var.set(f"Saved As: {target_path}")
            except Exception as e:
                messagebox.showerror("Error", str(e))

# ==============================================================================
# 3. CLI LAYER (Utility)
# ==============================================================================
def run_cli():
    parser = argparse.ArgumentParser(description="IndentArchitect CLI")
    parser.add_argument("file", help="Path to python file to normalize")
    parser.add_argument("--json", action="store_true", help="Output JSON patch only")
    parser.add_argument("--write", action="store_true", help="Overwrite file with normalized version")
    parser.add_argument("--spaces", type=int, default=4, help="Number of spaces (default 4)")
    parser.add_argument("--tabs", action="store_true", help="Use tabs instead of spaces")
    args = parser.parse_args()

    engine = WhitespaceEngine()
    
    try:
        with open(args.file, "r", encoding="utf-8") as f:
            content = f.read()
            
        engine.load_source(content, filepath=args.file)
        normalized = engine.normalize(use_tabs=args.tabs, space_count=args.spaces)
        
        if args.json:
            patch = engine.generate_patch()
            print(json.dumps(patch, indent=2))
        elif args.write:
            with open(args.file, "w", encoding="utf-8") as f:
                f.write(normalized)
            print(f"File normalized: {args.file}")
        else:
            print(normalized)
            
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

# ==============================================================================
# 4. ENTRY POINT
# ==============================================================================
def main():
    if len(sys.argv) > 1:
        run_cli()
    else:
        root = tk.Tk()
        engine = WhitespaceEngine()
        app = AppGUI(root, engine)
        root.mainloop()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
FILE: _WhitespaceMECHANIC\src\__init__.py
--------------------------------------------------------------------------------
