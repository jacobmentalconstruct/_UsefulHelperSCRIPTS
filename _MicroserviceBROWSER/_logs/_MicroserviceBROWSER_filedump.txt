Dump: C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_MicroserviceBROWSER


--------------------------------------------------------------------------------
FILE: .txt
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: AgentSpec_list-of-tools.txt
--------------------------------------------------------------------------------
# TOOL DEFINITIONS (STRICT INTERFACE)

## Tool: SpinnerThingyMaBobberMS
Description: The Visualizer: An interactive spinner widget.
Functions:
  - launch()
    # Starts the Tkinter main event loop
  - handle_keypress(event)
  - get_neon_color(offset)
  - draw_arc(cx, cy, radius, width, start, extent, color)
  - animate()

## Tool: EnvironmentManagerMS
Description: The Operator.
Functions:
  - resolve_python(project_path, config_override)
    # Priority:
1
  - launch_script(project_path, script_rel_path, env_vars)

## Tool: PythonChunkerMS
Description: Specialized Python AST Chunker.
Functions:
  - get_health()
    # Returns the operational status of the PythonChunkerMS
  - chunk(content)
    # Parses Python source into semantic CodeChunks

## Tool: ContentExtractorMS
Description: The Decoder.
Functions:
  - get_health()
    # Returns the operational status and library availability
  - extract_text(blob, mime_type)
    # Main routing logic for extraction

## Tool: ServiceRegistryMS
Description: The Tokenizer (v2): Scans a library of Python microservices and generates
Functions:
  - scan(save_to)

## Tool: TelemetryServiceMS
Description: The Nervous System.
Functions:
  - get_health()
    # Returns the operational status of the TelemetryServiceMS
  - start()
    # Begins the GUI update loop
  - ping()
    # Allows an agent to verify the pulse of the UI loop

## Tool: TreeMapperMS
Description: The Cartographer: Generates ASCII-art style directory maps.
Functions:
  - generate_tree(root_path, additional_exclusions, use_default_exclusions)

## Tool: ChalkBoardMS
Description: No description.
Functions:
  - loaded()
    # Called by JS when the page is ready
  - log_action(action_name)
    # Called by JS when user interacts
  - update_sign(text, theme)
    # Updates the embedded HTML via JS injection
  - trigger_effect(effect)
    # Triggers CSS animations like 'shake'

## Tool: NeuralGraphViewerMS
Description: No description.
Functions:
  - bind_services(cartridge, neural)
  - run_search(event)
  - load_from_db(db_path)
    # Loads graph data from SQLite
  - on_resize(event)
  - on_double_click(event)
  - on_click(event)
  - on_release(event)
  - on_drag(event)
  - on_hover(event)
  - on_zoom(amount)
  - on_windows_scroll(event)
  - animate()
    # The Heartbeat Loop

## Tool: DiffEngineMS
Description: The Timekeeper: Implements a 'Hybrid' versioning architecture.
Functions:
  - update_file(path, new_content, author)
    # The Atomic Update Operation:
1
  - get_head(path)
    # Fast retrieval of current content
  - get_history(path)
    # Retrieves the full evolution history of a file

## Tool: CodeFormatterMS
Description: The Architect.
Functions:
  - normalize_code(content, use_tabs, spaces)
    # Pure logic endpoint: Takes string, returns string + patch
  - format_file(file_path, use_tabs, spaces)
    # Filesystem endpoint: In-place repair of a file

## Tool: FingerprintScannerMS
Description: The Detective: Scans a directory tree and generates a deterministic
Functions:
  - scan_project(root_path)
    # Scans the project and returns a comprehensive state object

## Tool: CartridgeServiceMS
Description: The Source of Truth.
Functions:
  - get_vector_dim()
    # Retrieves the expected vector dimension from the manifest spec
  - initialize_manifest()
    # Populates the boot sector with strict RagFORGE Cartridge Schema (UNCF) v1
  - set_manifest(key, value)
    # Upsert metadata key
  - get_manifest(key)
    # Retrieve metadata key
  - validate_cartridge()
    # Quality Control: Checks if the cartridge is Agent-Safe
  - store_file(vfs_path, origin_path, content, blob, mime_type, origin_type)
    # The Universal Input Method
  - get_pending_files(limit)
    # Fetches files waiting for the Refinery
  - update_status(file_id, status, metadata)
  - ensure_directory(vfs_path)
    # Idempotent insert for VFS directories
  - get_status_flags()
    # Returns key manifest status flags in a single call
  - list_files(prefix, status, limit)
    # Enumerate files in the cartridge (optionally filtered by VFS prefix and/or status)
  - get_file_record(vfs_path)
    # Fetch a single file record by VFS path
  - list_directories(prefix)
    # Enumerate directories in the cartridge VFS
  - get_directory_tree(root)
    # Builds a nested directory tree starting at `root` ("" for full tree)
  - get_status_summary()
    # Counts files by status and provides a quick cartridge overview
  - add_node(node_id, node_type, label, data)
  - add_edge(source, target, relation, weight)
  - search_embeddings(query_vector, limit)
    # Performs semantic search using sqlite-vec

## Tool: SandboxManagerMS
Description: The Safety Harness: Manages a 'Sandbox' mirror of a 'Live' project.
Functions:
  - init_sandbox(force)
    # Creates or resets the sandbox by mirroring the live project
  - reset_sandbox()
    # Discards all sandbox changes and re-syncs from live
  - get_diff()
    # Compares Sandbox vs Live
  - promote_changes()
    # Applies changes from Sandbox to Live

## Tool: SearchEngineMS
Description: The Oracle: Performs Hybrid Search (Vector Similarity + Keyword Matching).
Functions:
  - search(db_path, query, limit)
    # Main entry point

## Tool: LibrarianMS
Description: No description.
Functions:
  - generate_catalog(output_file)

## Tool: LexicalSearchMS
Description: The Librarian's Index: A lightweight, AI-free search engine.
Functions:
  - add_document(doc_id, text, metadata)
    # Adds or updates a document in the index
  - search(query, top_k)
    # Performs a BM25 Ranked Search

## Tool: ArchiveBotMS
Description: No description.
Functions:
  - create_backup(source_path, output_dir, extra_exclusions, use_default_exclusions)

## Tool: CognitiveMemoryMS
Description: The Hippocampus: Manages Short-Term (Working) Memory and orchestrates 
Functions:
  - add_entry(role, content, metadata)
    # Adds an item to working memory and persists it
  - get_context(limit)
    # Returns the most recent conversation history formatted for an LLM
  - get_full_history()
    # Returns the raw list of memory objects
  - commit_turn()
    # Signal that a "Turn" (User + AI response) is complete

## Tool: CodeChunkerMS
Description: The Surgeon (Pure Python Edition): Splits code into semantic blocks
Functions:
  - chunk_file(file_path, max_chars)
    # Reads a file and breaks it into logical blocks based on indentation

## Tool: PromptVaultMS
Description: The Vault: A persistent SQLite store for managing, versioning, 
Functions:
  - create_template(slug, title, content, author, tags)
    # Creates a new prompt template with an initial version 1
  - add_version(slug, content, author)
    # Adds a new version to an existing template
  - get_template(slug)
    # Retrieves a full template with all history
  - render(slug, context)
    # Fetches the latest version and renders it with Jinja2
  - list_slugs()

## Tool: ThoughtStreamMS
Description: The Neural Inspector: A UI widget for displaying a stream of AI thoughts/logs
Functions:
  - add_thought_bubble(filename, chunk_id, content, vector_preview, color)
    # Mimics the 'InspectorFrame' from your React code

## Tool: NetworkLayoutMS
Description: The Topologist: Calculates visual coordinates for graph nodes using
Functions:
  - calculate_layout(nodes, edges, algorithm)
    # Computes (x, y) coordinates for the given graph

## Tool: NeuralServiceMS
Description: The Brain Interface: Orchestrates local AI operations via Ollama for inference and embeddings.
Functions:
  - update_models(fast_model, smart_model, embed_model)
    # Called by the UI Settings Modal to change models on the fly
  - get_available_models()
    # Fetches list from Ollama for the UI dropdown
  - check_connection()
    # Pings Ollama to see if it's alive
  - get_embedding(text)
    # Generates a vector using the configured embedding model
  - request_inference(prompt, tier, format_json)
    # Synchronous inference request
  - process_parallel(items, worker_func)
    # Helper to run a function across many items using a ThreadPool

## Tool: AuthMS
Description: ROLE: Simple authentication microservice providing username/password login
Functions:
  - login(username, password)
    # Attempt to log in with the provided username and password
  - validate_session(token)
    # Check if a serialized token is valid and not expired

## Tool: ContextPackerMS
Description: The Packer: Walks a directory and dumps all text-readable files 
Functions:
  - pack_directory(root_path, output_filename, additional_excludes)
    # Walks the directory and writes file contents to the output file

## Tool: RegexWeaverMS
Description: The Weaver: A fault-tolerant dependency extractor.
Functions:
  - extract_dependencies(content, language)
    # Scans code content for import statements

## Tool: TkinterThemeManagerMS
Description: The Stylist: Holds the color palette and font settings.
Functions:
  - get_theme()
  - update_key(key, value)

## Tool: CodeGrapherMS
Description: The Cartographer of Logic: Parses Python code to extract high-level 
Functions:
  - scan_directory(root_path)
    # Recursively scans a directory for

## Tool: ScannerMS
Description: The Scanner: Walks the file system, filters junk, and detects binary files.
Functions:
  - is_binary(file_path)
    # Determines if a file is binary using two heuristics:
1
  - scan_directory(root_path)
    # Recursively scans a directory and returns a JSON-compatible tree
  - flatten_tree(tree_node)
    # Helper to extract all valid file paths from a tree node 
(e

## Tool: ExplorerWidgetMS
Description: A standalone file system tree viewer.
Functions:
  - refresh_tree()
  - get_selected_paths()
  - process_gui_queue()

## Tool: RefineryServiceMS
Description: The Night Shift.
Functions:
  - get_health()
    # Returns the operational status of the RefineryServiceMS
  - process_pending(batch_size)
    # Main loop

## Tool: ContextAggregatorMS
Description: The Context Builder: Flattens a project folder into a single readable text file.
Functions:
  - aggregate(root_path, output_file, extra_exclusions, use_default_exclusions)

## Tool: LogViewMS
Description: The Console: A professional log viewer widget.
Functions:
  - clear()
  - save()

## Tool: TkinterUniButtonMS
Description: A generic button group that can merge ANY two actions.
Functions:

## Tool: SysInspectorMS
Description: The Auditor: Gathers hardware and environment statistics.
Functions:
  - generate_report()
    # Runs the full audit and returns a formatted string report

## Tool: IntakeServiceMS
Description: The Vacuum. 
Functions:
  - get_health()
    # Returns the operational status of the IntakeServiceMS
  - ingest_source(source_path)
    # Headless/CLI Entry point: Scans and Ingests in one go
  - scan_path(root_path, web_depth)
    # Unified Scanner Interface
  - ingest_selected(file_list, root_path)
    # Ingests only the specific files passed in the list
  - save_persistence(root_path, checked_map)
    # Saves user selections into the Cartridge Manifest (Portable)

## Tool: TkinterAppShellMS
Description: The Mother Ship.
Functions:
  - launch()
    # Ignition sequence start
  - get_main_container()
    # Other services call this to know where to
  - shutdown()

## Tool: RoleManagerMS
Description: The Casting Director: Manages Agent Personas (Roles).
Functions:
  - create_role(name, system_prompt, description, kbs)
    # Creates a new Agent Persona
  - get_role(name_or_id)
    # Retrieves a role by Name or ID
  - list_roles()
  - delete_role(name)

## Tool: SemanticChunkerMS
Description: Intelligent Code Splitter.
Functions:
  - chunk_file(content, filename)
    # Splits file content into chunks

## Tool: TkinterSmartExplorerMS
Description: The Navigator.
Functions:
  - load_data(data)
    # Ingests a dictionary tree (like from _ScoutMS or _TreeMapperMS)

## Tool: ScoutMS
Description: The Scanner: Walks file systems OR crawls websites (Depth-Aware).
Functions:
  - is_binary(file_path)
  - scan_directory(root_path, web_depth)
    # Main Entry Point
  - flatten_tree(tree_node)

## Tool: GitPilotMS
Description: No description.
Functions:
  - set_repo(path)

## Tool: NeuralGraphEngineMS
Description: No description.
Functions:
  - get_health()
    # Returns the operational status of the NeuralGraphEngineMS
  - resize(width, height)
  - set_data(nodes, links)
  - screen_to_world(sx, sy)
  - get_node_at(sx, sy)
  - handle_mouse_down(x, y)
  - handle_mouse_move(x, y, is_dragging)
  - handle_mouse_up()
  - pan(dx, dy)
  - zoom_camera(amount, mouse_x, mouse_y)
  - highlight_nodes(node_ids)
    # Highlights specific nodes by ID
  - step_physics()
  - get_image_bytes()

## Tool: LibrarianMS
Description: The Swarm Librarian.
Functions:
  - generate_catalog(output_file)
    # Main entry point

## Tool: ProjectForgeMS
Description: The Blacksmith.
Functions:
  - forge_project(parent_path, project_name, dependencies, project_type)
    # Stamps out a new project folder

## Tool: PromptOptimizerMS
Description: The Tuner: Uses an LLM to refine prompts or generate variations.
Functions:
  - refine_prompt(draft_prompt, feedback)
    # Rewrites a prompt based on feedback
  - generate_variations(draft_prompt, num_variations, context_data)
    # Generates multiple versions of a prompt for testing

## Tool: HeuristicSumMS
Description: The Skimmer: Generates quick summaries of code/text files without AI.
Functions:
  - summarize(text, filename, max_chars)
    # Generates a summary string from the provided text

## Tool: IngestEngineMS
Description: The Heavy Lifter: Reads files, chunks text, fetches embeddings,
Functions:
  - abort()
  - check_ollama_connection()
  - get_available_models()
  - process_files(file_paths, model_name)

## Tool: TextChunkerMS
Description: The Butcher: A unified service for splitting text into digestible chunks
Functions:
  - chunk_by_chars(text, chunk_size, chunk_overlap)
    # Standard Sliding Window
  - chunk_by_lines(text, max_lines, max_chars)
    # Line-Preserving Chunker

## Tool: IsoProcessMS
Description: The Safety Valve: Spawns isolated processes with real-time logging feedback.
Functions:
  - execute(payload, config)

## Tool: VectorFactoryMS
Description: The Switchboard: Returns the appropriate VectorStore implementation
Functions:
  - create(backend, config)
    # :param backend: 'faiss' or 'chroma'
:param config: Dict containing 'path', 'dim' (for FAISS), or 'collection' (for Chroma)

## Tool: MonacoHostMS
Description: Hosts the Monaco Editor.
Functions:
  - launch(title, width, height, func)
    # Create and launch the window
  - set_save_callback(callback)
    # Sets the function to trigger when Ctrl+S is pressed in the editor
  - open_file(filepath, content)
    # Opens a file in the editor (must be called from a background thread or callback)

## Tool: CodeJanitorMS
Description: No description.
Functions:
  - enforce_standards(dry_run)

## Tool: TasklistVaultMS
Description: The Taskmaster: A persistent SQLite engine for hierarchical task management.
Functions:
  - create_list(name)
    # Creates a new task list and returns its ID
  - get_lists()
    # Returns metadata for all task lists
  - add_task(list_id, content, parent_id)
    # Adds a task (or sub-task) to a list
  - update_task(task_id, content, status, result)
    # Updates a task's details
  - get_full_tree(list_id)
    # Fetches a list and reconstructs the full hierarchy of tasks
  - delete_list(list_id)

## Tool: WebScraperMS
Description: The Reader: Fetches URLs and extracts the main content using Readability.
Functions:
  - scrape(url)
    # Synchronous wrapper for fetching and cleaning a URL

## Tool: ChunkingRouterMS
Description: The Editor: A 'Recursive' text splitter.
Functions:
  - chunk_file(text, filename, max_size, overlap)
    # Extension-aware router

--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
# Standard Library dependencies only:
# tkinter, argparse, json, ast, threading, os, sys
#
# No external pip packages required.
--------------------------------------------------------------------------------
FILE: setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: src\app.py
--------------------------------------------------------------------------------
import sys
import os
import shutil
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from pathlib import Path
import json

# --- 1. PATH SETUP ---
current_dir = Path(__file__).resolve().parent
if str(current_dir) not in sys.path: sys.path.append(str(current_dir))
ms_dir = current_dir / "microservices"
if str(ms_dir) not in sys.path: sys.path.append(str(ms_dir))

# --- 2. IMPORTS ---
try:
    from microservices._TkinterAppShellMS import TkinterAppShellMS
    from microservices._TkinterThemeManagerMS import TkinterThemeManagerMS
    from microservices._ServiceRegistryMS import ServiceRegistryMS
    from microservices._ContextPackerMS import ContextPackerMS
except ImportError as e:
    # Graceful exit if dependencies are missing
    print(f"CRITICAL: Missing Core Microservices.\nError: {e}")
    sys.exit(1)

# --- 3. CONFIGURATION ---
try:
    # Try to find the library relative to this script
    PROJECT_ROOT = current_dir.parent.parent
    DETECTED_LIB_PATH = PROJECT_ROOT / "_MicroserviceLIBRARY"
except Exception:
    DETECTED_LIB_PATH = Path(r"C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_MicroserviceLIBRARY")
    
# Default to current dir if detection fails
DEFAULT_LIBRARY_PATH = DETECTED_LIB_PATH if DETECTED_LIB_PATH.exists() else Path(".")

# --- 4. THEME (Dark Steampunk) ---
COLORS = {
    "bg_dark": "#1b1b1b", "bg_panel": "#252526", "fg_text": "#e0c097",
    "fg_dim": "#858585", "accent": "#cd7f32", "accent_hover": "#ffd700",
    "select_bg": "#442d15", "success": "#50fa7b", "warning": "#ffb86c"
}

class SteampunkStyler:
    @staticmethod
    def apply(root):
        style = ttk.Style(root)
        style.theme_use('clam')
        style.configure(".", background=COLORS["bg_dark"], foreground=COLORS["fg_text"], font=("Consolas", 10))
        
        # Treeview (The List)
        style.configure("Treeview", background=COLORS["bg_panel"], foreground=COLORS["fg_text"], 
                        fieldbackground=COLORS["bg_panel"], borderwidth=0, font=("Consolas", 11))
        style.map("Treeview", background=[("selected", COLORS["select_bg"])], foreground=[("selected", COLORS["accent_hover"])])
        style.configure("Treeview.Heading", background=COLORS["bg_dark"], foreground=COLORS["accent"], font=("Consolas", 10, "bold"))
        
        # Buttons
        style.configure("TButton", background=COLORS["bg_panel"], foreground=COLORS["accent"], borderwidth=1, focusthickness=3)
        style.map("TButton", background=[("active", COLORS["select_bg"]), ("pressed", COLORS["accent"])], 
                  foreground=[("active", COLORS["accent_hover"]), ("pressed", COLORS["bg_dark"])])
        
        # Labels
        style.configure("Header.TLabel", foreground=COLORS["accent"], font=("Consolas", 12, "bold"))
        style.configure("Section.TLabel", foreground=COLORS["fg_dim"], font=("Consolas", 10, "italic"))

# --- 5. REPORT GENERATOR ---
class ReportGenerator:
    @staticmethod
    def agent_spec(services: list) -> str:
        """Generates a token-efficient Tool Definition list for LLMs."""
        lines = ["# TOOL DEFINITIONS (STRICT INTERFACE)", ""]
        for s in services:
            lines.append(f"## Tool: {s['name']}")
            # Grab only the first line of the docstring for brevity
            desc = s['description'].split(chr(10))[0] if s['description'] else "No description."
            lines.append(f"Description: {desc}")
            lines.append("Functions:")
            for m_name, m_data in s.get('methods', {}).items():
                args = ", ".join(m_data.get('args', []))
                lines.append(f"  - {m_name}({args})")
                if m_data.get('doc'):
                    doc_summary = m_data['doc'].split('.')[0].strip()
                    lines.append(f"    # {doc_summary}")
            lines.append("")
        return "\n".join(lines)

    @staticmethod
    def manifest(services: list) -> str:
        """Generates a high-level inventory list."""
        lines = ["# DEPLOYMENT MANIFEST", f"Total Services: {len(services)}", "-"*40]
        for s in services:
            desc = s['description'][:60] if s['description'] else "No description"
            lines.append(f"- [x] {s['name']} :: {desc}...")
        return "\n".join(lines)

# --- 6. MAIN APP ---
class MicroserviceBrowserApp:
    def __init__(self):
        self.theme_mgr = TkinterThemeManagerMS()
        self.registry_svc = ServiceRegistryMS()
        self.packer_svc = ContextPackerMS()
        
        self.library_root = DEFAULT_LIBRARY_PATH
        self.services_map = {} 
        self.checked_items = set() 
        
        self.app = TkinterAppShellMS({
            "theme_manager": self.theme_mgr,
            "title": "CORTEX COMPOSER [v2.2: Golden Master]",
            "geometry": "1400x900"
        })
        SteampunkStyler.apply(self.app.root)
        self.app.root.configure(bg=COLORS["bg_dark"])

        self.show_line_numbers = tk.BooleanVar(value=True)
        self.build_ui()
        
        # Auto-scan if valid, otherwise prompt user
        if self.library_root.exists(): 
            self.refresh_library()
        else:
            self.app.root.after(100, self.change_library)

    def build_ui(self):
        container = self.app.get_main_container()
        container.configure(bg=COLORS["bg_dark"])
        
        # --- HEADER ---
        deck = ttk.Frame(container, padding=10)
        deck.pack(fill="x")
        ttk.Label(deck, text="LIBRARY SOURCE:", style="Header.TLabel").pack(side="left")
        self.lbl_path = ttk.Label(deck, text=str(self.library_root), foreground=COLORS["fg_dim"])
        self.lbl_path.pack(side="left", padx=10)
        btn_frame = ttk.Frame(deck)
        btn_frame.pack(side="right")
        ttk.Button(btn_frame, text="[CHANGE PATH]", command=self.change_library).pack(side="left", padx=2)
        ttk.Button(btn_frame, text="[RE-SCAN]", command=self.refresh_library).pack(side="left", padx=2)

        paned = tk.PanedWindow(container, orient="horizontal", bg=COLORS["accent"], sashwidth=2, sashrelief="flat")
        paned.pack(fill="both", expand=True, padx=5, pady=5)
        
        # --- LEFT PANEL (Selection) ---
        left = ttk.Frame(paned)
        paned.add(left, width=400)
        
        # Selection Tools
        sel_row = ttk.Frame(left)
        sel_row.pack(fill="x", pady=5)
        ttk.Button(sel_row, text="ALL", width=5, command=self.select_all).pack(side="left", padx=1)
        ttk.Button(sel_row, text="NONE", width=5, command=self.select_none).pack(side="left", padx=1)
        ttk.Button(sel_row, text="INV", width=5, command=self.select_inverse).pack(side="left", padx=1)
        
        # Tree
        tree_frame = ttk.Frame(left)
        tree_frame.pack(fill="both", expand=True, pady=2)
        self.tree = ttk.Treeview(tree_frame, columns=("status"), show="tree", selectmode="browse")
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        self.tree.bind("<<TreeviewSelect>>", self.on_service_click)
        self.tree.bind("<Double-1>", self.on_service_toggle)

        # --- OPERATIONS DECK ---
        ops = ttk.LabelFrame(left, text="OPERATIONS DECK", padding=5)
        ops.pack(fill="x", pady=10)
        
        # 1. Deployment
        ttk.Label(ops, text="PHYSICAL DEPLOYMENT", style="Section.TLabel").pack(anchor="w")
        ttk.Button(ops, text="DEPLOY TO FOLDER...", command=self.deploy_files).pack(fill="x", pady=2)
        
        # 2. Reporting
        ttk.Label(ops, text="INTELLIGENT REPORTING", style="Section.TLabel").pack(anchor="w", pady=(10,0))
        ttk.Button(ops, text="COPY 'AGENT SPEC' (For LLMs)", command=self.copy_agent_spec).pack(fill="x", pady=2)
        ttk.Button(ops, text="COPY 'MANIFEST' (Summary)", command=self.copy_manifest).pack(fill="x", pady=2)
        ttk.Button(ops, text="COPY FULL CODE (Raw Dump)", command=self.copy_full_code).pack(fill="x", pady=2)

        # --- RIGHT PANEL (Viewer) ---
        right = ttk.Frame(paned)
        paned.add(right, width=800)
        
        view_head = ttk.Frame(right)
        view_head.pack(fill="x", pady=5)
        ttk.Label(view_head, text="SOURCE INSPECTOR", style="Header.TLabel").pack(side="left")
        ttk.Checkbutton(view_head, text="Line Numbers", variable=self.show_line_numbers, command=self.refresh_code_view).pack(side="right")

        self.txt_code = tk.Text(right, font=("Consolas", 11), bg=COLORS["bg_panel"], fg=COLORS["fg_text"], 
            insertbackground=COLORS["accent"], selectbackground=COLORS["select_bg"], wrap="none", undo=False, borderwidth=0)
        self.txt_code.pack(fill="both", expand=True)

    # --- CORE LOGIC ---

    def refresh_library(self):
        self.registry_svc.root = self.library_root
        self.tree.delete(*self.tree.get_children())
        self.services_map.clear()
        
        if not self.library_root.exists():
            messagebox.showerror("Error", f"Path not found: {self.library_root}")
            return

        registry_data = self.registry_svc.scan(save_to=None)
        
        for item in registry_data:
            name = item['name']
            iid = f"{name}_{item['path']}" if name in self.services_map else name
            self.services_map[iid] = item
            self.tree.insert("", "end", iid=iid, text=f"☐ {name}", tags=("unchecked",))
            
    def _get_selected_data(self):
        """Returns list of dicts for checked items."""
        return [self.services_map[iid] for iid in self.checked_items]

    # --- SELECTION HANDLING ---
    def on_service_toggle(self, event):
        item_id = self.tree.focus()
        if not item_id: return
        
        orig_name = self.services_map[item_id]['name']
        if item_id in self.checked_items:
            self.checked_items.remove(item_id)
            self.tree.item(item_id, text=f"☐ {orig_name}", tags=("unchecked",))
        else:
            self.checked_items.add(item_id)
            self.tree.item(item_id, text=f"☑ {orig_name}", tags=("checked",))

    def on_service_click(self, event):
        item_id = self.tree.focus()
        if not item_id: return
        data = self.services_map.get(item_id)
        if not data: return
        
        path = self.library_root / data['path']
        if path.exists():
            self.current_code_content = path.read_text(encoding="utf-8")
            self.refresh_code_view()

    def refresh_code_view(self):
        if not hasattr(self, 'current_code_content'): return
        content = self.current_code_content
        self.txt_code.delete("1.0", "end")
        if self.show_line_numbers.get():
            lines = [f"{i+1:03d} | {line}" for i, line in enumerate(content.splitlines())]
            self.txt_code.insert("1.0", "\n".join(lines))
        else:
            self.txt_code.insert("1.0", content)

    # --- BULK ACTIONS ---
    def select_all(self):
        for iid in self.services_map:
            if iid not in self.checked_items:
                self.checked_items.add(iid)
                self.tree.item(iid, text=f"☑ {self.services_map[iid]['name']}")

    def select_none(self):
        self.checked_items.clear()
        for iid in self.services_map:
            self.tree.item(iid, text=f"☐ {self.services_map[iid]['name']}")

    def select_inverse(self):
        new_set = set()
        for iid in self.services_map:
            if iid not in self.checked_items:
                new_set.add(iid)
                self.tree.item(iid, text=f"☑ {self.services_map[iid]['name']}")
            else:
                self.tree.item(iid, text=f"☐ {self.services_map[iid]['name']}")
        self.checked_items = new_set

    # --- OPERATIONS DECK ---

    def deploy_files(self):
        """Copies actual .py files to a selected directory with dependency safety."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services to deploy.")
        
        target_dir = filedialog.askdirectory(title="Select Target 'src/microservices' Folder")
        if not target_dir: return

        count = 0
        try:
            dest = Path(target_dir)
            
            # --- SAFETY INTERLOCK: Ensure Std Lib is present ---
            std_lib_name = "microservice_std_lib.py"
            std_lib_src = self.library_root / std_lib_name
            std_lib_dest = dest / std_lib_name
            
            if std_lib_src.exists() and not std_lib_dest.exists():
                shutil.copy2(std_lib_src, std_lib_dest)
                print(f"[Auto-Deploy] Copied dependency: {std_lib_name}")
            # ----------------------------------------------------

            for s in selection:
                src = self.library_root / s['path']
                if src.exists():
                    shutil.copy2(src, dest / src.name)
                    count += 1
            messagebox.showinfo("Deployed", f"Successfully deployed {count} microservices to:\n{dest}")
        except Exception as e:
            messagebox.showerror("Deployment Error", str(e))

    def copy_agent_spec(self):
        """Copies the lightweight API definition."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        report = ReportGenerator.agent_spec(selection)
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append(report)
        messagebox.showinfo("Copied", f"Agent Spec ({len(selection)} tools) copied to clipboard.")

    def copy_manifest(self):
        """Copies a high-level list."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        report = ReportGenerator.manifest(selection)
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append(report)
        messagebox.showinfo("Copied", "Manifest copied to clipboard.")

    def copy_full_code(self):
        """The old massive dump."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        output = ["# CONTEXT DUMP", "="*40]
        for s in selection:
            path = self.library_root / s['path']
            if path.exists():
                output.append(f"\n# FILE: {s['path']}\n" + "-"*40)
                output.append(path.read_text(encoding="utf-8"))
        
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append("\n".join(output))
        messagebox.showinfo("Copied", f"Full Source Code ({len(selection)} files) copied.")

    def change_library(self):
        path = filedialog.askdirectory(initialdir=self.library_root)
        if path:
            self.library_root = Path(path)
            self.lbl_path.config(text=str(self.library_root))
            self.refresh_library()

    def run(self):
        self.app.launch()

if __name__ == "__main__":
    browser = MicroserviceBrowserApp()
    browser.run()
--------------------------------------------------------------------------------
FILE: src\manifest-summary.txt
--------------------------------------------------------------------------------
import sys
import os
import shutil
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from pathlib import Path
import json

# --- 1. PATH SETUP ---
current_dir = Path(__file__).resolve().parent
if str(current_dir) not in sys.path: sys.path.append(str(current_dir))
ms_dir = current_dir / "microservices"
if str(ms_dir) not in sys.path: sys.path.append(str(ms_dir))

# --- 2. IMPORTS ---
try:
    from microservices._TkinterAppShellMS import TkinterAppShellMS
    from microservices._TkinterThemeManagerMS import TkinterThemeManagerMS
    from microservices._ServiceRegistryMS import ServiceRegistryMS
    from microservices._ContextPackerMS import ContextPackerMS
except ImportError as e:
    # Graceful exit if dependencies are missing
    print(f"CRITICAL: Missing Core Microservices.\nError: {e}")
    sys.exit(1)

# --- 3. CONFIGURATION ---
try:
    # Try to find the library relative to this script
    PROJECT_ROOT = current_dir.parent.parent
    DETECTED_LIB_PATH = PROJECT_ROOT / "_MicroserviceLIBRARY"
except Exception:
    DETECTED_LIB_PATH = Path(r"C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_MicroserviceLIBRARY")
    
# Default to current dir if detection fails
DEFAULT_LIBRARY_PATH = DETECTED_LIB_PATH if DETECTED_LIB_PATH.exists() else Path(".")

# --- 4. THEME (Dark Steampunk) ---
COLORS = {
    "bg_dark": "#1b1b1b", "bg_panel": "#252526", "fg_text": "#e0c097",
    "fg_dim": "#858585", "accent": "#cd7f32", "accent_hover": "#ffd700",
    "select_bg": "#442d15", "success": "#50fa7b", "warning": "#ffb86c"
}

class SteampunkStyler:
    @staticmethod
    def apply(root):
        style = ttk.Style(root)
        style.theme_use('clam')
        style.configure(".", background=COLORS["bg_dark"], foreground=COLORS["fg_text"], font=("Consolas", 10))
        
        # Treeview (The List)
        style.configure("Treeview", background=COLORS["bg_panel"], foreground=COLORS["fg_text"], 
                        fieldbackground=COLORS["bg_panel"], borderwidth=0, font=("Consolas", 11))
        style.map("Treeview", background=[("selected", COLORS["select_bg"])], foreground=[("selected", COLORS["accent_hover"])])
        style.configure("Treeview.Heading", background=COLORS["bg_dark"], foreground=COLORS["accent"], font=("Consolas", 10, "bold"))
        
        # Buttons
        style.configure("TButton", background=COLORS["bg_panel"], foreground=COLORS["accent"], borderwidth=1, focusthickness=3)
        style.map("TButton", background=[("active", COLORS["select_bg"]), ("pressed", COLORS["accent"])], 
                  foreground=[("active", COLORS["accent_hover"]), ("pressed", COLORS["bg_dark"])])
        
        # Labels
        style.configure("Header.TLabel", foreground=COLORS["accent"], font=("Consolas", 12, "bold"))
        style.configure("Section.TLabel", foreground=COLORS["fg_dim"], font=("Consolas", 10, "italic"))

# --- 5. REPORT GENERATOR ---
class ReportGenerator:
    @staticmethod
    def agent_spec(services: list) -> str:
        """Generates a token-efficient Tool Definition list for LLMs."""
        lines = ["# TOOL DEFINITIONS (STRICT INTERFACE)", ""]
        for s in services:
            lines.append(f"## Tool: {s['name']}")
            # Grab only the first line of the docstring for brevity
            desc = s['description'].split(chr(10))[0] if s['description'] else "No description."
            lines.append(f"Description: {desc}")
            lines.append("Functions:")
            for m_name, m_data in s.get('methods', {}).items():
                args = ", ".join(m_data.get('args', []))
                lines.append(f"  - {m_name}({args})")
                if m_data.get('doc'):
                    doc_summary = m_data['doc'].split('.')[0].strip()
                    lines.append(f"    # {doc_summary}")
            lines.append("")
        return "\n".join(lines)

    @staticmethod
    def manifest(services: list) -> str:
        """Generates a high-level inventory list."""
        lines = ["# DEPLOYMENT MANIFEST", f"Total Services: {len(services)}", "-"*40]
        for s in services:
            desc = s['description'][:60] if s['description'] else "No description"
            lines.append(f"- [x] {s['name']} :: {desc}...")
        return "\n".join(lines)

# --- 6. MAIN APP ---
class MicroserviceBrowserApp:
    def __init__(self):
        self.theme_mgr = TkinterThemeManagerMS()
        self.registry_svc = ServiceRegistryMS()
        self.packer_svc = ContextPackerMS()
        
        self.library_root = DEFAULT_LIBRARY_PATH
        self.services_map = {} 
        self.checked_items = set() 
        
        self.app = TkinterAppShellMS({
            "theme_manager": self.theme_mgr,
            "title": "CORTEX COMPOSER [v2.2: Golden Master]",
            "geometry": "1400x900"
        })
        SteampunkStyler.apply(self.app.root)
        self.app.root.configure(bg=COLORS["bg_dark"])

        self.show_line_numbers = tk.BooleanVar(value=True)
        self.build_ui()
        
        # Auto-scan if valid, otherwise prompt user
        if self.library_root.exists(): 
            self.refresh_library()
        else:
            self.app.root.after(100, self.change_library)

    def build_ui(self):
        container = self.app.get_main_container()
        container.configure(bg=COLORS["bg_dark"])
        
        # --- HEADER ---
        deck = ttk.Frame(container, padding=10)
        deck.pack(fill="x")
        ttk.Label(deck, text="LIBRARY SOURCE:", style="Header.TLabel").pack(side="left")
        self.lbl_path = ttk.Label(deck, text=str(self.library_root), foreground=COLORS["fg_dim"])
        self.lbl_path.pack(side="left", padx=10)
        btn_frame = ttk.Frame(deck)
        btn_frame.pack(side="right")
        ttk.Button(btn_frame, text="[CHANGE PATH]", command=self.change_library).pack(side="left", padx=2)
        ttk.Button(btn_frame, text="[RE-SCAN]", command=self.refresh_library).pack(side="left", padx=2)

        paned = tk.PanedWindow(container, orient="horizontal", bg=COLORS["accent"], sashwidth=2, sashrelief="flat")
        paned.pack(fill="both", expand=True, padx=5, pady=5)
        
        # --- LEFT PANEL (Selection) ---
        left = ttk.Frame(paned)
        paned.add(left, width=400)
        
        # Selection Tools
        sel_row = ttk.Frame(left)
        sel_row.pack(fill="x", pady=5)
        ttk.Button(sel_row, text="ALL", width=5, command=self.select_all).pack(side="left", padx=1)
        ttk.Button(sel_row, text="NONE", width=5, command=self.select_none).pack(side="left", padx=1)
        ttk.Button(sel_row, text="INV", width=5, command=self.select_inverse).pack(side="left", padx=1)
        
        # Tree
        tree_frame = ttk.Frame(left)
        tree_frame.pack(fill="both", expand=True, pady=2)
        self.tree = ttk.Treeview(tree_frame, columns=("status"), show="tree", selectmode="browse")
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        self.tree.bind("<<TreeviewSelect>>", self.on_service_click)
        self.tree.bind("<Double-1>", self.on_service_toggle)

        # --- OPERATIONS DECK ---
        ops = ttk.LabelFrame(left, text="OPERATIONS DECK", padding=5)
        ops.pack(fill="x", pady=10)
        
        # 1. Deployment
        ttk.Label(ops, text="PHYSICAL DEPLOYMENT", style="Section.TLabel").pack(anchor="w")
        ttk.Button(ops, text="DEPLOY TO FOLDER...", command=self.deploy_files).pack(fill="x", pady=2)
        
        # 2. Reporting
        ttk.Label(ops, text="INTELLIGENT REPORTING", style="Section.TLabel").pack(anchor="w", pady=(10,0))
        ttk.Button(ops, text="COPY 'AGENT SPEC' (For LLMs)", command=self.copy_agent_spec).pack(fill="x", pady=2)
        ttk.Button(ops, text="COPY 'MANIFEST' (Summary)", command=self.copy_manifest).pack(fill="x", pady=2)
        ttk.Button(ops, text="COPY FULL CODE (Raw Dump)", command=self.copy_full_code).pack(fill="x", pady=2)

        # --- RIGHT PANEL (Viewer) ---
        right = ttk.Frame(paned)
        paned.add(right, width=800)
        
        view_head = ttk.Frame(right)
        view_head.pack(fill="x", pady=5)
        ttk.Label(view_head, text="SOURCE INSPECTOR", style="Header.TLabel").pack(side="left")
        ttk.Checkbutton(view_head, text="Line Numbers", variable=self.show_line_numbers, command=self.refresh_code_view).pack(side="right")

        self.txt_code = tk.Text(right, font=("Consolas", 11), bg=COLORS["bg_panel"], fg=COLORS["fg_text"], 
            insertbackground=COLORS["accent"], selectbackground=COLORS["select_bg"], wrap="none", undo=False, borderwidth=0)
        self.txt_code.pack(fill="both", expand=True)

    # --- CORE LOGIC ---

    def refresh_library(self):
        self.registry_svc.root = self.library_root
        self.tree.delete(*self.tree.get_children())
        self.services_map.clear()
        
        if not self.library_root.exists():
            messagebox.showerror("Error", f"Path not found: {self.library_root}")
            return

        registry_data = self.registry_svc.scan(save_to=None)
        
        for item in registry_data:
            name = item['name']
            iid = f"{name}_{item['path']}" if name in self.services_map else name
            self.services_map[iid] = item
            self.tree.insert("", "end", iid=iid, text=f"☐ {name}", tags=("unchecked",))
            
    def _get_selected_data(self):
        """Returns list of dicts for checked items."""
        return [self.services_map[iid] for iid in self.checked_items]

    # --- SELECTION HANDLING ---
    def on_service_toggle(self, event):
        item_id = self.tree.focus()
        if not item_id: return
        
        orig_name = self.services_map[item_id]['name']
        if item_id in self.checked_items:
            self.checked_items.remove(item_id)
            self.tree.item(item_id, text=f"☐ {orig_name}", tags=("unchecked",))
        else:
            self.checked_items.add(item_id)
            self.tree.item(item_id, text=f"☑ {orig_name}", tags=("checked",))

    def on_service_click(self, event):
        item_id = self.tree.focus()
        if not item_id: return
        data = self.services_map.get(item_id)
        if not data: return
        
        path = self.library_root / data['path']
        if path.exists():
            self.current_code_content = path.read_text(encoding="utf-8")
            self.refresh_code_view()

    def refresh_code_view(self):
        if not hasattr(self, 'current_code_content'): return
        content = self.current_code_content
        self.txt_code.delete("1.0", "end")
        if self.show_line_numbers.get():
            lines = [f"{i+1:03d} | {line}" for i, line in enumerate(content.splitlines())]
            self.txt_code.insert("1.0", "\n".join(lines))
        else:
            self.txt_code.insert("1.0", content)

    # --- BULK ACTIONS ---
    def select_all(self):
        for iid in self.services_map:
            if iid not in self.checked_items:
                self.checked_items.add(iid)
                self.tree.item(iid, text=f"☑ {self.services_map[iid]['name']}")

    def select_none(self):
        self.checked_items.clear()
        for iid in self.services_map:
            self.tree.item(iid, text=f"☐ {self.services_map[iid]['name']}")

    def select_inverse(self):
        new_set = set()
        for iid in self.services_map:
            if iid not in self.checked_items:
                new_set.add(iid)
                self.tree.item(iid, text=f"☑ {self.services_map[iid]['name']}")
            else:
                self.tree.item(iid, text=f"☐ {self.services_map[iid]['name']}")
        self.checked_items = new_set

    # --- OPERATIONS DECK ---

    def deploy_files(self):
        """Copies actual .py files to a selected directory with dependency safety."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services to deploy.")
        
        target_dir = filedialog.askdirectory(title="Select Target 'src/microservices' Folder")
        if not target_dir: return

        count = 0
        try:
            dest = Path(target_dir)
            
            # --- SAFETY INTERLOCK: Ensure Std Lib is present ---
            std_lib_name = "microservice_std_lib.py"
            std_lib_src = self.library_root / std_lib_name
            std_lib_dest = dest / std_lib_name
            
            if std_lib_src.exists() and not std_lib_dest.exists():
                shutil.copy2(std_lib_src, std_lib_dest)
                print(f"[Auto-Deploy] Copied dependency: {std_lib_name}")
            # ----------------------------------------------------

            for s in selection:
                src = self.library_root / s['path']
                if src.exists():
                    shutil.copy2(src, dest / src.name)
                    count += 1
            messagebox.showinfo("Deployed", f"Successfully deployed {count} microservices to:\n{dest}")
        except Exception as e:
            messagebox.showerror("Deployment Error", str(e))

    def copy_agent_spec(self):
        """Copies the lightweight API definition."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        report = ReportGenerator.agent_spec(selection)
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append(report)
        messagebox.showinfo("Copied", f"Agent Spec ({len(selection)} tools) copied to clipboard.")

    def copy_manifest(self):
        """Copies a high-level list."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        report = ReportGenerator.manifest(selection)
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append(report)
        messagebox.showinfo("Copied", "Manifest copied to clipboard.")

    def copy_full_code(self):
        """The old massive dump."""
        selection = self._get_selected_data()
        if not selection: return messagebox.showwarning("Empty", "Select services first.")
        
        output = ["# CONTEXT DUMP", "="*40]
        for s in selection:
            path = self.library_root / s['path']
            if path.exists():
                output.append(f"\n# FILE: {s['path']}\n" + "-"*40)
                output.append(path.read_text(encoding="utf-8"))
        
        self.app.root.clipboard_clear()
        self.app.root.clipboard_append("\n".join(output))
        messagebox.showinfo("Copied", f"Full Source Code ({len(selection)} files) copied.")

    def change_library(self):
        path = filedialog.askdirectory(initialdir=self.library_root)
        if path:
            self.library_root = Path(path)
            self.lbl_path.config(text=str(self.library_root))
            self.refresh_library()

    def run(self):
        self.app.launch()

if __name__ == "__main__":
    browser = MicroserviceBrowserApp()
    browser.run()
--------------------------------------------------------------------------------
FILE: src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\microservice_std_lib.py
--------------------------------------------------------------------------------
"""
LIBRARY: Microservice Standard Lib
VERSION: 2.0.0
ROLE: Provides decorators for tagging Python classes as AI-discoverable services.
"""

import functools
import inspect
from typing import Dict, List, Any, Optional, Type

# ==============================================================================
# DECORATORS (The "Writer" Tools)
# ==============================================================================

def service_metadata(name: str, version: str, description: str, tags: List[str], capabilities: List[str] = None, dependencies: List[str] = None, side_effects: List[str] = None):
    """
    Class Decorator.
    Labels a Microservice class with high-level metadata for the Catalog.
    """
    def decorator(cls):
        cls._is_microservice = True
        cls._service_info = {
            "name": name,
            "version": version,
            "description": description,
            "tags": tags,
            "capabilities": capabilities or [],
            "dependencies": dependencies or [],
            "side_effects": side_effects or []
        }
        return cls
    return decorator

def service_endpoint(inputs: Dict[str, str], outputs: Dict[str, str], description: str, tags: List[str] = None, side_effects: List[str] = None, mode: str = "sync"):
    """
    Method Decorator.
    Defines the 'Socket' that the AI Architect can plug into.
    
    :param inputs: Dict of {arg_name: type_string} (e.g. {"query": "str"})
    :param outputs: Dict of {return_name: type_string} (e.g. {"results": "List[Dict]"})
    :param description: What this specific function does.
    :param tags: Keywords for searching (e.g. ["search", "read-only"])
    :param side_effects: List of impact types (e.g. ["network:outbound", "disk:write"])
    :param mode: 'sync', 'async', or 'ui_event'
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        
        # Attach metadata to the function object itself
        wrapper._endpoint_info = {
            "name": func.__name__,
            "inputs": inputs,
            "outputs": outputs,
            "description": description,
            "tags": tags or [],
            "side_effects": side_effects or [],
            "mode": mode
        }
        return wrapper
    return decorator

# ==============================================================================
# INTROSPECTION (The "Reader" Tools)
# ==============================================================================

def extract_service_schema(service_cls: Type) -> Dict[str, Any]:
    """
    Scans a decorated Service Class and returns a JSON-serializable schema 
    of its metadata and all its exposed endpoints.
    
    This is what the AI Agent uses to 'read' the manual.
    """
    if not getattr(service_cls, "_is_microservice", False):
        raise ValueError(f"Class {service_cls.__name__} is not decorated with @service_metadata")

    schema = {
        "meta": getattr(service_cls, "_service_info", {}),
        "endpoints": []
    }

    # Inspect all methods of the class
    for name, method in inspect.getmembers(service_cls, predicate=inspect.isfunction):
        # Unwrap decorators if necessary to find our tags
        # (Though usually the wrapper has the tag attached)
        endpoint_info = getattr(method, "_endpoint_info", None)
        
        if endpoint_info:
            schema["endpoints"].append(endpoint_info)

    return schema

--------------------------------------------------------------------------------
FILE: src\microservices\_ContextPackerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _ContextPackerMS
ENTRY_POINT: _ContextPackerMS.py
DEPENDENCIES: None
"""

import os
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional, Set

from microservice_std_lib import service_metadata, service_endpoint

# ==============================================================================
# CONFIGURATION
# ==============================================================================
DEFAULT_EXCLUDES = {
    '.git', '__pycache__', '.idea', '.vscode', 'node_modules', 
    'venv', '.venv', 'dist', 'build', '.DS_Store', 'file-dump.txt'
}

logger = logging.getLogger("ContextPacker")

# ==============================================================================
# MICROSERVICE CLASS
# ==============================================================================

@service_metadata(
    name="ContextPacker",
    version="1.0.0",
    description="Flattens a directory of source code into a single text file (useful for LLM context stuffing).",
    tags=["filesystem", "export", "utility"],
    capabilities=["filesystem:read", "filesystem:write"]
)
class ContextPackerMS:
    """
    The Packer: Walks a directory and dumps all text-readable files 
    into a single monolithic text file with delimiters.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}

    @service_endpoint(
        inputs={"root_path": "str", "output_filename": "str", "additional_excludes": "Set[str]"},
        outputs={"output_path": "str", "file_count": "int"},
        description="Packs directory contents into a single text file.",
        tags=["export", "dump"],
        side_effects=["filesystem:read", "filesystem:write"]
    )
    def pack_directory(self, 
                       root_path: str, 
                       output_filename: str = "context_dump.txt", 
                       additional_excludes: Optional[Set[str]] = None) -> Dict[str, Any]:
        """
        Walks the directory and writes file contents to the output file.
        """
        root = Path(root_path).resolve()
        output_file = root / output_filename
        
        # Merge excludes
        excludes = DEFAULT_EXCLUDES.copy()
        if additional_excludes:
            excludes.update(additional_excludes)
            
        # Ensure we don't pack the output file itself if it already exists
        excludes.add(output_filename)

        count = 0
        logger.info(f"Packing context from {root} into {output_filename}...")

        try:
            with open(output_file, 'w', encoding='utf-8') as out_f:
                # Add Header
                out_f.write(f"CONTEXT PACKER DUMP\n")
                out_f.write(f"SOURCE: {root}\n")
                out_f.write("="*60 + "\n\n")

                for current_dir, dirs, files in os.walk(root):
                    # In-place modification of dirs to skip excluded folders during walk
                    dirs[:] = [d for d in dirs if d not in excludes and not d.startswith('.')]
                    
                    for file in files:
                        if file in excludes or file.startswith('.'):
                            continue
                            
                        file_path = Path(current_dir) / file
                        
                        # Process the file
                        self._append_file(file_path, root, out_f)
                        count += 1
                        
            return {
                "output_path": str(output_file),
                "file_count": count
            }
            
        except Exception as e:
            logger.error(f"Packing failed: {e}")
            raise

    def _append_file(self, file_path: Path, root: Path, out_f):
        """Helper to append a single file's content to the dump."""
        rel_path = file_path.relative_to(root)
        
        try:
            # Try reading as text
            content = file_path.read_text(encoding='utf-8')
            
            out_f.write(f"==================================================\n")
            out_f.write(f"FILE: {rel_path}\n")
            out_f.write(f"==================================================\n")
            out_f.write(content + "\n\n")
            
        except UnicodeDecodeError:
            # It's a binary file (image, pyc, etc.)
            out_f.write(f"==================================================\n")
            out_f.write(f"FILE: {rel_path} [SKIPPED - BINARY]\n")
            out_f.write(f"==================================================\n\n")
        except Exception as e:
            logger.warning(f"Could not read {rel_path}: {e}")


# --- Independent Test Block ---
if __name__ == "__main__":
    # Setup logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')

    packer = ContextPackerMS()
    print("Service ready:", packer)
    
    # Run a test pack on the current folder
    print("\n--- Packing Current Directory ---")
    result = packer.pack_directory(".", "test_dump.txt")
    print(f"Packed {result['file_count']} files to: {result['output_path']}")

--------------------------------------------------------------------------------
FILE: src\microservices\_ServiceRegistryMS.py
--------------------------------------------------------------------------------
import ast
import json
import uuid
import os
import re
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional

from microservice_std_lib import service_metadata, service_endpoint

# ==============================================================================
# CONFIGURATION
# ==============================================================================
OUTPUT_FILE = "registry.json"
logger = logging.getLogger("ServiceRegistry")

# ==============================================================================
# MICROSERVICE CLASS
# ==============================================================================

@service_metadata(
    name="ServiceRegistry",
    version="1.0.0",
    description="Scans a library of Python microservices and generates standardized JSON Service Tokens.",
    tags=["introspection", "registry", "parsing"],
    capabilities=["filesystem:read", "filesystem:write"]
)
class ServiceRegistryMS:
    """
    The Tokenizer (v2): Scans a library of Python microservices and generates
    standardized JSON 'Service Tokens'.
    Feature: Hybrid AST/Regex parsing for maximum robustness.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        # Default to current directory if not specified
        self.root = Path(self.config.get("root_path", ".")).resolve()
        self.registry = []

    @service_endpoint(
        inputs={"save_to": "str"},
        outputs={"registry": "List[Dict]"},
        description="Scans the file system for microservices and builds a registry.",
        tags=["introspection", "scan"],
        side_effects=["filesystem:read", "filesystem:write"]
    )
    def scan(self, save_to: str = OUTPUT_FILE) -> List[Dict[str, Any]]:
        logger.info(f"Scanning for microservices in: {self.root}")
        self.registry = [] # Reset registry
        
        # 1. Walk directories/files
        if self.root.exists():
            for item in self.root.iterdir():
                # Check for Service Folders (e.g. _AuthMS)
                if item.is_dir() and item.name.startswith("_") and item.name.endswith("MS"):
                    self._process_folder(item)
                # Check for Service Files (e.g. __AuthMS.py)
                elif item.is_file() and item.name.startswith("_") and item.name.endswith("MS.py"):
                    token = self._tokenize_file(item)
                    if token:
                        self.registry.append(token)
        
        # 2. Save Registry
        if save_to:
            try:
                with open(save_to, "w", encoding="utf-8") as f:
                    json.dump(self.registry, f, indent=2)
                logger.info(f"✅ Registry built. Found {len(self.registry)} services. Saved to {save_to}")
            except Exception as e:
                logger.error(f"Failed to save registry: {e}")
            
        return self.registry

    def _process_folder(self, folder: Path):
        # Find the main .py file (usually matches folder name, or is the only .py file)
        candidates = list(folder.glob("*.py"))
        for file in candidates:
            # Usually entry points start with __ inside the folder
            if file.name.startswith("__") or len(candidates) == 1:
                token = self._tokenize_file(file)
                if token:
                    self.registry.append(token)
                    logger.info(f"  + Tokenized: {token['name']}")
                    break 

    def _tokenize_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                source = f.read()
            
            # Attempt 1: Strict AST Parsing (The "Right" Way)
            try:
                return self._ast_parse(source, file_path)
            except Exception:
                # Attempt 2: Regex Fallback (The "Survival" Way)
                return self._regex_parse(source, file_path)
                
        except Exception as e:
            logger.warning(f"  - Failed to read {file_path.name}: {e}")
            return None

    def _ast_parse(self, source: str, file_path: Path):
        tree = ast.parse(source)
        target_class = None
        
        # Find class ending in 'MS'
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef) and node.name.endswith("MS"):
                target_class = node
                break
        
        if not target_class: return None

        # Extract Metadata
        return self._build_token(
            name=target_class.name,
            doc=ast.get_docstring(target_class) or "",
            methods=[
                (n.name, [a.arg for a in n.args.args if a.arg != 'self'], ast.get_docstring(n) or "")
                for n in target_class.body if isinstance(n, ast.FunctionDef) and not n.name.startswith("_")
            ],
            deps=self._extract_ast_imports(tree),
            file_path=file_path
        )

    def _regex_parse(self, source: str, file_path: Path):
        # Find class definition
        class_match = re.search(r'class\s+(\w+MS)', source)
        if not class_match: return None
        name = class_match.group(1)
        
        # Find methods (def name(args):)
        methods = []
        for match in re.finditer(r'def\s+(\w+)\s*\((.*?)\):', source):
            m_name = match.group(1)
            if not m_name.startswith("_"):
                # Rough args parsing
                args = [a.strip().split(':')[0] for a in match.group(2).split(',') if a.strip() != 'self']
                methods.append((m_name, args, "Regex extracted"))
                
        return self._build_token(name, "Parsed via Regex", methods, [], file_path)

    def _build_token(self, name, doc, methods, deps, file_path):
        # Generate deterministic ID
        namespace = uuid.uuid5(uuid.NAMESPACE_DNS, "microservice.library")
        token_id = f"MS_{uuid.uuid5(namespace, name).hex[:8].upper()}"
        
        method_dict = {
            m_name: {"args": m_args, "doc": m_doc.strip()} 
            for m_name, m_args, m_doc in methods
        }
        
        try:
            rel_path = str(file_path.relative_to(self.root)).replace('\\', '/')
        except ValueError:
            rel_path = file_path.name

        return {
            "token_id": token_id,
            "name": name,
            "path": rel_path,
            "description": doc.strip(),
            "methods": method_dict,
            "dependencies": sorted(deps)
        }

    def _extract_ast_imports(self, tree):
        deps = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for n in node.names: deps.add(n.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module: deps.add(node.module.split('.')[0])
        return list(deps)


if __name__ == "__main__":
    # Setup logging for independent test
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    
    svc = ServiceRegistryMS()
    print("Service ready:", svc)
    # Perform a test scan of the current directory
    svc.scan()

--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterAppShellMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterAppShellMS
ENTRY_POINT: _TkinterAppShellMS.py
DEPENDENCIES: None
"""
import tkinter as tk
from tkinter import ttk
import logging
from typing import Dict, Any, Optional

from microservice_std_lib import service_metadata, service_endpoint

# Updated Import: Single Underscore + 'Tkinter' prefix
try:
    from _TkinterThemeManagerMS import TkinterThemeManagerMS
except ImportError:
    TkinterThemeManagerMS = None

logger = logging.getLogger("AppShell")

@service_metadata(
    name="TkinterAppShell",
    version="2.0.0",
    description="The Application Container. Manages the root window, main loop, and global layout.",
    tags=["ui", "core", "lifecycle"],
    capabilities=["ui:root", "ui:gui"]
)
class TkinterAppShellMS:
    """
    The Mother Ship.
    Owns the Tkinter Root. All other UI microservices dock into this.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.root = tk.Tk()
        self.root.withdraw() # Hide until launch
        
        # Load Theme (Inject dependency or create new)
        self.theme_svc = self.config.get("theme_manager")
        if not self.theme_svc and TkinterThemeManagerMS:
            self.theme_svc = TkinterThemeManagerMS()
            
        self.colors = self.theme_svc.get_theme() if self.theme_svc else {}
        self._configure_root()
        
    def _configure_root(self):
        self.root.title(self.config.get("title", "Microservice OS"))
        self.root.geometry(self.config.get("geometry", "1200x800"))
        
        # Apply Base Theme
        bg = self.colors.get('background', '#1e1e1e')
        self.root.configure(bg=bg)
        
        # Configure TTK Styles globally
        style = ttk.Style()
        style.theme_use('clam')
        
        # Standard Frames
        style.configure('TFrame', background=bg)
        style.configure('TLabel', background=bg, foreground=self.colors.get('foreground', '#ccc'))
        style.configure('TButton', background=self.colors.get('panel_bg', '#333'), foreground='white')
        
        # Main Container (Grid or Pack)
        self.main_container = tk.Frame(self.root, bg=bg)
        self.main_container.pack(fill="both", expand=True, padx=5, pady=5)

    @service_endpoint(
        inputs={},
        outputs={},
        description="Starts the GUI Main Loop.",
        tags=["lifecycle", "start"],
        mode="sync",
        side_effects=["ui:block"]
    )
    def launch(self):
        """Ignition sequence start."""
        self.root.deiconify()
        logger.info("AppShell Launched.")
        self.root.mainloop()

    @service_endpoint(
        inputs={},
        outputs={"container": "tk.Frame"},
        description="Returns the main content area for other services to dock into.",
        tags=["ui", "layout"]
    )
    def get_main_container(self):
        """Other services call this to know where to .pack() themselves."""
        return self.main_container

    @service_endpoint(
        inputs={},
        outputs={},
        description="Gracefully shuts down the application.",
        tags=["lifecycle", "stop"],
        side_effects=["ui:close"]
    )
    def shutdown(self):
        self.root.quit()

if __name__ == "__main__":
    shell = TkinterAppShellMS({"title": "Test Shell"})
    shell.launch()
--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterThemeManagerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterThemeManagerMS
ENTRY_POINT: _TkinterThemeManagerMS.py
DEPENDENCIES: None
"""
from typing import Dict, Any, Optional
from microservice_std_lib import service_metadata, service_endpoint

# Default "Dark Modern" Theme
DEFAULT_THEME = {
    'background': '#1e1e1e',
    'foreground': '#d4d4d4',
    'panel_bg':   '#252526',
    'border':     '#3c3c3c',
    'accent':     '#007acc',
    'error':      '#f48771',
    'success':    '#89d185',
    'font_main':  ('Segoe UI', 10),
    'font_mono':  ('Consolas', 10)
}

@service_metadata(
    name="TkinterThemeManager",
    version="1.0.0",
    description="Centralized configuration for UI colors and fonts.",
    tags=["ui", "config", "theme"],
    capabilities=["ui:style"]
)
class TkinterThemeManagerMS:
    """
    The Stylist: Holds the color palette and font settings.
    All UI components query this service to decide how to draw themselves.
    """
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.theme = DEFAULT_THEME.copy()
        
        # Allow override from config
        if "overrides" in self.config:
            self.theme.update(self.config["overrides"])

    @service_endpoint(
        inputs={},
        outputs={"theme": "Dict"},
        description="Returns the current active theme dictionary.",
        tags=["ui", "read"]
    )
    def get_theme(self) -> Dict[str, Any]:
        return self.theme

    @service_endpoint(
        inputs={"key": "str", "value": "Any"},
        outputs={},
        description="Updates a specific theme attribute (e.g., changing accent color).",
        tags=["ui", "write"],
        side_effects=["ui:refresh"]
    )
    def update_key(self, key: str, value: Any):
        self.theme[key] = value

if __name__ == "__main__":
    svc = TkinterThemeManagerMS()
    print("Theme Ready:", svc.get_theme()['accent'])