Dump: C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_RagFORGE


--------------------------------------------------------------------------------
FILE: LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
# --- Critical UI/Graphing ---
pygame-ce>=2.3.0
Pillow>=10.0.0

# --- Networking/AI ---
requests>=2.30.0

# --- Database Extensions ---
# (Ensure your Python environment supports installing this, 
# otherwise you may need to manually place the DLL/SO)
sqlite-vec>=0.1.0

# --- Document Processing ---
pypdf>=3.0.0
beautifulsoup4>=4.12.0
--------------------------------------------------------------------------------
FILE: setup_env.bat
--------------------------------------------------------------------------------
@echo off
echo [SYSTEM] Initializing new project environment...

:: 1. Create the venv if it doesn't exist
if not exist .venv (
    echo [SYSTEM] Creating .venv...
    py -m venv .venv
)

:: 2. Upgrade pip and install requirements
echo [SYSTEM] Installing dependencies...
.venv\Scripts\python.exe -m pip install --upgrade pip
if exist requirements.txt (
    .venv\Scripts\pip install -r requirements.txt
)

echo.
echo [SUCCESS] Environment ready!
echo You can now open this folder in VS Code or launch via scripts_menu.py
pause
--------------------------------------------------------------------------------
FILE: src\app.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
== _RagFORGE: Neural Cartridge Factory ==
"""

# 1. IMPORTS
import sys
import os

# --- PATH PATCH START ---
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)
# --- PATH PATCH END ---

import argparse
import threading
import tkinter as tk
from tkinter import ttk, messagebox

# Microservices
from microservices.base_service import BaseService
from microservices.cartridge_service import CartridgeService
from microservices.neural_service import NeuralService
from microservices.intake_service import IntakeService
from microservices.refinery_service import RefineryService

# UI Components
from microservices.panels import (
    Sidebar,
    IngestToolbar,
    FileTreePanel,
    EditorPanel,
    SystemLog,
)
from microservices.graph_view import GraphView
from microservices.thought_stream import ThoughtStream

# 2. CONSTANTS
APP_TITLE = "_RagFORGE v1.0"
STORAGE_DIR = "./cartridges"
BG_COLOR = "#1e1e2f"


# 3. CORE FUNCTIONALITY (Headless Logic)

def headless_forge(source_path: str, db_name: str, verbose: bool = False):
    """CLI Entry point for automated cartridge creation."""
    if not db_name.endswith(".db"):
        db_name += ".db"

    db_path = os.path.join(STORAGE_DIR, db_name)

    print(f"[FORGE] Target Cartridge: {db_path}")
    print(f"[FORGE] Source Material: {source_path}")

    cartridge = CartridgeService(db_path)
    neural = NeuralService()
    intake = IntakeService(cartridge)
    refinery = RefineryService(cartridge, neural)

    print(">>> Phase 1: Intake (Vacuuming files...)")
    stats = intake.ingest_source(source_path)
    print(f"    Intake Result: {stats}")

    print(">>> Phase 2: Refinery (Chunking & Weaving...)")
    while True:
        processed = refinery.process_pending(batch_size=10)
        if processed == 0:
            break
        if verbose:
            print(f"    Refined batch of {processed}...")

    print(f"[SUCCESS] Cartridge forged at {db_path}")
    return db_path


# 4. GUI LOGIC (The Workstation)

class RagForgeApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.geometry("1200x800")
        self.configure(bg=BG_COLOR)

        self.neural = NeuralService()
        self.active_cartridge = None
        self.active_db_path = None
        self.refining = False

        self._apply_cyberpunk_theme()
        self._setup_ui()

    def _apply_cyberpunk_theme(self):
        """Injects the Dark/Cyberpunk visual style globally."""
        style = ttk.Style(self)

        try:
            style.theme_use("clam")
        except Exception:
            pass

        dark_bg = "#1e1e2f"
        darker_bg = "#151515"
        text_fg = "#e0e0e0"
        accent = "#007ACC"
        border = "#333344"

        # Treeviews
        style.configure(
            "Treeview",
            background=darker_bg,
            fieldbackground=darker_bg,
            foreground=text_fg,
            borderwidth=0,
            rowheight=26,
            font=("Segoe UI", 10),
        )
        style.map(
            "Treeview",
            background=[("selected", accent)],
            foreground=[("selected", "white")],
        )

        style.configure(
            "Treeview.Heading",
            background=dark_bg,
            foreground="#888",
            relief="flat",
            font=("Segoe UI", 9, "bold"),
        )
        style.map(
            "Treeview.Heading",
            background=[("active", "#2d2d44")],
        )

        # Scrollbars
        style.configure(
            "Vertical.TScrollbar",
            gripcount=0,
            background="#2d2d44",
            darkcolor=dark_bg,
            lightcolor=dark_bg,
            troughcolor=dark_bg,
            bordercolor=dark_bg,
            arrowcolor="#888",
        )
        style.map(
            "Vertical.TScrollbar",
            background=[("active", "#444"), ("disabled", dark_bg)],
        )

        # Tabs
        style.configure(
            "TNotebook",
            background=dark_bg,
            borderwidth=0,
        )
        style.configure(
            "TNotebook.Tab",
            background="#252526",
            foreground="#888",
            padding=[15, 8],
            font=("Segoe UI", 10),
        )
        style.map(
            "TNotebook.Tab",
            background=[("selected", accent)],
            foreground=[("selected", "white")],
        )

        # Panes
        style.configure("TPanedwindow", background=dark_bg)
        style.configure("Sash", background=border, handlecv_bg=border)

    def _setup_ui(self):
        self.sidebar = Sidebar(self, STORAGE_DIR, self.load_cartridge)
        self.sidebar.pack(side="left", fill="y")

        self.main_area = tk.Frame(self, bg=BG_COLOR)
        self.main_area.pack(side="right", fill="both", expand=True)

        self.notebook = ttk.Notebook(self.main_area)
        self.notebook.pack(fill="both", expand=True)

        self.tab_forge = tk.Frame(self.notebook, bg=BG_COLOR)
        self.notebook.add(self.tab_forge, text="  DATA INGESTION  ")

        self.ingest_toolbar = IngestToolbar(
            self.tab_forge,
            on_scan=self.run_scan_request,
            on_ingest=self.run_ingest_request,
        )
        self.ingest_toolbar.pack(fill="x", side="top")

        forge_panes = ttk.PanedWindow(self.tab_forge, orient="horizontal")
        forge_panes.pack(fill="both", expand=True, padx=5, pady=5)

        self.file_tree = FileTreePanel(forge_panes, None)
        forge_panes.add(self.file_tree, weight=1)

        right_col = ttk.PanedWindow(forge_panes, orient="vertical")
        forge_panes.add(right_col, weight=3)

        self.stream = ThoughtStream(right_col)
        right_col.add(self.stream, weight=3)

        self.sys_log = SystemLog(right_col)
        right_col.add(self.sys_log, weight=1)

        self.editor_panel = EditorPanel(self.notebook)
        self.notebook.add(self.editor_panel, text="  KNOWLEDGE INSPECTOR  ")

        self.graph_view = GraphView(self.notebook)
        self.notebook.add(self.graph_view, text="  NEURAL TOPOLOGY  ")

        status_frame = tk.Frame(
            self.main_area,
            bg="#101018",
            height=25,
            highlightbackground="#333",
            highlightthickness=1,
        )
        status_frame.pack(fill="x", side="bottom")
        status_frame.pack_propagate(False)

        self.status_var = tk.StringVar(value="Ready.")
        tk.Label(
            status_frame,
            textvariable=self.status_var,
            bg="#101018",
            fg="#888",
            font=("Arial", 9),
        ).pack(side="left", padx=10)

    # Remaining methods unchanged â€¦


    def load_cartridge(self, path):
        """Called when user clicks a DB in sidebar."""
        self.active_db_path = path
        self.status_var.set(f"Loaded: {os.path.basename(path)}")
        self.title(f"{APP_TITLE} - [{os.path.basename(path)}]")
        
        # 1. Init Backend for this specific cartridge
        self.active_cartridge = CartridgeService(path)
        
        # 2. Wire up panels
        new_intake = IntakeService(self.active_cartridge)
        self.file_tree.intake = new_intake
        self.editor_panel.load_db(path)
        self.sys_log.log(f"Cartridge loaded: {os.path.basename(path)}")
        
        # 3. Load Graph (Non-blocking)
        self.graph_view.load_from_db(path)
        
        # 4. Start Background Poller (The Refinery Daemon)
        if not self.refining:
            self.refining = True
            self.after(1000, self._refinery_loop)

    def run_scan_request(self, path):
        if not self.active_cartridge:
            messagebox.showwarning("No Cartridge", "Select a cartridge first.")
            return
        
        self.status_var.set(f"Scanning {path}...")
        self.file_tree.load_tree(path)
        self.sys_log.log(f"Scanned source: {path}")
        self.status_var.set("Scan complete. Select files to ingest.")

    def run_ingest_request(self):
        if not self.active_cartridge:
            return
        
        files = self.file_tree.get_selected_files()
        root = self.file_tree.root_path
        
        if not files:
            messagebox.showwarning("No Files", "No files selected for ingestion.")
            return

        def worker():
            count = len(files)
            msg = f"Ingesting {count} items..."
            self.status_var.set(msg)
            self.sys_log.log(msg)
            try:
                # Access intake via file_tree which now holds the reference
                stats = self.file_tree.intake.ingest_selected(files, root)
                done_msg = f"Ingest Result: {stats}"
                self.status_var.set(done_msg)
                self.sys_log.log(done_msg)
            except Exception as e:
                err = f"Ingest Failed: {e}"
                self.sys_log.log(err)
            
            self.after(0, lambda: self.editor_panel.refresh_list())

        threading.Thread(target=worker, daemon=True).start()

    def _refinery_loop(self):
        """
        The Heartbeat. Checks for RAW files and processes them in small batches.
        Keeps the UI responsive while chewing through data.
        """
        if self.active_cartridge:
            # We create a transient refinery instance to process the batch
            # Ideally, this should be persistent, but for now this works.
            refinery = RefineryService(self.active_cartridge, self.neural)
            
            try:
                # Process a small batch
                processed = refinery.process_pending(batch_size=1)
                
                if processed > 0:
                    self.status_var.set("Refining Knowledge... (Embedding & Weaving)")
                    # Update visuals occasionally
                    if processed % 5 == 0:
                        self.graph_view.load_from_db(self.active_db_path)
                        self.editor_panel.refresh_list()
                else:
                    current_status = self.status_var.get()
                    if "Refining" in current_status:
                        self.status_var.set("Refinery Idle. Cartridge up to date.")
                        self.graph_view.load_from_db(self.active_db_path)
                        self.editor_panel.refresh_list()
            except Exception as e:
                print(f"Refinery Loop Error: {e}")

        # Loop
        self.after(2000, self._refinery_loop)


# 5. CLI ENTRY POINT

def main():
    parser = argparse.ArgumentParser(description="_RagFORGE: Neural Cartridge Factory")
    
    # CLI Args for Headless Mode
    parser.add_argument("--input", "-i", type=str, help="Input source path (folder or URL)")
    parser.add_argument("--output", "-o", type=str, help="Output .db filename (e.g. 'my_brain.db')")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose logs")
    
    args = parser.parse_args()

    if args.input and args.output:
        # HEADLESS MODE
        try:
            headless_forge(args.input, args.output, args.verbose)
        except Exception as e:
            print(f"[FATAL] {e}")
            sys.exit(1)
    else:
        # GUI MODE
        app = RagForgeApp()
        app.mainloop()

if __name__ == "__main__":
    main()




--------------------------------------------------------------------------------
FILE: src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\base_service.py
--------------------------------------------------------------------------------
import logging
import sys

class BaseService:
    """
    Standard base class for all _NeoCORTEX microservices.
    Provides unified logging and error handling.
    """
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.log = logging.getLogger(service_name)
        
        # Configure logging if not already set up
        if not self.log.handlers:
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter('%(asctime)s [%(name)s] %(levelname)s: %(message)s', datefmt='%H:%M:%S')
            handler.setFormatter(formatter)
            self.log.addHandler(handler)
            self.log.setLevel(logging.INFO)

    def log_info(self, msg: str):
        self.log.info(msg)

    def log_error(self, msg: str):
        self.log.error(msg)

--------------------------------------------------------------------------------
FILE: src\microservices\cartridge_service.py
--------------------------------------------------------------------------------
import sqlite3
import json
import time
from pathlib import Path
from typing import Dict, Any, Optional, List
from .base_service import BaseService

class CartridgeService(BaseService):
    """
    The Source of Truth.
    Manages the Unified Neural Cartridge Format (UNCF v1.0).
    """
    
    SCHEMA_VERSION = "uncf_v1.0"

    def __init__(self, db_path: str):
        super().__init__("CartridgeService")
        self.db_path = Path(db_path)
        self._init_db()

    def _get_conn(self):
        return sqlite3.connect(self.db_path)

    def _init_db(self):
        """Initializes the standard Schema."""
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        conn = self._get_conn()
        cursor = conn.cursor()
        
        # 1. Manifest (The Boot Sector)
        cursor.execute("CREATE TABLE IF NOT EXISTS manifest (key TEXT PRIMARY KEY, value TEXT)")
        
        # 1.5 Directories (The VFS Index)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS directories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vfs_path TEXT UNIQUE NOT NULL,
                parent_path TEXT,
                metadata TEXT DEFAULT '{}'
            )
        """)
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_dir_parent ON directories(parent_path)")

        # 2. Files (The Content Store)
        # Supports Text AND Binary (blob_data)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vfs_path TEXT NOT NULL,       -- Portable path (e.g. "src/main.py")
                origin_path TEXT,             -- Provenance (e.g. "C:/Users/...")
                origin_type TEXT,             -- 'filesystem', 'web', 'github'
                content TEXT,                 -- Text content (UTF-8)
                blob_data BLOB,               -- Binary content (Images, PDFs)
                mime_type TEXT,
                status TEXT DEFAULT 'RAW',    -- RAW, REFINED, ERROR, SKIPPED
                metadata TEXT DEFAULT '{}',   -- JSON tags, summaries
                last_updated TIMESTAMP
            )
        """)
        # Index for fast lookups by VFS path
        cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_vfs ON files(vfs_path)")

        # 3. Chunks (The Vector Store)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS chunks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_id INTEGER,
                chunk_index INTEGER,
                content TEXT,
                embedding BLOB,
                name TEXT,
                type TEXT,
                start_line INTEGER,
                end_line INTEGER,
                FOREIGN KEY(file_id) REFERENCES files(id)
            )
        """)

        # 4. Graph Topology (The Neural Wiring)
        cursor.execute("CREATE TABLE IF NOT EXISTS graph_nodes (id TEXT PRIMARY KEY, type TEXT, label TEXT, data_json TEXT)")
        cursor.execute("CREATE TABLE IF NOT EXISTS graph_edges (source TEXT, target TEXT, relation TEXT, weight REAL)")

        # 5. Validation Logs
        cursor.execute("CREATE TABLE IF NOT EXISTS logs (timestamp REAL, level TEXT, message TEXT, context TEXT)")
        
        conn.commit()
        conn.close()

    def store_file(self, vfs_path: str, origin_path: str, content: str = None, blob: bytes = None, mime_type: str = "text/plain", origin_type: str = "filesystem"):
        """
        The Universal Input Method. 
        Stores raw data. If file exists, updates it and resets status to 'RAW' for re-refining.
        """
        conn = self._get_conn()
        try:
            conn.execute("""
                INSERT OR REPLACE INTO files 
                (vfs_path, origin_path, origin_type, content, blob_data, mime_type, status, last_updated)
                VALUES (?, ?, ?, ?, ?, ?, 'RAW', ?)
            """, (vfs_path, origin_path, origin_type, content, blob, mime_type, time.time()))
            conn.commit()
            return True
        except Exception as e:
            self.log_error(f"DB Store Error ({vfs_path}): {e}")
            return False
        finally:
            conn.close()

    def get_pending_files(self, limit: int = 10) -> List[Dict]:
        """Fetches files waiting for the Refinery."""
        conn = self._get_conn()
        conn.row_factory = sqlite3.Row
        rows = conn.execute("SELECT * FROM files WHERE status = 'RAW' LIMIT ?", (limit,)).fetchall()
        conn.close()
        return [dict(row) for row in rows]

    def update_status(self, file_id: int, status: str, metadata: dict = None):
        conn = self._get_conn()
        if metadata:
            conn.execute("UPDATE files SET status = ?, metadata = ? WHERE id = ?", 
                         (status, json.dumps(metadata), file_id))
        else:
            conn.execute("UPDATE files SET status = ? WHERE id = ?", (status, file_id))
        conn.commit()
        conn.close()

    def ensure_directory(self, vfs_path: str):
        """Idempotent insert for VFS directories."""
        if not vfs_path: return
        parent = os.path.dirname(vfs_path).replace("\\", "/")
        if parent == vfs_path: parent = "" # Root case
        
        conn = self._get_conn()
        try:
            conn.execute("INSERT OR IGNORE INTO directories (vfs_path, parent_path) VALUES (?, ?)", (vfs_path, parent))
            conn.commit()
        except: pass
        finally:
            conn.close()

    # --- Graph Helpers ---
    def add_node(self, node_id: str, node_type: str, label: str, data: dict = None):
        conn = self._get_conn()
        conn.execute("INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json) VALUES (?, ?, ?, ?)",
                     (node_id, node_type, label, json.dumps(data or {})))
        conn.commit()
        conn.close()

    def add_edge(self, source: str, target: str, relation: str = "related", weight: float = 1.0):
        conn = self._get_conn()
        conn.execute("INSERT OR IGNORE INTO graph_edges (source, target, relation, weight) VALUES (?, ?, ?, ?)",
                     (source, target, relation, weight))
        conn.commit()
        conn.close()

--------------------------------------------------------------------------------
FILE: src\microservices\graph_engine.py
--------------------------------------------------------------------------------
import pygame
import math
import random

# Initialize font module globally once
pygame.font.init()

class GraphRenderer:
    def __init__(self, width, height, bg_color=(16, 16, 24)):
        self.width = width
        self.height = height
        self.bg_color = bg_color
        
        self.surface = pygame.Surface((width, height))
        
        # Camera
        self.cam_x = 0
        self.cam_y = 0
        self.zoom = 1.0
        
        # Assets
        self.font = pygame.font.SysFont("Consolas", 12)
        
        # Data
        self.nodes = [] 
        self.links = []
        
        # Interaction
        self.dragged_node_idx = None
        self.hovered_node_idx = None
        
        # Physics State
        self.settled = False

    def resize(self, width, height):
        self.width = width
        self.height = height
        self.surface = pygame.Surface((width, height))

    def set_data(self, nodes, links):
        self.nodes = nodes
        self.links = links
        self.settled = False # Wake up physics on new data
        
        # 1. Build an ID map so we can find parents
        node_map = {node['id']: node for node in self.nodes}

        for n in self.nodes:
            # GNN Injection: Use pre-calculated layout if available
            if 'gnn_x' in n and 'gnn_y' in n:
                n['x'] = n['gnn_x'] * self.width
                n['y'] = n['gnn_y'] * self.height

            elif 'x' not in n:
                # SMART SPAWN: If I am a satellite, spawn near my planet
                parent_id = n.get('meta', {}).get('parent')
                if parent_id and parent_id in node_map and 'x' in node_map[parent_id]:
                    p = node_map[parent_id]
                    angle = random.random() * 6.28
                    dist = 30
                    n['x'] = p['x'] + math.cos(angle) * dist
                    n['y'] = p['y'] + math.sin(angle) * dist
                else:
                    # Random spawn for Files
                    n['x'] = random.randint(int(self.width*0.2), int(self.width*0.8))
                    n['y'] = random.randint(int(self.height*0.2), int(self.height*0.8))
            if 'vx' not in n: n['vx'] = 0
            if 'vy' not in n: n['vy'] = 0
            
            # Semantic Coloring
            if n.get('type') == 'file':
                n['_color'] = (0, 122, 204) # Blue
                n['_radius'] = 6
            elif n.get('type') == 'web':
                n['_color'] = (204, 0, 122) # Purple/Pink
                n['_radius'] = 7
            elif n.get('type') == 'chunk':
                n['_color'] = (100, 200, 100) # Satellite Green
                n['_radius'] = 3
            else:
                n['_color'] = (160, 32, 240) # Default
                n['_radius'] = 6

    # --- INPUT HANDLING ---
    
    def screen_to_world(self, sx, sy):
        cx, cy = self.width / 2, self.height / 2
        wx = (sx - cx) / self.zoom + cx - self.cam_x
        wy = (sy - cy) / self.zoom + cy - self.cam_y
        return wx, wy

    def get_node_at(self, sx, sy):
        wx, wy = self.screen_to_world(sx, sy)
        for n in self.nodes:
            dist = math.hypot(n['x'] - wx, n['y'] - wy)
            if dist < n['_radius'] * 2:
                return n
        return None

    def handle_mouse_down(self, x, y):
        wx, wy = self.screen_to_world(x, y)
        for i, n in enumerate(self.nodes):
            dist = math.hypot(n['x'] - wx, n['y'] - wy)
            if dist < n['_radius'] * 2:
                self.dragged_node_idx = i
                self.settled = False # Wake up physics
                return True
        return False

    def handle_mouse_move(self, x, y, is_dragging):
        wx, wy = self.screen_to_world(x, y)
        
        if is_dragging and self.dragged_node_idx is not None:
            node = self.nodes[self.dragged_node_idx]
            node['x'] = wx
            node['y'] = wy
            node['vx'] = 0
            node['vy'] = 0
            self.settled = False
        else:
            prev_hover = self.hovered_node_idx
            self.hovered_node_idx = None
            for i, n in enumerate(self.nodes):
                dist = math.hypot(n['x'] - wx, n['y'] - wy)
                if dist < n['_radius'] * 2:
                    self.hovered_node_idx = i
                    break
            return prev_hover != self.hovered_node_idx

    def handle_mouse_up(self):
        self.dragged_node_idx = None

    def pan(self, dx, dy):
        self.cam_x += dx / self.zoom
        self.cam_y += dy / self.zoom

    def zoom_camera(self, amount, mouse_x, mouse_y):
        self.zoom *= amount
        self.zoom = max(0.1, min(self.zoom, 5.0))

    # --- PHYSICS (Damped) ---

    def step_physics(self):
        if not self.nodes or self.settled: return

        REPULSION = 1000
        ATTRACTION = 0.01
        CENTER_GRAVITY = 0.01
        DAMPING = 0.85 # Increased damping to settle faster
        
        cx, cy = self.width / 2, self.height / 2
        total_kinetic_energy = 0

        for i, a in enumerate(self.nodes):
            if i == self.dragged_node_idx: continue

            # LOD: Freeze satellites if zoomed out
            if self.zoom < 1.2 and a.get('type') == 'chunk':
                a['vx'] = 0
                a['vy'] = 0
                continue
            
            fx, fy = 0, 0
            
            # 1. Gravity (Center pull)
            fx += (cx - a['x']) * CENTER_GRAVITY
            fy += (cy - a['y']) * CENTER_GRAVITY

            # 2. Repulsion
            for j, b in enumerate(self.nodes):
                if i == j: continue
                dx = a['x'] - b['x']
                dy = a['y'] - b['y']
                dist_sq = dx*dx + dy*dy
                if dist_sq < 0.1: dist_sq = 0.1
                
                # Performance opt: Ignore far away nodes
                if dist_sq > 25000: continue 

                f = REPULSION / dist_sq
                dist = math.sqrt(dist_sq)
                fx += (dx / dist) * f
                fy += (dy / dist) * f

            a['vx'] = (a['vx'] + fx) * DAMPING
            a['vy'] = (a['vy'] + fy) * DAMPING

        # 3. Attraction (Links)
        for u, v in self.links:
            a = self.nodes[u]
            b = self.nodes[v]
            dx = b['x'] - a['x']
            dy = b['y'] - a['y']
            fx = dx * ATTRACTION
            fy = dy * ATTRACTION
            
            if u != self.dragged_node_idx:
                a['vx'] += fx
                a['vy'] += fy
            if v != self.dragged_node_idx:
                b['vx'] -= fx
                b['vy'] -= fy

        # 4. Apply & Measure Energy
        for i, n in enumerate(self.nodes):
            if i == self.dragged_node_idx: continue
            n['x'] += n['vx']
            n['y'] += n['vy']
            total_kinetic_energy += (abs(n['vx']) + abs(n['vy']))

        # 5. Sleep Threshold
        if total_kinetic_energy < 0.5:
            self.settled = True

    # --- RENDERING ---

    def get_image_bytes(self):
        self.surface.fill(self.bg_color)
        
        cx, cy = self.width / 2, self.height / 2
        def to_screen(x, y):
            sx = (x - cx + self.cam_x) * self.zoom + cx
            sy = (y - cy + self.cam_y) * self.zoom + cy
            return int(sx), int(sy)

        # Links
        for u, v in self.links:
            if self.zoom < 1.2:
                if self.nodes[u].get('type') == 'chunk' or self.nodes[v].get('type') == 'chunk':
                    continue

            start = to_screen(self.nodes[u]['x'], self.nodes[u]['y'])
            end = to_screen(self.nodes[v]['x'], self.nodes[v]['y'])
            pygame.draw.line(self.surface, (60, 60, 80), start, end, 1)

        # Nodes
        for i, n in enumerate(self.nodes):
            # LOD: Hide chunks if zoomed out
            if self.zoom < 1.2 and n.get('type') == 'chunk':
                continue

            sx, sy = to_screen(n['x'], n['y'])
            if sx < -20 or sx > self.width + 20 or sy < -20 or sy > self.height + 20: continue
                
            rad = int(n['_radius'] * self.zoom)
            col = n['_color']
            
            if i == self.hovered_node_idx or i == self.dragged_node_idx:
                pygame.draw.circle(self.surface, (255, 255, 255), (sx, sy), rad + 2)
            
            pygame.draw.circle(self.surface, col, (sx, sy), rad)
            
            if self.zoom > 0.8 or i == self.hovered_node_idx:
                text = self.font.render(n['label'], True, (200, 200, 200))
                self.surface.blit(text, (sx + rad + 4, sy - 6))

        return pygame.image.tostring(self.surface, 'RGB')


--------------------------------------------------------------------------------
FILE: src\microservices\graph_view.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import sqlite3
import json
import os
from .graph_engine import GraphRenderer

class GraphView(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.pack(fill="both", expand=True)
        
        # UI Container
        self.canvas_lbl = tk.Label(self, bg="#101018", cursor="crosshair")
        self.canvas_lbl.pack(fill="both", expand=True)
        
        # Engine Init
        self.engine = GraphRenderer(800, 600)
        self.photo = None 
        
        # Input State
        self.last_mouse_x = 0
        self.last_mouse_y = 0
        self.is_dragging_node = False
        self.is_panning = False

        # Bindings
        self.canvas_lbl.bind('<Button-1>', self.on_click)
        self.canvas_lbl.bind('<Double-Button-1>', self.on_double_click)
        self.canvas_lbl.bind('<ButtonRelease-1>', self.on_release)
        self.canvas_lbl.bind('<B1-Motion>', self.on_drag)
        self.canvas_lbl.bind('<Motion>', self.on_hover)
        self.canvas_lbl.bind('<Button-4>', lambda e: self.on_zoom(1.1)) # Linux Scroll Up
        self.canvas_lbl.bind('<Button-5>', lambda e: self.on_zoom(0.9)) # Linux Scroll Down
        self.canvas_lbl.bind('<MouseWheel>', self.on_windows_scroll)    # Windows Scroll
        self.canvas_lbl.bind('<Configure>', self.on_resize)
        
        # Start the Heartbeat
        self.animate()

    def load_from_db(self, db_path):
        """
        Loads graph data from SQLite.
        Does NOT block the UI. The physics engine will settle the nodes frame-by-frame.
        """
        if not os.path.exists(db_path): return
        
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # [cite_start]Fetch Nodes [cite: 198]
            db_nodes = cursor.execute("SELECT id, type, label, data_json FROM graph_nodes").fetchall()
            
            # [cite_start]Fetch Edges [cite: 198]
            db_edges = cursor.execute("SELECT source, target FROM graph_edges").fetchall()
            
            conn.close()
        except Exception as e:
            print(f"Graph Load Error: {e}")
            return

        # Format for Engine
        id_to_index = {}
        formatted_nodes = []
        
        for idx, row in enumerate(db_nodes):
            node_id, n_type, label, raw_json = row
            meta = {}
            try:
                if raw_json: meta = json.loads(raw_json)
            except: pass
            
            id_to_index[node_id] = idx
            formatted_nodes.append({'id': node_id, 'type': n_type, 'label': label, 'meta': meta})

        formatted_links = []
        for src, tgt in db_edges:
            if src in id_to_index and tgt in id_to_index:
                formatted_links.append((id_to_index[src], id_to_index[tgt]))

        # Inject Data - The Physics Engine handles the "Explosion" logic internally
        self.engine.set_data(formatted_nodes, formatted_links)

    def on_resize(self, event):
        if event.width > 1 and event.height > 1:
            self.engine.resize(event.width, event.height)

    def on_double_click(self, event):
        # Zoom in on the node we clicked
        hit_node = self.engine.get_node_at(event.x, event.y)
        if hit_node:
            # Center camera on node and zoom in
            self.engine.cam_x = hit_node['x']
            self.engine.cam_y = hit_node['y']
            self.engine.zoom = 2.0
            self.engine.settled = False

    def on_click(self, event):
        self.last_mouse_x = event.x
        self.last_mouse_y = event.y
        
        # Check if we clicked a node
        hit = self.engine.handle_mouse_down(event.x, event.y)
        if hit:
            self.is_dragging_node = True
        else:
            self.is_panning = True

    def on_release(self, event):
        self.engine.handle_mouse_up()
        self.is_dragging_node = False
        self.is_panning = False

    def on_drag(self, event):
        if self.is_dragging_node:
            self.engine.handle_mouse_move(event.x, event.y, True)
        elif self.is_panning:
            # Camera Pan
            dx = event.x - self.last_mouse_x
            dy = event.y - self.last_mouse_y
            self.engine.pan(dx, dy)
            
        self.last_mouse_x = event.x
        self.last_mouse_y = event.y

    def on_hover(self, event):
        if not self.is_dragging_node:
            self.engine.handle_mouse_move(event.x, event.y, False)

    def on_zoom(self, amount):
        self.engine.zoom_camera(amount, 0, 0)
        self.engine.settled = False # Wake up physics on zoom

    def on_windows_scroll(self, event):
        if event.delta > 0: self.on_zoom(1.1)
        else: self.on_zoom(0.9)

    def animate(self):
        """
        The Heartbeat Loop. 
        Runs at ~30 FPS. Handles Physics + Rendering.
        """
        # 1. Step Physics (Micro-calculations)
        self.engine.step_physics()
        
        # 2. Render to Buffer
        raw_data = self.engine.get_image_bytes()
        
        # 3. Blit to Screen
        if raw_data:
            img = Image.frombytes('RGB', (self.engine.width, self.engine.height), raw_data)
            self.photo = ImageTk.PhotoImage(img)
            self.canvas_lbl.configure(image=self.photo)
        
        # 4. Loop
        self.after(30, self.animate)
--------------------------------------------------------------------------------
FILE: src\microservices\intake_service.py
--------------------------------------------------------------------------------
import os
import mimetypes
import requests
import fnmatch
import json
from pathlib import Path
from typing import Dict, Set, List, Any
from .base_service import BaseService
from .cartridge_service import CartridgeService

# Optional import for Web
try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

class IntakeService(BaseService):
    """
    The Vacuum. 
    Now supports two-phase ingestion:
    1. Scan -> Build Tree (with .gitignore respect)
    2. Ingest -> Process selected paths
    """

    DEFAULT_IGNORE_DIRS = {
        '.git', '__pycache__', 'node_modules', 'venv', '.venv', 'env', '.env', 
        '.idea', '.vscode', 'dist', 'build', 'target', 'bin', 'obj', 
        '__cartridge__'
    }
    
    DEFAULT_IGNORE_EXTS = {
        '.pyc', '.pyd', '.exe', '.dll', '.so', '.db', '.sqlite', '.sqlite3', 
        '.bin', '.iso', '.img', '.zip', '.tar', '.gz', '.7z', '.pdf', '.jpg', '.png'
    }

    def __init__(self, cartridge: CartridgeService):
        super().__init__("IntakeService")
        self.cartridge = cartridge
        self.ignore_patterns: Set[str] = set()

    # --- PHASE 1: SCANNING ---

    def scan_path(self, root_path: str) -> Dict[str, Any]:
        """
        Builds a file tree dict.
        Returns: { 'name': 'root', 'path': '...', 'type': 'dir', 'children': [...], 'checked': bool }
        """
        # 1. Web URL
        if root_path.startswith("http://") or root_path.startswith("https://"):
            return {
                'name': root_path,
                'path': root_path,
                'rel_path': root_path,
                'type': 'web',
                'children': [],
                'checked': True
            }

        # 2. Local Path
        root_path = os.path.abspath(root_path)
        
        if os.path.isfile(root_path):
            # Single File Mode
            return {
                'name': os.path.basename(root_path),
                'path': root_path,
                'rel_path': os.path.basename(root_path),
                'type': 'file',
                'children': [],
                'checked': True
            }
            
        # 3. Directory Mode
        self._load_gitignore(root_path)
        saved_config = self._load_persistence(root_path)
        return self._scan_recursive(root_path, root_path, saved_config)

    def _scan_recursive(self, current_path: str, root_path: str, saved_config: Dict) -> Dict:
        name = os.path.basename(current_path)
        is_dir = os.path.isdir(current_path)
        rel_path = os.path.relpath(current_path, root_path).replace("\\", "/")
        
        node = {
            'name': name,
            'path': current_path,
            'rel_path': rel_path,
            'type': 'dir' if is_dir else 'file',
            'children': [],
            'checked': True
        }

        # Determine Check State
        if saved_config and rel_path in saved_config:
            # Respect user persistence
            node['checked'] = saved_config[rel_path]
        elif self._is_ignored(name) or (not is_dir and self._is_binary_ext(name)):
            # Default to unchecked if ignored
            node['checked'] = False

        if is_dir:
            try:
                with os.scandir(current_path) as it:
                    entries = sorted(it, key=lambda e: (not e.is_dir(), e.name.lower()))
                    for entry in entries:
                        child = self._scan_recursive(entry.path, root_path, saved_config)
                        node['children'].append(child)
            except PermissionError:
                pass
        
        return node

    # --- PHASE 2: INGESTION ---

    def ingest_selected(self, file_list: List[str], root_path: str) -> Dict[str, int]:
        """Ingests only the specific files passed in the list."""
        stats = {"added": 0, "skipped": 0, "errors": 0}
        
        for file_path in file_list:
            try:
                # Calculate VFS Path
                try:
                    vfs_path = os.path.relpath(file_path, root_path).replace("\\", "/")
                except ValueError:
                    vfs_path = os.path.basename(file_path)

                self._read_and_store(Path(file_path), vfs_path, "filesystem", stats)
            except Exception as e:
                self.log_error(f"Error ingesting {file_path}: {e}")
                stats["errors"] += 1
        
        # --- POST-INGESTION: Update Manifest ---
        self._rebuild_directory_index()
        
        return stats

    def _rebuild_directory_index(self):
        """
        Scans 'files' table and populates 'directories' table.
        This creates the navigable VFS structure.
        """
        self.log_info("Rebuilding VFS Directory Index...")
        conn = self.cartridge._get_conn()
        try:
            rows = conn.execute("SELECT vfs_path FROM files").fetchall()
            seen_dirs = set()
            
            for r in rows:
                path = r[0]
                # Walk up the path to register all parents
                current = os.path.dirname(path).replace("\\", "/")
                while current and current != "." and current not in seen_dirs:
                    self.cartridge.ensure_directory(current)
                    seen_dirs.add(current)
                    current = os.path.dirname(current).replace("\\", "/")
            
        except Exception as e:
            self.log_error(f"Directory Index Error: {e}")
        finally:
            conn.close()

    # --- HELPERS ---

    def _load_persistence(self, root_path: str) -> Dict[str, bool]:
        """Loads config from DB Manifest (Portable) or fallback to local."""
        # 1. Try DB Manifest
        try:
            conn = self.cartridge._get_conn()
            row = conn.execute("SELECT value FROM manifest WHERE key='ingest_config'").fetchone()
            conn.close()
            if row:
                return json.loads(row[0])
        except: pass
        
        # 2. Fallback to local (Legacy)
        cfg_path = os.path.join(root_path, ".ragforge.json")
        if os.path.exists(cfg_path):
            try:
                with open(cfg_path, 'r') as f: return json.load(f)
            except: pass
        return {}

    def save_persistence(self, root_path: str, checked_map: Dict[str, bool]):
        """Saves user selections into the Cartridge Manifest (Portable)."""
        # 1. Save to DB
        try:
            conn = self.cartridge._get_conn()
            conn.execute("INSERT OR REPLACE INTO manifest (key, value) VALUES (?, ?)", 
                         ("ingest_config", json.dumps(checked_map)))
            conn.commit()
            conn.close()
        except Exception as e:
            self.log_error(f"Failed to save persistence to DB: {e}")

        # 2. Save local backup (Optional, keeps scan state if DB is deleted)
        cfg_path = os.path.join(root_path, ".ragforge.json")
        try:
            with open(cfg_path, 'w') as f: json.dump(checked_map, f, indent=2)
        except: pass

    def _load_gitignore(self, root_path: str):
        gitignore_path = os.path.join(root_path, '.gitignore')
        self.ignore_patterns = self.DEFAULT_IGNORE_DIRS.copy()
        if os.path.exists(gitignore_path):
            try:
                with open(gitignore_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            if line.endswith('/'): line = line[:-1]
                            self.ignore_patterns.add(line)
            except: pass

    def _is_ignored(self, name: str) -> bool:
        if name in self.ignore_patterns: return True
        for pattern in self.ignore_patterns:
            if fnmatch.fnmatch(name, pattern): return True
        return False

    def _is_binary_ext(self, name: str) -> bool:
        _, ext = os.path.splitext(name)
        return ext.lower() in self.DEFAULT_IGNORE_EXTS

    def _read_and_store(self, real_path: Path, vfs_path: str, origin_type: str, stats: Dict):
        mime_type, _ = mimetypes.guess_type(real_path)
        if not mime_type: mime_type = "application/octet-stream"
        try:
            with open(real_path, 'r', encoding='utf-8') as f:
                content = f.read()
                self.cartridge.store_file(vfs_path, str(real_path), content=content, mime_type=mime_type, origin_type=origin_type)
        except UnicodeDecodeError:
            try:
                with open(real_path, 'rb') as f:
                    blob = f.read()
                    self.cartridge.store_file(vfs_path, str(real_path), blob=blob, mime_type=mime_type, origin_type=origin_type)
            except: pass
        stats["added"] += 1

--------------------------------------------------------------------------------
FILE: src\microservices\neural_service.py
--------------------------------------------------------------------------------
import requests
import json
import concurrent.futures
from typing import Optional, Dict, Any, List
from .base_service import BaseService

# Configuration constants
OLLAMA_API_URL = "http://localhost:11434/api"

class NeuralService(BaseService):
    def __init__(self, max_workers: int = 4):
        super().__init__("NeuralService")
        self.max_workers = max_workers
        # Default configs
        self.config = {
            "fast": "qwen2.5-coder:1.5b-cpu",
            "smart": "qwen2.5:3b-cpu",
            "embed": "mxbai-embed-large:latest-cpu"
        }

    def update_models(self, fast_model: str, smart_model: str, embed_model: str):
        """Called by the UI Settings Modal to change models on the fly."""
        self.config["fast"] = fast_model
        self.config["smart"] = smart_model
        self.config["embed"] = embed_model
        self.log_info(f"Models Updated: Fast={fast_model}, Smart={smart_model}")

    def get_available_models(self) -> List[str]:
        """Fetches list from Ollama for the UI dropdown."""
        try:
            res = requests.get(f"{OLLAMA_API_URL}/tags", timeout=2)
            if res.status_code == 200:
                return [m['name'] for m in res.json().get('models', [])]
        except:
            return []
        return []

    def check_connection(self) -> bool:
        """Pings Ollama to see if it's alive."""
        try:
            requests.get(f"{OLLAMA_API_URL}/tags", timeout=2)
            return True
        except requests.RequestException:
            self.log_error("Ollama connection failed. Is 'ollama serve' running?")
            return False

    def get_embedding(self, text: str) -> Optional[List[float]]:
        """Generates a vector using the CPU embedder."""
        try:
            res = requests.post(
                f"{OLLAMA_API_URL}/embeddings",
                json={"model": self.config["embed"], "prompt": text},
                timeout=30
            )
            if res.status_code == 200:
                return res.json().get("embedding")
        except Exception as e:
            self.log_error(f"Embedding failed: {e}")
        return None

    def request_inference(self, prompt: str, tier: str = "fast", format_json: bool = False) -> str:
        """
        Synchronous inference request.
        tier: 'fast' (1.5b-cpu), 'smart' (3b-cpu), or 'architect' (7b-gpu)
        """
        model = self.config.get(tier, self.config["fast"])
        payload = {
            "model": model,
            "prompt": prompt,
            "stream": False
        }
        if format_json:
            payload["format"] = "json"

        try:
            res = requests.post(f"{OLLAMA_API_URL}/generate", json=payload, timeout=60)
            if res.status_code == 200:
                return res.json().get("response", "").strip()
        except Exception as e:
            self.log_error(f"Inference ({tier}) failed: {e}")
        return ""

    def process_parallel(self, items: List[Any], worker_func) -> List[Any]:
        """
        Helper to run a function across many items using the ThreadPool.
        Useful for batch ingestion.
        """
        results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # worker_func should take a single item and return a result
            futures = {executor.submit(worker_func, item): item for item in items}
            for future in concurrent.futures.as_completed(futures):
                try:
                    results.append(future.result())
                except Exception as e:
                    self.log_error(f"Worker task failed: {e}")
        return results


--------------------------------------------------------------------------------
FILE: src\microservices\panels.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext, simpledialog
import os
import sqlite3
import threading

# --- UI CONSTANTS ---
BG_COLOR = "#1e1e2f"
SIDEBAR_COLOR = "#171725"
ACCENT_COLOR = "#007ACC"
TEXT_COLOR = "#e0e0e0"
SUCCESS_COLOR = "#388E3C"

class SystemLog(tk.Frame):
    """A read-only scrolling log for system events."""
    def __init__(self, parent):
        super().__init__(parent, bg=BG_COLOR)
        tk.Label(self, text="SYSTEM LOG", bg=BG_COLOR, fg="#666", font=("Consolas", 9, "bold")).pack(anchor="w", padx=5, pady=(5,0))
        self.text = scrolledtext.ScrolledText(self, bg="#151515", fg="#00FF00", font=("Consolas", 9), height=8, bd=0)
        self.text.pack(fill="both", expand=True, padx=5, pady=5)
        self.text.config(state="disabled")

    def log(self, msg):
        self.text.config(state="normal")
        ts = time.strftime("%H:%M:%S")
        self.text.insert("end", f"[{ts}] {msg}\n")
        self.text.see("end")
        self.text.config(state="disabled")

class IngestToolbar(tk.Frame):
    """Top bar for selecting source and triggering actions."""
    def __init__(self, parent, on_scan, on_ingest):
        super().__init__(parent, bg=BG_COLOR, pady=5)
        self.on_scan = on_scan
        self.on_ingest = on_ingest
        self.path_var = tk.StringVar()

        # Label
        tk.Label(self, text="SOURCE:", bg=BG_COLOR, fg="#888", font=("Arial", 9, "bold")).pack(side="left", padx=(10, 5))
        
        # Entry
        self.entry = tk.Entry(self, textvariable=self.path_var, bg="#252526", fg="white", 
                              insertbackground="white", relief="flat", font=("Consolas", 10))
        self.entry.pack(side="left", fill="x", expand=True, padx=5, ipady=4)

        # Buttons
        btn_cfg = {"bg": "#444", "fg": "white", "relief": "flat", "padx": 10, "font": ("Arial", 9)}
        
        tk.Button(self, text="ðŸ“„ File", command=self._browse_file, **btn_cfg).pack(side="left", padx=2)
        tk.Button(self, text="ðŸ“‚ Folder", command=self._browse_folder, **btn_cfg).pack(side="left", padx=2)
        
        # Separator
        tk.Frame(self, width=1, bg="#555").pack(side="left", fill="y", padx=10, pady=5)

        tk.Button(self, text="ðŸ” SCAN", command=self._trigger_scan, **btn_cfg).pack(side="left", padx=2)
        
        # Ingest (Green)
        ing_cfg = btn_cfg.copy()
        ing_cfg["bg"] = SUCCESS_COLOR
        ing_cfg["font"] = ("Arial", 9, "bold")
        tk.Button(self, text="â–¶ INGEST", command=self._trigger_ingest, **ing_cfg).pack(side="left", padx=(10, 10))

    def _browse_folder(self):
        d = filedialog.askdirectory()
        if d:
            self.path_var.set(d)
            self._trigger_scan()

    def _browse_file(self):
        f = filedialog.askopenfilename()
        if f:
            self.path_var.set(f)
            self._trigger_scan()

    def _trigger_scan(self):
        path = self.path_var.get().strip()
        if path: self.on_scan(path)

    def _trigger_ingest(self):
        self.on_ingest()


class FileTreePanel(tk.Frame):
    """Hierarchy Explorer with Checkboxes."""
    def __init__(self, parent, intake_service):
        super().__init__(parent, bg=BG_COLOR)
        self.intake = intake_service
        self.root_path = None
        self.node_map = {}

        # Header
        tk.Label(self, text="HIERARCHY EXPLORER", bg=BG_COLOR, fg="#666", 
                 font=("Consolas", 9, "bold")).pack(anchor="w", padx=5, pady=(5,0))

        # Tree (Inherits 'Treeview' style from app.py)
        self.tree = ttk.Treeview(self, show="tree", selectmode="none")
        self.tree.pack(fill="both", expand=True, padx=5, pady=5)
        self.tree.bind("<Button-1>", self._on_tree_click)
        
        sb = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
        sb.place(relx=1, rely=0, relheight=1, anchor="ne")
        self.tree.configure(yscrollcommand=sb.set)

    def load_tree(self, path):
        self.root_path = path
        self.tree.delete(*self.tree.get_children())
        self.node_map = {}
        tree_data = self.intake.scan_path(path)
        self._insert_node("", tree_data)

    def _insert_node(self, parent_id, node):
        icon = "â˜‘" if node['checked'] else "â˜"
        display = f"{icon}  {node['name']}"
        item_id = self.tree.insert(parent_id, "end", text=display, open=(parent_id==""))
        self.node_map[item_id] = node
        for child in node['children']:
            self._insert_node(item_id, child)

    def _on_tree_click(self, event):
        region = self.tree.identify_region(event.x, event.y)
        if region in ["tree", "separator"]:
            return 
        item_id = self.tree.identify_row(event.y)
        if item_id:
            self._toggle_check(item_id)
            return "break"

    def _toggle_check(self, item_id):
        node = self.node_map[item_id]
        new_state = not node['checked']
        self._set_node_state(item_id, new_state)
        self._save_config()

    def _set_node_state(self, item_id, state):
        node = self.node_map[item_id]
        node['checked'] = state
        icon = "â˜‘" if state else "â˜"
        self.tree.item(item_id, text=f"{icon}  {node['name']}")
        for child_id in self.tree.get_children(item_id):
            self._set_node_state(child_id, state)

    def _save_config(self):
        if not self.root_path or os.path.isfile(self.root_path): return
        flat_config = {n['rel_path']: n['checked'] for n in self.node_map.values()}
        self.intake.save_persistence(self.root_path, flat_config)

    def get_selected_files(self):
        selected = []
        for node in self.node_map.values():
            if node['checked'] and (node['type'] == 'file' or node['type'] == 'web'):
                selected.append(node['path'])
        return selected

class Sidebar(tk.Frame):
    """
    Manages the list of available Cartridges (.db files).
    """
    def __init__(self, parent, storage_dir, on_select_callback):
        super().__init__(parent, bg=SIDEBAR_COLOR, width=220)
        self.storage_dir = storage_dir
        self.on_select = on_select_callback
        self.pack_propagate(False)

        # Header
        tk.Label(self, text="_RagFORGE", bg=SIDEBAR_COLOR, fg=ACCENT_COLOR, 
                 font=("Consolas", 14, "bold"), pady=15).pack(fill="x")
        
        # List
        tk.Label(self, text="CARTRIDGES", bg=SIDEBAR_COLOR, fg="#666", 
                 font=("Arial", 8, "bold"), anchor="w", padx=10).pack(fill="x")
        
        self.listbox = tk.Listbox(self, bg=SIDEBAR_COLOR, fg=TEXT_COLOR, bd=0, 
                                  highlightthickness=0, selectbackground=ACCENT_COLOR)
        self.listbox.pack(fill="both", expand=True, padx=5, pady=5)
        self.listbox.bind("<<ListboxSelect>>", self._on_click)

        # Footer Actions
        btn_frame = tk.Frame(self, bg=SIDEBAR_COLOR, pady=10)
        btn_frame.pack(fill="x", side="bottom")
        
        row1 = tk.Frame(btn_frame, bg=SIDEBAR_COLOR)
        row1.pack(fill="x", pady=2)
        tk.Button(row1, text="ðŸ“‚ ROOT", bg="#2d2d44", fg="#aaa", relief="flat", font=("Arial", 8), 
                  command=self._change_root).pack(side="left", padx=10, fill="x", expand=True)
        
        row2 = tk.Frame(btn_frame, bg=SIDEBAR_COLOR)
        row2.pack(fill="x", pady=2)
        tk.Button(row2, text="REFRESH", bg="#2d2d44", fg="white", relief="flat", 
                  command=self.refresh).pack(side="left", padx=10, fill="x", expand=True)
        tk.Button(row2, text="+ NEW", bg="#2d2d44", fg="white", relief="flat", 
                  command=self._create_new).pack(side="right", padx=10, fill="x", expand=True)

        self.refresh()

    def _change_root(self):
        d = filedialog.askdirectory(title="Select Cartridge Library")
        if d:
            self.storage_dir = d
            self.refresh()

    def refresh(self):
        self.listbox.delete(0, tk.END)
        if not os.path.exists(self.storage_dir):
            os.makedirs(self.storage_dir)
        
        dbs = [f for f in os.listdir(self.storage_dir) if f.endswith(".db")]
        for db in dbs:
            self.listbox.insert(tk.END, db)

    def _on_click(self, event):
        sel = self.listbox.curselection()
        if sel:
            db_name = self.listbox.get(sel[0])
            self.on_select(os.path.join(self.storage_dir, db_name))

    def _create_new(self):
        name = simpledialog.askstring("New Cartridge", "Enter name (e.g. 'project_alpha'):")
        if name:
            if not name.endswith(".db"): name += ".db"
            path = os.path.join(self.storage_dir, name)
            # Just touching the file is enough, CartridgeService will init schema on load
            sqlite3.connect(path).close()
            self.refresh()

class EditorPanel(tk.Frame):
    """
    Views the 'files' table content.
    """
    def __init__(self, parent):
        super().__init__(parent, bg=BG_COLOR)
        self.active_db = None
        
        paned = ttk.PanedWindow(self, orient="horizontal")
        paned.pack(fill="both", expand=True)
        
        # Left: File Tree
        self.tree = ttk.Treeview(paned, show="tree", selectmode="browse")
        self.tree.heading("#0", text="VFS Path", anchor="w")
        self.tree.bind("<<TreeviewSelect>>", self._on_select)
        paned.add(self.tree, weight=1)
        
        # Right: Content
        self.editor = scrolledtext.ScrolledText(paned, bg="#252526", fg=TEXT_COLOR, 
                                                font=("Consolas", 10), insertbackground="white")
        paned.add(self.editor, weight=3)

    def load_db(self, db_path):
        self.active_db = db_path
        self.refresh_list()

    def refresh_list(self):
        self.tree.delete(*self.tree.get_children())
        self.editor.delete("1.0", tk.END)
        
        if not self.active_db or not os.path.exists(self.active_db): return
        
        try:
            conn = sqlite3.connect(self.active_db)
            rows = conn.execute("SELECT id, vfs_path, status FROM files ORDER BY vfs_path").fetchall()
            conn.close()
            
            for rid, path, status in rows:
                display = f"[{status}] {path}"
                self.tree.insert("", "end", iid=rid, text=display, values=(path,))
        except Exception as e:
            print(f"Tree load error: {e}")

    def _on_select(self, event):
        sel = self.tree.selection()
        if not sel: return
        file_id = sel[0]
        
        try:
            conn = sqlite3.connect(self.active_db)
            row = conn.execute("SELECT content FROM files WHERE id=?", (file_id,)).fetchone()
            conn.close()
            
            self.editor.delete("1.0", tk.END)
            if row and row[0]:
                self.editor.insert("1.0", row[0])
            else:
                self.editor.insert("1.0", "(Binary content or empty)")
        except: pass




--------------------------------------------------------------------------------
FILE: src\microservices\refinery_service.py
--------------------------------------------------------------------------------
import json
import re
from typing import Dict, List
from .base_service import BaseService
from .cartridge_service import CartridgeService
from .neural_service import NeuralService
from .semantic_chunker import SemanticChunker

class RefineryService(BaseService):
    """
    The Night Shift.
    Polls the DB for 'RAW' files and processes them into Chunks and Graph Nodes.
    """

    def __init__(self, cartridge: CartridgeService, neural: NeuralService):
        super().__init__("RefineryService")
        self.cartridge = cartridge
        self.neural = neural
        self.chunker = SemanticChunker()
        
        # Simple regex for imports (Python/JS)
        self.import_pattern = re.compile(r'(?:from|import)\s+([\w\.]+)|require\([\'"]([\w\.\-/]+)[\'"]\)')

    def process_pending(self, batch_size: int = 5) -> int:
        """Main loop. Returns number of files processed."""
        pending = self.cartridge.get_pending_files(limit=batch_size)
        if not pending: return 0

        self.log_info(f"Refining batch of {len(pending)} files...")
        
        for file_row in pending:
            self._refine_file(file_row)
            
        return len(pending)

    def _refine_file(self, row: Dict):
        file_id = row['id']
        vfs_path = row['vfs_path']
        content = row['content']
        
        # Skip binary files for now (unless we add OCR later)
        if not content:
            self.cartridge.update_status(file_id, "SKIPPED_BINARY")
            return

        try:
            # 1. Semantic Chunking
            chunks = self.chunker.chunk_file(content, vfs_path)
            
            # 2. Vectorization & Storage
            conn = self.cartridge._get_conn()
            for i, chunk in enumerate(chunks):
                # Embedding
                vector = self.neural.get_embedding(chunk.content)
                vec_blob = json.dumps(vector).encode('utf-8') if vector else None
                
                # Store Chunk
                conn.execute("""
                    INSERT INTO chunks (file_id, chunk_index, content, embedding, name, type, start_line, end_line)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (file_id, i, chunk.content, vec_blob, chunk.name, chunk.type, chunk.start_line, chunk.end_line))

                # Graph Node for Chunks (Functions/Classes)
                if chunk.type in ['class', 'function']:
                    node_id = f"{vfs_path}::{chunk.name}"
                    self.cartridge.add_node(node_id, 'chunk', chunk.name, {'parent': vfs_path})
                    self.cartridge.add_edge(node_id, vfs_path, "defined_in")

            conn.commit()
            conn.close()

            # 3. File Level Graph Node
            self.cartridge.add_node(vfs_path, 'file', vfs_path.split('/')[-1], {'path': vfs_path})

            # 4. Import Weaving (Simple)
            self._weave_imports(vfs_path, content)

            self.cartridge.update_status(file_id, "REFINED")

        except Exception as e:
            self.log_error(f"Refining failed for {vfs_path}: {e}")
            self.cartridge.update_status(file_id, "ERROR", {"error": str(e)})

    def _weave_imports(self, source_path: str, content: str):
        """Scans content for imports and links them in the graph."""
        lines = content.splitlines()
        for line in lines:
            match = self.import_pattern.search(line)
            if match:
                # Extract the import name (e.g., 'os', 'numpy', './utils')
                imp = match.group(1) or match.group(2)
                if imp:
                    # Heuristic: Link to any node ID that contains this string
                    # Real implementation would do path resolution, but this creates the visual structure effectively.
                    self.cartridge.add_edge(source_path, imp, "imports")
--------------------------------------------------------------------------------
FILE: src\microservices\scanner.py
--------------------------------------------------------------------------------
import os
import time
import requests
from urllib.parse import urljoin, urlparse
from typing import Dict, List, Any, Optional

# Try imports for Web/PDF support
try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

class ScannerMS:
    """
    The Scanner: Walks file systems OR crawls websites (Depth-Aware).
    """
    
    def __init__(self):
        self.IGNORE_DIRS = {
            '.git', '__pycache__', 'node_modules', 'venv', '.env', 
            '.idea', '.vscode', 'dist', 'build', 'coverage', 'site-packages'
        }
        self.BINARY_EXTENSIONS = {
            '.pyc', '.pyd', '.exe', '.dll', '.so', '.dylib', '.class', 
            '.jpg', '.jpeg', '.png', '.gif', '.ico', 
            '.zip', '.tar', '.gz', '.docx', '.xlsx',
            '.db', '.sqlite', '.sqlite3'
        }
        self.visited_urls = set()

    def is_binary(self, file_path: str) -> bool:
        _, ext = os.path.splitext(file_path)
        if ext.lower() in self.BINARY_EXTENSIONS: return True
        return False

    def scan_directory(self, root_path: str, web_depth: int = 0) -> Optional[Dict[str, Any]]:
        """
        Main Entry Point.
        :param root_path: File path or URL.
        :param web_depth: How many links deep to crawl (0 = single page).
        """
        # 1. Web Crawl Mode
        if root_path.startswith("http://") or root_path.startswith("https://"):
            self.visited_urls.clear()
            return self._crawl_web_recursive(root_path, depth=web_depth, origin_domain=urlparse(root_path).netloc)

        # 2. Local File System Mode
        target = os.path.abspath(root_path)
        if not os.path.exists(target): return None
        
        if not os.path.isdir(target): 
            return self._create_node(target, is_dir=False)
            
        return self._scan_fs_recursive(target)

    # --- Web Logic ---
    def _crawl_web_recursive(self, url: str, depth: int, origin_domain: str) -> Dict[str, Any]:
        """
        Recursively fetches links.
        """
        node = {
            'text': url, 
            'path': url, 
            'type': 'web', 
            'children': [], 
            'checked': True
        }
        
        if depth < 0 or url in self.visited_urls: return node
        self.visited_urls.add(url)

        if depth > 0 and BeautifulSoup:
            try:
                # Polite Delay
                time.sleep(0.1)
                resp = requests.get(url, timeout=5)
                if resp.status_code == 200:
                    soup = BeautifulSoup(resp.content, 'html.parser')
                    for link in soup.find_all('a', href=True):
                        full_url = urljoin(url, link['href'])
                        parsed = urlparse(full_url)
                        
                        # Filter: Only same domain, valid schemes
                        if parsed.netloc == origin_domain and parsed.scheme in ['http', 'https']:
                            if full_url not in self.visited_urls:
                                child_node = self._crawl_web_recursive(full_url, depth - 1, origin_domain)
                                node['children'].append(child_node)
            except Exception as e:
                node['error'] = str(e)
                
        return node

    # --- File System Logic ---
    def _scan_fs_recursive(self, current_path: str) -> Dict[str, Any]:
        node = self._create_node(current_path, is_dir=True)
        node['children'] = []
        try:
            with os.scandir(current_path) as it:
                entries = sorted(it, key=lambda e: (not e.is_dir(), e.name.lower()))
                for entry in entries:
                    if entry.is_dir() and entry.name in self.IGNORE_DIRS: continue
                    if entry.name.startswith('.'): continue

                    if entry.is_dir():
                        child = self._scan_fs_recursive(entry.path)
                        if child: node['children'].append(child)
                    else:
                        node['children'].append(self._create_node(entry.path, is_dir=False))
        except PermissionError:
            node['error'] = "Access Denied"
        return node

    def _create_node(self, path: str, is_dir: bool) -> Dict[str, Any]:
        name = os.path.basename(path)
        node = {'text': name, 'path': path, 'type': 'folder' if is_dir else 'file', 'checked': False}
        if not is_dir and self.is_binary(path): node['type'] = 'binary'
        return node

    def flatten_tree(self, tree_node: Dict[str, Any]) -> List[str]:
        files = []
        if tree_node['type'] in ['file', 'web']:
            files.append(tree_node['path'])
        elif 'children' in tree_node:
            for child in tree_node['children']:
                files.extend(self.flatten_tree(child))
        return files
--------------------------------------------------------------------------------
FILE: src\microservices\semantic_chunker.py
--------------------------------------------------------------------------------
import ast
from dataclasses import dataclass
from typing import List

@dataclass
class CodeChunk:
    name: str          # e.g., "class AuthMS"
    type: str          # "class", "function", "text"
    content: str       # The raw source
    start_line: int
    end_line: int
    docstring: str = "" # Captured separately for high-quality RAG

class SemanticChunker:
    """
    Intelligent Code Splitter.
    Parses source code into logical units (Classes, Functions) 
    rather than arbitrary text windows.
    """
    
    def chunk_file(self, content: str, filename: str) -> List[CodeChunk]:
        if filename.endswith(".py"):
            return self._chunk_python(content)
        return self._chunk_generic(content)

    def _chunk_python(self, source: str) -> List[CodeChunk]:
        chunks = []
        try:
            tree = ast.parse(source)
            lines = source.splitlines(keepends=True)
            
            def get_segment(node):
                start = node.lineno - 1
                end = node.end_lineno if hasattr(node, 'end_lineno') else start + 1
                return "".join(lines[start:end]), start + 1, end

            for node in tree.body:
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ""
                    chunks.append(CodeChunk(
                        name=f"def {node.name}", type="function", 
                        content=text, start_line=s, end_line=e, docstring=doc
                    ))
                elif isinstance(node, ast.ClassDef):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ""
                    chunks.append(CodeChunk(
                        name=f"class {node.name}", type="class", 
                        content=text, start_line=s, end_line=e, docstring=doc
                    ))

            # Fallback: If no classes/functions found (e.g., script file), treat as generic
            if not chunks:
                return self._chunk_generic(source)
                
        except SyntaxError:
            return self._chunk_generic(source)
            
        return chunks

    def _chunk_generic(self, text: str, window_size: int = 1500) -> List[CodeChunk]:
        """Sliding window for non-code files."""
        chunks = []
        lines = text.splitlines(keepends=True)
        current_chunk = []
        current_size = 0
        chunk_idx = 1
        start_line = 1
        
        for i, line in enumerate(lines):
            current_chunk.append(line)
            current_size += len(line)
            
            if current_size >= window_size:
                chunks.append(CodeChunk(
                    name=f"Chunk {chunk_idx}", type="text_block",
                    content="".join(current_chunk), start_line=start_line, end_line=i + 1
                ))
                current_chunk = []
                current_size = 0
                chunk_idx += 1
                start_line = i + 2
                
        if current_chunk:
            chunks.append(CodeChunk(
                name=f"Chunk {chunk_idx}", type="text_block",
                content="".join(current_chunk), start_line=start_line, end_line=len(lines)
            ))
            
        return chunks

--------------------------------------------------------------------------------
FILE: src\microservices\thought_stream.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk
import datetime

class ThoughtStream(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.header = ttk.Label(self, text="NEURAL INSPECTOR", font=("Consolas", 10, "bold"))
        self.header.pack(fill="x", padx=5, pady=5)
        
        self.canvas = tk.Canvas(self, bg="#13131f", highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = tk.Frame(self.canvas, bg="#13131f")
        
        self.scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw", width=340)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

    def add_thought_bubble(self, filename, chunk_id, content, vector_preview, color):
        bubble = tk.Frame(self.scrollable_frame, bg="#1a1a25", highlightbackground="#444", highlightthickness=1)
        bubble.pack(fill="x", padx=5, pady=5)
        
        ts = datetime.datetime.now().strftime("%H:%M:%S")
        tk.Label(bubble, text=f"{filename} #{chunk_id} [{ts}]", fg="#007ACC", bg="#1a1a25", font=("Consolas", 8)).pack(anchor="w", padx=5, pady=2)
        
        snippet = content[:400] + "..." if len(content) > 400 else content
        tk.Label(bubble, text=snippet, fg="#ccc", bg="#10101a", font=("Consolas", 8), justify="left", wraplength=300).pack(fill="x", padx=5, pady=2)
        
        self._draw_sparkline(bubble, vector_preview, color)

    def _draw_sparkline(self, parent, vector, color):
        if not vector: return
        h = 30
        w = 300
        cv = tk.Canvas(parent, height=h, width=w, bg="#1a1a25", highlightthickness=0)
        cv.pack(padx=5, pady=2)
        bar_w = w / len(vector)
        for i, val in enumerate(vector):
            mag = abs(val) 
            bar_h = mag * h
            x0 = i * bar_w
            y0 = h - bar_h
            x1 = x0 + bar_w
            y1 = h
            cv.create_rectangle(x0, y0, x1, y1, fill=color, outline="")
--------------------------------------------------------------------------------
FILE: src\microservices\__init__.py
--------------------------------------------------------------------------------
