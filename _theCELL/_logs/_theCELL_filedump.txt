Dump: C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL


--------------------------------------------------------------------------------
FILE: .gitignore
--------------------------------------------------------------------------------
# ============================================================
# _theCELL / _UsefulHelperSCRIPTS - Python + Tkinter
# ============================================================

# --- Python bytecode / caches ---
__pycache__/
*.py[cod]
*$py.class
.pytest_cache/
.mypy_cache/
.ruff_cache/
.pyre/
.pytype/
.coverage
.coverage.*
htmlcov/

# --- Virtual environments (keep crawlers out) ---
.venv/
venv/
ENV/
env/
.conda/
.condarc
pip-wheel-metadata/

# --- Packaging / build artifacts ---
build/
dist/
*.egg-info/
.eggs/
pip-log.txt

# --- IDE / editor ---
.vscode/
.idea/
*.code-workspace

# --- OS junk ---
.DS_Store
Thumbs.db
Desktop.ini

# --- Logs / temp ---
*.log
*.tmp
*.temp
*.swp
*~
.cache/
_logs

# --- App persistence / generated data ---
_db/
*.db
*.sqlite
*.sqlite3
*.db-journal
*.sqlite-journal
*.wal
*.shm

# --- JSONL / session artifacts (generated) ---
*.jsonl
memory_archive_*.jsonl
working_memory*.jsonl
session_*.jsonl

# --- Common local config/secrets (don’t commit) ---
.env
.env.*
*.env
secrets.json
config.local.json
app_config.json
app_config.json.tmp

# --- Vector / RAG stores (often large + machine-local) ---
knowledge_base/
chroma/
chromadb/
vector_store/
vectors/
*.faiss
*.index

# --- Jupyter / notebooks (if any) ---
.ipynb_checkpoints/

# --- Optional: if you ever dump reports/maps locally ---
*_project_map.txt
*_filedump.txt
*_folder_tree.txt
reports/
output/

--------------------------------------------------------------------------------
FILE: LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
requests>=2.28.0
pydantic>=1.10.0,<2.0.0
chromadb>=0.3.21
faiss-cpu>=1.7.4
numpy>=1.21.0


--------------------------------------------------------------------------------
FILE: setup_env.bat
--------------------------------------------------------------------------------
@echo off
setlocal

echo [STATUS] Searching for Python 3.10...
py -3.10 --version >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERROR] Python 3.10 was not found. Please install it from python.org.
    pause
    exit /b
)

echo [STATUS] Setting up _theCELL Environment with Python 3.10...
if not exist .venv (
    py -3.10 -m venv .venv
)

call .venv\Scripts\activate

echo [STATUS] Installing dependencies from requirements.txt...
python -m pip install --upgrade pip
python -m pip install -r requirements.txt

echo [STATUS] Setup Complete.
echo ----------------------------------------------------------------------
echo  Starting _theCELL Idea Ingestor...
echo ----------------------------------------------------------------------
python -m src.app
pause

--------------------------------------------------------------------------------
FILE: src\app.py
--------------------------------------------------------------------------------
import uuid
from datetime import datetime
from .backend import Backend
from .ui import CELL_UI
from src.microservices._TkinterAppShellMS import TkinterAppShellMS
from src.cell_identity import CellRegistry

def main():
    # Create global cell registry (singleton for the application)
    global_registry = CellRegistry()
    
    # Initialize the logic hub
    backend = Backend(registry=global_registry)

    # Load persisted theme preference (default Dark)
    theme = (backend.get_setting('theme_preference') or 'Dark').strip().title()
    if theme not in ('Dark', 'Light'):
        theme = 'Dark'
    
    # Initialize the Mother Ship (Shell)
    shell = TkinterAppShellMS({
        "title": f"_theCELL [{backend.cell_name}]",
        "geometry": "1000x800",
        "theme": theme
    })
    
    # --- Global Orchestration State ---
    cell_registry = {}  # { session_id: backend_instance }

    def broadcast_registry_update():
        """Informs all cells of the current list of available targets."""
        active_cells = global_registry.get_all_cells()
        cell_data = {
            cid: {"id": cid, "name": identity.cell_name}
            for cid, identity in active_cells.items()
        }
        for b_instance in cell_registry.values():
            b_instance.bus.emit("update_registry", cell_data)

    def register_cell_orchestration(target_backend):
        """Wires a backend into the global recursive and nexus pipelines."""
        
        # 1. Handle Recursive Spawning
        def on_spawn_request(data):
            print(f"[System] Spawning child from: {data.get('spawn_timestamp')}")
            
            # Determine parent identity
            p_id = getattr(target_backend, 'cell_id', 'unknown')
            
            # Create unique session file (timestamp-based, independent of cell_id)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
            unique_session_id = f"session_{timestamp}.jsonl"
            
            # Create child backend (identity auto-generated via CellRegistry)
            child_backend = Backend(
                registry=global_registry,
                memory_path=unique_session_id,
                cell_id=None,      # Auto-generate unique ID
                parent_id=p_id,
                cell_name=None     # Auto-generate default name
            )
            
            # Create window with auto-generated cell name
            child_win = shell.spawn_window(title=f"_theCELL [{child_backend.cell_name}]", geometry="900x700")
            
            # Parent-child relationship auto-managed by registry (no manual children_ids)
            
            # Shell Proxy for Child Window
            class ShellProxy:
                def __init__(self, root, colors):
                    self.root = root
                    self.colors = colors
                def get_main_container(self): return self.root
            
            child_proxy = ShellProxy(child_win, shell.colors)
            
            # Wire orchestration BEFORE CELL_UI fires register_cell signal
            register_cell_orchestration(child_backend)
            
            child_ui = CELL_UI(child_proxy, child_backend)
            
            # Hydrate DNA into child cell based on send destination
            source = data.get('source_artifact', {})
            send_dest = source.get('send_destination', 'steps')
            send_content = source.get('send_content', source.get('payload', ''))
            source_name = source.get('source_name', getattr(target_backend, 'cell_name', 'Unknown'))

            if send_dest == 'steps':
                child_ui.add_onto_step(source_name, send_content)
            else:
                child_ui.append_to_task(send_content)

            child_ui.prompt_text.delete("1.0", "end")
            child_ui.prompt_text.insert("1.0", source.get('instructions', {}).get('system_prompt', ''))

        target_backend.bus.subscribe("cell_spawn_requested", on_spawn_request)

        # 2. Handle Identity & Registry
        def on_cell_registered(reg_data):
            cid = reg_data['id']
            cell_registry[cid] = target_backend
            print(f"[Registry] Cell Registered: {cid}")
            broadcast_registry_update()
        
        target_backend.bus.subscribe("register_cell", on_cell_registered)

        # 3. Handle Nexus/Data Pushing (The Router)
        def on_push_request(payload):
            target_id = payload.get('target_id')
            if target_id in cell_registry:
                print(f"[Nexus] Routing data from {payload.get('source_id')} to {target_id}")
                cell_registry[target_id].bus.emit("push_to_nexus", payload)

        target_backend.bus.subscribe("push_to_nexus", on_push_request)

    # Wire orchestration BEFORE CELL_UI fires register_cell signal
    register_cell_orchestration(backend)

    # Dock the UI into the shell
    app_ui = CELL_UI(shell, backend)
    
    # Ignition
    shell.launch()

if __name__ == "__main__":
    main()









--------------------------------------------------------------------------------
FILE: src\backend.py
--------------------------------------------------------------------------------
import sqlite3
import os
import json
import logging
import threading
from datetime import datetime
from typing import List, Dict, Optional, Any, Tuple
from src.microservices._IngestEngineMS import IngestEngineMS
from src.microservices._FeedbackValidationMS import FeedbackValidationMS
from src.microservices._SignalBusMS import SignalBusMS
from src.microservices._CognitiveMemoryMS import CognitiveMemoryMS
from src.microservices._HydrationFactoryMS import HydrationFactoryMS
from src.microservices._ErrorNotifierMS import ErrorNotifierMS
from src.microservices._ConfigStoreMS import ConfigStoreMS
from src.microservices._CodeFormatterMS import CodeFormatterMS
from src.microservices._TreeMapperMS import TreeMapperMS
from src.microservices._VectorFactoryMS import VectorFactoryMS
from src.microservices.microservice_std_lib import service_metadata
from src.cell_identity import CellIdentity, CellRegistry

class Backend:
    """
    ROLE: Orchestration / Logic Hub
    SERVICES: Ingest, Validation, SignalBus, Memory, Factory, Notifier, ConfigStore
    STATE: Persistent (SQLite / JSON)
    """
    def __init__(self, registry: CellRegistry, db_path: str = None, memory_path: str = None, 
                 cell_id: str = None, parent_id: str = None, cell_name: str = None):
        # BOOTSTRAP: Define persistence paths
        project_root = os.path.abspath(os.getcwd())
        db_dir = os.path.join(project_root, "_db")
        os.makedirs(db_dir, exist_ok=True)

        # IDENTITY: Traceable lineage and naming (integrated with CellRegistry)
        self.identity = CellIdentity(cell_id, cell_name, parent_id)
        
        # Convenience accessors (backward compatible)
        self.cell_id = self.identity.cell_id
        self.cell_name = self.identity.cell_name
        self.parent_id = self.identity.parent_id
        self.children_ids = list(self.identity.children.keys())
        
        # Store registry reference and register this cell
        self.registry = registry
        self.registry.register_cell(self.identity)

        if db_path is None:
            db_path = os.path.join(db_dir, "app_internal.db")

        self.db_path = db_path
        self.logger = logging.getLogger(self.__class__.__name__)
        self._init_db()

        self.engine = IngestEngineMS()
        self.validator = FeedbackValidationMS()
        self.bus = SignalBusMS()
        self.notifier = ErrorNotifierMS(self.bus)
        self.config_store = ConfigStoreMS()

        # BOOTSTRAP: Initialize Specialists (orchestration-owned)
        self.formatter = CodeFormatterMS()
        self.mapper = TreeMapperMS()
        self.vector_factory = VectorFactoryMS()

        # DI: Package and inject services into the Fabricator
        specialists = {
            'formatter': self.formatter,
            'mapper': self.mapper,
            'vector_factory': self.vector_factory,
            'ingest_engine': self.engine
        }
        self.factory = HydrationFactoryMS(services=specialists)
        
        # Configure memory with Long-Term flush capability (Phase 7)
        mem_config = {
             'persistence_path': memory_path,
            'summarizer_func': self._summarize_memory_stub, 
            'long_term_ingest_func': self._flush_to_vector_db
        } if memory_path else {
            'summarizer_func': self._summarize_memory_stub,
            'long_term_ingest_func': self._flush_to_vector_db
        }
        self.memory = CognitiveMemoryMS(config=mem_config)
        
        # Initialize state from persistent storage
        self.system_role: str = self.get_setting('last_system_role') or "You are a helpful AI assistant."

    def get_models(self):
        """Fetches available Ollama models."""
        models = self.engine.get_available_models()
        return models if models else ["No Models Found"]

    def set_system_role(self, role_text: str) -> None:
        self.system_role = role_text
        self.save_setting('last_system_role', role_text)

    def _init_db(self) -> None:
        # TASK: Schema Initialization
        # SCOPE: Personas, Roles, Prompts
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.executescript("""
                    -- SECTION: IDENTITY REPOSITORIES --
                    CREATE TABLE IF NOT EXISTS personas (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT UNIQUE,
                        role_text TEXT,
                        sys_prompt_text TEXT,
                        task_prompt_text TEXT,
                        is_default INTEGER DEFAULT 0,
                        last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                    CREATE TABLE IF NOT EXISTS saved_roles (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                    CREATE TABLE IF NOT EXISTS saved_sys_prompts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                    CREATE TABLE IF NOT EXISTS saved_task_prompts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                """)

                # --- Lightweight migration for existing DBs ---
                # If the DB already existed, the personas table may be missing columns.
                try:
                    cols = {row[1] for row in conn.execute("PRAGMA table_info(personas)").fetchall()}
                    if 'task_prompt_text' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN task_prompt_text TEXT")
                    if 'last_modified' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
                    if 'is_default' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN is_default INTEGER DEFAULT 0")
                except sqlite3.Error as mig_e:
                    self.logger.error(f"Personas migration failed: {mig_e}")

        except sqlite3.Error as e:
            self.logger.error(f"Database initialization failed: {e}")

    def save_setting(self, key: str, value: Any) -> None:
        self.config_store.set(key, value)

    def get_setting(self, key: str) -> Optional[Any]:
        return self.config_store.get(key)

    def save_persona(self, name: str, role: str, sys_prompt: str, task_prompt: str = "", is_default: bool = False) -> bool:
        """Persist or update a bonded AI Persona template."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if is_default:
                    conn.execute("UPDATE personas SET is_default = 0")

                # Use UPSERT so we UPDATE in-place on name collisions instead of DELETE+INSERT (OR REPLACE)
                conn.execute(
                    """
                    INSERT INTO personas (name, role_text, sys_prompt_text, task_prompt_text, is_default, last_modified)
                    VALUES (?, ?, ?, ?, ?, ?)
                    ON CONFLICT(name) DO UPDATE SET
                        role_text=excluded.role_text,
                        sys_prompt_text=excluded.sys_prompt_text,
                        task_prompt_text=excluded.task_prompt_text,
                        is_default=excluded.is_default,
                        last_modified=excluded.last_modified
                    """,
                    (name, role, sys_prompt, task_prompt, 1 if is_default else 0, datetime.now().isoformat())
                )
            return True
        except sqlite3.Error as e:
            self.logger.error(f"Failed to save persona '{name}': {e}")
            return False

    def get_default_item(self, table_name: str) -> Optional[str]:
        """Retrieves the content of the item flagged as default for a given table."""
        with sqlite3.connect(self.db_path) as conn:
            col = "role_text" if table_name == 'personas' else "content"
            res = conn.execute(f"SELECT {col} FROM {table_name} WHERE is_default = 1").fetchone()
            return res[0] if res else None

    def get_repository_items(self, table_name: str) -> List[Tuple[int, str, str, int]]:
        """Generic fetch for any repository table including default flag."""
        valid_tables = ['saved_roles', 'saved_sys_prompts', 'saved_task_prompts', 'personas']
        if table_name not in valid_tables: return []
        
        with sqlite3.connect(self.db_path) as conn:
            # Personas uses role_text for the 'Preview' column
            if table_name == 'personas':
                return conn.execute("SELECT id, name, role_text, is_default FROM personas ORDER BY name ASC").fetchall()
            return conn.execute(f"SELECT id, name, content, is_default FROM {table_name} ORDER BY name ASC").fetchall()

    def save_repository_item(self, table_name: str, name: str, content: str, is_default: bool = False) -> bool:
        """Universal save for modular instruction fragments with default enforcement."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if is_default:
                    conn.execute(f"UPDATE {table_name} SET is_default = 0")
                conn.execute(f"INSERT OR REPLACE INTO {table_name} (name, content, is_default) VALUES (?, ?, ?)", 
                             (name, content, 1 if is_default else 0))
            return True
        except sqlite3.Error as e:
            self.logger.error(f"Repo save failed for {table_name}: {e}")
            return False

    def set_as_default(self, table_name: str, item_id: int) -> None:
        """Sets a specific item as the default for its repository."""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(f"UPDATE {table_name} SET is_default = 0")
            conn.execute(f"UPDATE {table_name} SET is_default = 1 WHERE id = ?", (item_id,))

    def delete_repository_item(self, table_name: str, item_id: int) -> bool:
        """Generic delete for any repository table."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(f"DELETE FROM {table_name} WHERE id = ?", (item_id,))
            return True
        except sqlite3.Error: return False

    def process_submission(self, content: str, model: str, role: str, prompt: str, inherited_context: str = "") -> Dict[str, Any]:
        # ACTION: Generate Artifact -> Start Threaded Inference
        # INPUTS: content (raw), model (ID), role (text), prompt (text)
        artifact = {
            "metadata": {
                "model": model,
                "timestamp": datetime.now().isoformat(),
                "source": "_theCELL_Idea_Ingestor",
                "version": "1.0.0"
            },
            "instructions": {
                "system_role": role,
                "system_prompt": prompt,
                "inherited_context": inherited_context
            },
            "payload": content.strip()
        }

        # Add User Input to Working Memory
        self.memory.add_entry(role="user", content=content, metadata=artifact['metadata'])

        self.logger.info(f"Artifact generated for model: {model}")
        self.bus.emit(SignalBusMS.SIGNAL_PROCESS_START, artifact)

        # The Pulse: Start Threaded Inference
        thread = threading.Thread(target=self._run_inference_thread, args=(artifact,))
        thread.daemon = True
        thread.start()

        return artifact

    def _run_inference_thread(self, artifact: Dict[str, Any]):
        """
        Background worker that streams tokens from the Engine to the SignalBus.
        """
        try:
            model = artifact['metadata']['model']
            sys_role = artifact['instructions']['system_role']
            sys_prompt = artifact['instructions']['system_prompt']
            inherited = artifact['instructions'].get('inherited_context', '')
            user_payload = artifact['payload']

            # Structured Prompt Construction: Role > System > Request > Last Response
            full_system = f"ROLE: {sys_role}\n\nSYSTEM INSTRUCTIONS:\n{sys_prompt}".strip()
            
            if inherited:
                user_payload = f"TASK: {user_payload}\n\n### REFERENCE CONTEXT (LAST RESPONSE) ###\n{inherited}"

            response_buffer = []
            
            # Connect to IngestEngine stream
            stream = self.engine.generate_stream(prompt=user_payload, model=model, system=full_system)
            
            for token in stream:
                # Emit token to UI
                self.bus.emit(SignalBusMS.SIGNAL_LOG_APPEND, token)
                response_buffer.append(token)

            final_response = "".join(response_buffer)
            
            # Hydrate artifact with result
            artifact['response'] = final_response
            
            # Add AI Response to Working Memory
            self.memory.add_entry(role="assistant", content=final_response, metadata=artifact['metadata'])

            # Signal Completion (UI triggers HITL buttons)
            self.bus.emit(SignalBusMS.SIGNAL_PROCESS_COMPLETE, artifact)

        except Exception as e:
            error_msg = f"Inference failed: {str(e)}"
            self.logger.error(error_msg)
            self.bus.emit(SignalBusMS.SIGNAL_LOG_APPEND, f"\n[SYSTEM ERROR]: {error_msg}")

    def spawn_child(self, parent_artifact: Dict[str, Any]) -> None:
        """
        Prepares a new Cell by combining the parent's product with the current memory context,
        then emits a signal requesting the UI to launch the new window.
        """
        # 1. Summarize Parent Context (The Hippocampus)
        context_summary = self.memory.get_context(limit=10)
        
        # 2. Create Child DNA
        child_payload = {
            "source_artifact": parent_artifact,
            "inherited_context": context_summary,
            "spawn_timestamp": datetime.now().isoformat()
        }

        self.logger.info("Spawning child cell requested...")
        
        # 3. Signal the System (AppShell) to launch the GUI
        self.bus.emit(SignalBusMS.SIGNAL_SPAWN_REQUESTED, child_payload)

    # --- INTEGRATION: Hydration & Export ---
    def export_artifact(self, artifact: Dict[str, Any], destination: str, path: str = None) -> Dict[str, Any]:
        # ROLE: Factory Router
        # MODES: scaffold, memory, blueprint
        try:
            mode_map = {"File": "scaffold", "Vector": "memory", "Project Capture": "blueprint"}
            mode = mode_map.get(destination, "scaffold")
            
            # If Vector, we assume a default collection if not specified
            target = path if path else ("cell_memory_bank" if destination == "Vector" else "export.txt")
            
            return self.factory.hydrate_artifact(artifact, mode=mode, destination=target)
        except Exception as e:
            self.bus.emit(SignalBusMS.SIGNAL_ERROR, {"message": f"Export failed: {str(e)}", "level": "ERROR"})
            return {"status": "error", "message": str(e)}

    # --- Phase 5: Feedback Loop ---
    def record_feedback(self, artifact: Dict[str, Any], is_accepted: bool) -> None:
        """Submits the turn to the FeedbackValidator for training."""
        self.validator.validate_artifact(artifact, is_accepted)

    def push_to_target(self, target_cell_id: str, content: str) -> None:
        """Emits a signal to push content to a specific Nexus/Ledger cell."""
        payload = {
            "target_id": target_cell_id,
            "content": content,
            "source_id": getattr(self, 'session_id', 'unknown')
        }
        self.bus.emit(SignalBusMS.SIGNAL_PUSH_DATA, payload)

    # --- Phase 7: Long-Term Memory Helpers ---
    def _summarize_memory_stub(self, text: str) -> str:
        """Simple truncation summarizer. Ideally uses an LLM call."""
        return f"Session Summary [{datetime.now().isoformat()}]: {text[:200]}..."

    def _flush_to_vector_db(self, text: str, metadata: Dict[str, Any]) -> None:
        """Callback for CognitiveMemory to save flushed context to Vector Store."""
        artifact = {
            "payload": text,
            "metadata": metadata
        }
        # We use the factory to 'hydrate' this into the memory bank
        self.factory.hydrate_artifact(artifact, mode="memory", destination="long_term_history")

    def rename_cell(self, new_name: str) -> None:
        """
        User-facing method to rename this cell.
        Propagates change through registry to all references.
        """
        old_name = self.cell_name
        self.registry.rename_cell(self.cell_id, new_name)
        
        # Update local reference
        self.cell_name = self.identity.cell_name
        
        # Emit signals for UI update
        self.bus.emit("cell_renamed", {
            "cell_id": self.cell_id,
            "old_name": old_name,
            "new_name": new_name
        })
        
        self.bus.emit("update_window_title", f"_theCELL [{self.cell_name}]")

    def get_family_tree(self) -> dict:
        """
        Returns detailed family relationship data for this cell.
        """
        return {
            "identity": self.identity.to_dict(),
            "lineage": self.registry.get_lineage(self.cell_id),
            "children": self.registry.get_children(self.cell_id),
            "descendants": self.registry.get_descendants(self.cell_id)
        }

    def close_cell(self) -> None:
        """
        Clean up when cell window is closed.
        Unregisters from global registry.
        """
        self.registry.unregister_cell(self.cell_id)























--------------------------------------------------------------------------------
FILE: src\cell_identity.py
--------------------------------------------------------------------------------
"""
Cell Identity Management System for _theCELL
============================================

This module provides identity and relationship tracking for the cognitive cell
architecture. Each cell has a unique ID, user-renameable name, and maintains
bidirectional parent-child relationships with automatic name propagation.

Classes:
    CellIdentity: Manages a single cell's identity and relationships
    CellRegistry: Global registry coordinating all cells with name propagation

Author: Jacob Lambert
License: MIT
"""

import uuid
import threading
from typing import Dict, List, Optional, Set, Tuple
from datetime import datetime


class CellIdentity:
    """
    Represents the identity and relationship data for a single cognitive cell.
    
    Each cell has:
    - A unique, collision-resistant ID (auto-generated if not provided)
    - A human-readable name (auto-generated default, user-renameable)
    - Parent cell reference (if spawned from another cell)
    - Children cell references (if this cell has spawned others)
    - Creation and rename timestamps
    
    Attributes:
        cell_id (str): Unique identifier for this cell
        cell_name (str): Human-readable name
        parent_id (Optional[str]): ID of parent cell, None if root
        children (Dict[str, str]): Map of child_id -> child_name
        created_at (str): ISO timestamp of creation
        renamed_at (Optional[str]): ISO timestamp of last rename, None if never renamed
    """
    
    def __init__(self, 
                 cell_id: str = None, 
                 cell_name: str = None, 
                 parent_id: str = None):
        """
        Initialize a cell identity.
        
        Args:
            cell_id: Unique ID (auto-generated if None)
            cell_name: Display name (auto-generated default if None)
            parent_id: Parent cell ID (None for root cells)
        """
        # Generate unique ID if not provided
        self.cell_id: str = cell_id if cell_id else self._generate_unique_id()
        
        # Generate default name if not provided
        self.cell_name: str = cell_name if cell_name else self._generate_default_name()
        
        # Relationship tracking
        self.parent_id: Optional[str] = parent_id
        self.children: Dict[str, str] = {}  # {child_id: child_name}
        
        # Metadata
        self.created_at: str = datetime.now().isoformat()
        self.renamed_at: Optional[str] = None
    
    def _generate_unique_id(self) -> str:
        """
        Generates a unique, collision-resistant cell ID.
        
        Format: cell_YYYYMMDDHHmmSS_<8-char-uuid>
        Example: cell_20260217033045_a1b2c3d4
        
        Returns:
            Unique cell identifier string
        """
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        uuid_segment = uuid.uuid4().hex[:8]
        return f"cell_{timestamp}_{uuid_segment}"
    
    def _generate_default_name(self) -> str:
        """
        Generates a human-readable default name from the cell ID.
        
        Extracts the last 8 characters of the ID for readability.
        Example: "Cell-A1B2C3D4"
        
        Returns:
            Default display name string
        """
        short_id = self.cell_id.split('_')[-1]
        return f"Cell-{short_id.upper()}"
    
    def rename(self, new_name: str) -> Tuple[str, str]:
        """
        Renames the cell and records the timestamp.
        
        Args:
            new_name: New display name for the cell
            
        Returns:
            Tuple of (old_name, new_name) for propagation tracking
        """
        old_name = self.cell_name
        self.cell_name = new_name.strip()
        self.renamed_at = datetime.now().isoformat()
        return old_name, new_name
    
    def add_child(self, child_id: str, child_name: str) -> None:
        """
        Records a child cell in this parent's registry.
        
        Args:
            child_id: Unique ID of child cell
            child_name: Display name of child cell
        """
        self.children[child_id] = child_name
    
    def remove_child(self, child_id: str) -> None:
        """
        Removes a child cell from this parent's registry.
        
        Args:
            child_id: ID of child cell to remove
        """
        if child_id in self.children:
            del self.children[child_id]
    
    def update_child_name(self, child_id: str, new_name: str) -> None:
        """
        Updates a child's name in this parent's record.
        
        Called automatically when a child cell is renamed.
        
        Args:
            child_id: ID of child cell
            new_name: Updated name of child cell
        """
        if child_id in self.children:
            self.children[child_id] = new_name
    
    def to_dict(self) -> dict:
        """
        Serializes identity to dictionary format.
        
        Useful for persistence, debugging, and export.
        
        Returns:
            Dictionary representation of this cell's identity
        """
        return {
            "cell_id": self.cell_id,
            "cell_name": self.cell_name,
            "parent_id": self.parent_id,
            "children": self.children.copy(),
            "created_at": self.created_at,
            "renamed_at": self.renamed_at
        }
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        parent_str = f"parent={self.parent_id}" if self.parent_id else "root"
        children_count = len(self.children)
        return f"CellIdentity({self.cell_name!r}, id={self.cell_id}, {parent_str}, children={children_count})"


class CellRegistry:
    """
    Global registry that tracks all active cells and manages name propagation.
    
    This is the coordination layer that:
    - Maintains the master list of all active cells
    - Enforces parent-child relationship consistency
    - Propagates name changes bidirectionally
    - Provides lineage and descendant queries
    - Thread-safe for concurrent cell operations
    
    The registry should be created once as a singleton in app.py and passed
    to all Backend instances.
    
    Attributes:
        _cells (Dict[str, CellIdentity]): Master registry of all cells
        _lock (threading.Lock): Ensures thread-safe operations
        _change_listeners (List[callable]): Callbacks for registry events
    """
    
    def __init__(self):
        """Initialize an empty cell registry."""
        self._cells: Dict[str, CellIdentity] = {}
        self._lock = threading.Lock()
        self._change_listeners: List[callable] = []
    
    def register_cell(self, identity: CellIdentity) -> None:
        """
        Registers a new cell in the global registry.
        
        Automatically updates parent's children list if parent exists.
        Notifies listeners of the registration.
        
        Args:
            identity: CellIdentity instance to register
        """
        with self._lock:
            self._cells[identity.cell_id] = identity
            
            # If this cell has a parent, update parent's children list
            if identity.parent_id and identity.parent_id in self._cells:
                parent = self._cells[identity.parent_id]
                parent.add_child(identity.cell_id, identity.cell_name)
            
            self._notify_listeners("cell_registered", identity)
    
    def unregister_cell(self, cell_id: str) -> None:
        """
        Removes a cell from the registry (called when cell window closes).
        
        Automatically removes cell from parent's children list.
        Notifies listeners of the removal.
        
        Args:
            cell_id: ID of cell to unregister
        """
        with self._lock:
            if cell_id not in self._cells:
                return
            
            identity = self._cells[cell_id]
            
            # Notify parent of child removal
            if identity.parent_id and identity.parent_id in self._cells:
                parent = self._cells[identity.parent_id]
                parent.remove_child(cell_id)
            
            # Remove from registry
            del self._cells[cell_id]
            self._notify_listeners("cell_unregistered", identity)
    
    def rename_cell(self, cell_id: str, new_name: str) -> None:
        """
        Renames a cell and propagates the change to all references.
        
        This is the core propagation mechanism:
        1. Renames the cell itself
        2. Updates parent's record of this child's name
        3. Notifies all listeners so UIs can update
        
        Args:
            cell_id: ID of cell to rename
            new_name: New display name
        """
        with self._lock:
            if cell_id not in self._cells:
                return
            
            identity = self._cells[cell_id]
            old_name, new_name = identity.rename(new_name)
            
            # Propagate to parent's children list
            if identity.parent_id and identity.parent_id in self._cells:
                parent = self._cells[identity.parent_id]
                parent.update_child_name(cell_id, new_name)
            
            # Notify all listeners of the name change
            self._notify_listeners("cell_renamed", {
                "cell_id": cell_id,
                "old_name": old_name,
                "new_name": new_name,
                "identity": identity
            })
    
    def get_cell(self, cell_id: str) -> Optional[CellIdentity]:
        """
        Retrieves a cell's identity by ID.
        
        Args:
            cell_id: ID of cell to retrieve
            
        Returns:
            CellIdentity instance or None if not found
        """
        with self._lock:
            return self._cells.get(cell_id)
    
    def get_all_cells(self) -> Dict[str, CellIdentity]:
        """
        Returns a copy of all registered cells.
        
        Safe to iterate over without holding the lock.
        
        Returns:
            Dictionary mapping cell_id -> CellIdentity
        """
        with self._lock:
            return self._cells.copy()
    
    def get_children(self, cell_id: str) -> Dict[str, str]:
        """
        Returns all direct children of a given cell.
        
        Args:
            cell_id: ID of parent cell
            
        Returns:
            Dictionary mapping child_id -> child_name (empty dict if no children)
        """
        with self._lock:
            if cell_id in self._cells:
                return self._cells[cell_id].children.copy()
            return {}
    
    def get_lineage(self, cell_id: str) -> List[str]:
        """
        Returns the full lineage from root to this cell.
        
        Walks up the parent chain to build the ancestry.
        
        Args:
            cell_id: ID of cell to get lineage for
            
        Returns:
            List of cell IDs from root to current cell
            Example: [root_id, parent_id, grandparent_id, cell_id]
        """
        lineage = []
        current_id = cell_id
        
        with self._lock:
            # Walk up the parent chain
            while current_id and current_id in self._cells:
                lineage.insert(0, current_id)
                current_id = self._cells[current_id].parent_id
        
        return lineage
    
    def get_descendants(self, cell_id: str) -> Set[str]:
        """
        Returns all descendant cell IDs recursively.
        
        Includes children, grandchildren, great-grandchildren, etc.
        
        Args:
            cell_id: ID of ancestor cell
            
        Returns:
            Set of all descendant cell IDs (empty set if no descendants)
        """
        descendants = set()
        
        def _recurse(cid: str):
            """Recursive helper to walk down the tree."""
            if cid in self._cells:
                for child_id in self._cells[cid].children.keys():
                    descendants.add(child_id)
                    _recurse(child_id)
        
        with self._lock:
            _recurse(cell_id)
        
        return descendants
    
    def get_all_roots(self) -> List[str]:
        """
        Returns IDs of all root cells (cells with no parent).
        
        Useful for displaying cell hierarchies or finding orphaned trees.
        
        Returns:
            List of root cell IDs
        """
        with self._lock:
            return [
                cid for cid, identity in self._cells.items()
                if identity.parent_id is None
            ]
    
    def cell_exists(self, cell_id: str) -> bool:
        """
        Checks if a cell ID exists in the registry.
        
        Args:
            cell_id: ID to check
            
        Returns:
            True if cell exists, False otherwise
        """
        with self._lock:
            return cell_id in self._cells
    
    def add_change_listener(self, listener: callable) -> None:
        """
        Registers a callback for registry change events.
        
        Listener signature: listener(event_type: str, data: any)
        
        Events emitted:
        - "cell_registered": data is CellIdentity
        - "cell_unregistered": data is CellIdentity
        - "cell_renamed": data is dict with cell_id, old_name, new_name
        
        Args:
            listener: Callback function to register
        """
        self._change_listeners.append(listener)
    
    def remove_change_listener(self, listener: callable) -> None:
        """
        Unregisters a change listener callback.
        
        Args:
            listener: Callback function to remove
        """
        if listener in self._change_listeners:
            self._change_listeners.remove(listener)
    
    def _notify_listeners(self, event_type: str, data) -> None:
        """
        Notifies all registered listeners of a registry change.
        
        Called internally when registry state changes.
        Listeners are called outside the lock to avoid deadlocks.
        
        Args:
            event_type: Type of event ("cell_registered", etc.)
            data: Event-specific data
        """
        # Make a copy of listeners to iterate safely
        listeners = self._change_listeners.copy()
        
        for listener in listeners:
            try:
                listener(event_type, data)
            except Exception as e:
                # Don't let listener errors crash the registry
                print(f"[CellRegistry] Listener error in {listener}: {e}")
    
    def export_registry(self) -> dict:
        """
        Exports the entire registry state as a dictionary.
        
        Useful for debugging, persistence, or analysis.
        
        Returns:
            Dictionary with registry state:
            {
                "cells": {cell_id: identity_dict, ...},
                "timestamp": ISO timestamp,
                "total_cells": count,
                "root_cells": [root_ids]
            }
        """
        with self._lock:
            return {
                "cells": {
                    cid: identity.to_dict() 
                    for cid, identity in self._cells.items()
                },
                "timestamp": datetime.now().isoformat(),
                "total_cells": len(self._cells),
                "root_cells": self.get_all_roots()
            }
    
    def get_statistics(self) -> dict:
        """
        Returns registry statistics for monitoring.
        
        Returns:
            Dictionary with statistics:
            {
                "total_cells": count,
                "root_cells": count,
                "max_depth": int,
                "average_children": float
            }
        """
        with self._lock:
            total = len(self._cells)
            roots = len(self.get_all_roots())
            
            # Calculate max depth
            max_depth = 0
            for cell_id in self._cells.keys():
                depth = len(self.get_lineage(cell_id)) - 1
                max_depth = max(max_depth, depth)
            
            # Calculate average children per cell
            total_children = sum(
                len(identity.children) 
                for identity in self._cells.values()
            )
            avg_children = total_children / total if total > 0 else 0
            
            return {
                "total_cells": total,
                "root_cells": roots,
                "max_depth": max_depth,
                "average_children": round(avg_children, 2)
            }
    
    def __len__(self) -> int:
        """Returns the number of registered cells."""
        with self._lock:
            return len(self._cells)
    
    def __contains__(self, cell_id: str) -> bool:
        """Checks if a cell ID exists (supports 'in' operator)."""
        return self.cell_exists(cell_id)
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        stats = self.get_statistics()
        return (
            f"CellRegistry(cells={stats['total_cells']}, "
            f"roots={stats['root_cells']}, "
            f"max_depth={stats['max_depth']})"
        )

--------------------------------------------------------------------------------
FILE: src\ui.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import sqlite3

class CellViewerModal(tk.Toplevel):
    """Reusable DB browser for instruction repositories."""
    def __init__(self, parent, colors, table_name, backend, on_select_callback):
        super().__init__(parent)
        self.title(f"Browse: {table_name.replace('_', ' ').title()}")
        self.geometry("600x400")
        self.configure(bg=colors.get('background'))
        self.backend = backend
        self.table_name = table_name
        self.callback = on_select_callback

        # Treeview for Tabular Data
        style = ttk.Style()
        style.configure(
            "Treeview",
            background=colors.get('entry_bg', colors.get('panel_bg')),
            foreground=colors.get('entry_fg', colors.get('foreground')),
            fieldbackground=colors.get('entry_bg', colors.get('panel_bg')),
            borderwidth=0
        )
        style.configure(
            "Treeview.Heading",
            background=colors.get('heading_bg', colors.get('panel_bg')),
            foreground=colors.get('heading_fg', colors.get('foreground'))
        )
        style.map(
            "Treeview",
            background=[('selected', colors.get('select_bg', colors.get('accent')))],
            foreground=[('selected', colors.get('select_fg', colors.get('entry_fg', colors.get('foreground'))))]
        )
        self.tree = ttk.Treeview(self, columns=("ID", "Name", "Preview", "Default"), show='headings')
        
        for col in ("ID", "Name", "Preview", "Default"): 
            self.tree.heading(col, text=col)
            self.tree.column(col, width=50 if col in ('ID', 'Default') else 150 if col == 'Name' else 250)
        
        self.tree.pack(fill='both', expand=True, padx=10, pady=10)
        self._refresh_data()

        # Subscribe to theme updates
        if hasattr(self.backend, 'bus'):
            self.backend.bus.subscribe("theme_updated", self.refresh_theme)

        self.btn_frame = tk.Frame(self, bg=colors.get('background'))
        self.btn_frame.pack(fill='x', padx=10, pady=5)
        
        btn_opts = {
            "bg": colors.get('panel_bg', colors.get('background')),
            "fg": colors.get('button_fg', colors.get('foreground')),
            "relief": "flat"
        }
        tk.Button(self.btn_frame, text="Load Selection", command=self._on_load, **btn_opts).pack(side='left', padx=5)
        tk.Button(self.btn_frame, text="Set as Default", command=self._on_default, **btn_opts).pack(side='left', padx=5)
        tk.Button(
            self.btn_frame,
            text="Delete",
            bg=colors.get('error', colors.get('accent')),
            fg=colors.get('button_fg', colors.get('foreground')),
            relief="flat",
            command=self._on_delete
        ).pack(side='right', padx=5)

    def _refresh_data(self):
        self.tree.delete(*self.tree.get_children())
        for item in self.backend.get_repository_items(self.table_name):
            # item = (id, name, content, is_default)
            self.tree.insert("", "end", values=(item[0], item[1], item[2][:100].replace('\n', ' '), "★" if item[3] else ""))

    def _on_load(self):
        selected = self.tree.selection()
        if selected:
            item_values = self.tree.item(selected[0], 'values')
            with sqlite3.connect(self.backend.db_path) as conn:
                if self.table_name == 'personas':
                    # Bonded Template: Returns a tuple for the callback to handle
                    res = conn.execute("SELECT role_text, sys_prompt_text, task_prompt_text FROM personas WHERE id=?", (item_values[0],)).fetchone()
                    if res: self.callback(res) 
                else:
                    # Atomic Fragment
                    res = conn.execute(f"SELECT content FROM {self.table_name} WHERE id=?", (item_values[0],)).fetchone()
                    if res: self.callback(res[0])
            self.destroy()

    def _on_default(self):
        selected = self.tree.selection()
        if selected:
            item_id = self.tree.item(selected[0], 'values')[0]
            self.backend.set_as_default(self.table_name, item_id)
            self._refresh_data()

    def _on_delete(self):
        selected = self.tree.selection()
        if selected:
            item_id = self.tree.item(selected[0], 'values')[0]
            self.backend.delete_repository_item(self.table_name, item_id)
            self._refresh_data()

    def refresh_theme(self, new_colors):
        self.configure(bg=new_colors.get('background'))
        self.btn_frame.configure(bg=new_colors.get('background'))
        style = ttk.Style()
        style.configure(
            "Treeview",
            background=new_colors.get('entry_bg', new_colors.get('panel_bg')),
            foreground=new_colors.get('entry_fg', new_colors.get('foreground')),
            fieldbackground=new_colors.get('entry_bg', new_colors.get('panel_bg'))
        )
        style.configure(
            "Treeview.Heading",
            background=new_colors.get('heading_bg', new_colors.get('panel_bg')),
            foreground=new_colors.get('heading_fg', new_colors.get('foreground'))
        )

class CELL_UI:
    def __init__(self, shell, backend):
        self.shell = shell
        self.backend = backend
        self.container = shell.get_main_container()
        self.colors = shell.colors

        # Phase 1: Identity & Registry
        self.session_id = self.backend.cell_id
        self.backend.session_id = self.session_id
        
        # Register with the global orchestration bus
        self.backend.bus.emit("register_cell", {
            "id": self.session_id, 
            "title": self.backend.cell_name,
            "parent_id": self.backend.parent_id
        })

        # Track singleton modals / key widgets
        self._settings_window = None
        self._rename_window = None
        self.model_lbl = None
        self.btn_save_template = None
        self.btn_load_template = None
        self.btn_submit = None

        # Panels (Step 2 stubs)
        self.panel_prompt = None
        self.panel_inference = None
        self.panel_result = None
        self.panel_export = None

        # Two-column layout containers (Step 1 layout)
        self.main_row = None
        self.left_col = None
        self.right_col = None

        # Action bar ref (so it can be themed)
        self.action_frame = None

        # Panel widgets (stubs)
        self.infer_log = None
        self.result_text = None
        self.btn_accept = None
        self.btn_reject = None
        self.btn_exit = None

        # Send To panel widgets
        self.panel_sendto = None
        self.sendto_cb = None
        self.sendto_btn = None
        self._nexus_id_map = {}
        self._response_ready = False
        
        # Restore window state from DB
        saved_geo = self.backend.get_setting('window_geometry')
        if saved_geo: self.shell.root.geometry(saved_geo)
        
        self._setup_main_window()
        self._build_context_menu()
        self._restore_component_state()
        self._register_signals()

    def _register_signals(self):
        """Connects UI to the nervous system."""
        if hasattr(self.backend, 'bus'):
            self.backend.bus.subscribe("log_append", self._on_log_append)
            self.backend.bus.subscribe("process_complete", self._on_process_complete)
            self.backend.bus.subscribe("update_registry", self._update_nexus_list)
            self.backend.bus.subscribe("push_to_nexus", self._handle_incoming_push)
            # Pass the new palette through so ttk/tk widgets can rebind safely.
            self.backend.bus.subscribe("theme_updated", self.refresh_theme)
            # Cell identity signals
            self.backend.bus.subscribe("cell_renamed", self._on_cell_renamed)
            self.backend.bus.subscribe("update_window_title", self._update_window_title)

    def _update_nexus_list(self, cell_data):
        """Updates the Send To dropdown with currently active cells."""
        # cell_data is: {cell_id: {"id": ..., "name": ...}}
        targets = [
            f"{data['name']} ({cid})"
            for cid, data in cell_data.items()
            if cid != self.session_id
        ]

        if self.sendto_cb:
            self.sendto_cb['values'] = ["New Cell"] + targets

        # Store ID mapping for lookup
        self._nexus_id_map = {
            f"{data['name']} ({cid})": cid
            for cid, data in cell_data.items()
        }

    def _update_sendto_state(self):
        """Enables or disables SEND button based on response readiness and target selection."""
        if not self.sendto_btn:
            return
        target = self.sendto_var.get() if self.sendto_var else "Select..."
        can_send = self._response_ready and target not in ("Select...", "")
        self.sendto_btn.configure(state='normal' if can_send else 'disabled')

    def _on_send_execute(self):
        """Executes the Send To action based on current selections."""
        target = self.sendto_var.get()
        content_src = self.sendto_content_var.get()
        destination = self.sendto_dest_var.get()

        # Get content to send
        if content_src == "response":
            content = self.result_text.get("1.0", "end-1c")
        else:
            content = self.input_box.get("1.0", "end-1c")

        source_name = self.backend.cell_name

        if target == "New Cell":
            artifact = self._get_current_artifact()
            artifact['send_destination'] = destination
            artifact['send_content'] = content
            artifact['source_name'] = source_name
            self.backend.spawn_child(artifact)
        else:
            target_id = self._nexus_id_map.get(target)
            if not target_id:
                return
            payload = {
                "target_id": target_id,
                "content": content,
                "source_id": self.session_id,
                "source_name": source_name,
                "destination": destination
            }
            self.backend.bus.emit("push_to_nexus", payload)

    def add_onto_step(self, source_name: str, content: str):
        """Public: Adds an ontological step (called by spawn handler or incoming push)."""
        self._onto_steps.append({"source": source_name, "content": content})
        self._rebuild_steps_ui()

    def append_to_task(self, content: str):
        """Public: Appends content to the Task box (called by spawn handler or incoming push)."""
        current = self.input_box.get("1.0", "end-1c")
        if current.strip():
            self.input_box.insert('end', f"\n\n{content}")
        else:
            self.input_box.insert('end', content)

    def _rebuild_steps_ui(self):
        """Clears and redraws all step cards in the Ontological Steps frame."""
        for widget in self.onto_steps_frame.winfo_children():
            widget.destroy()

        if not self._onto_steps:
            tk.Label(
                self.onto_steps_frame,
                text="No ontological steps yet.",
                bg=self.colors.get('background'),
                fg=self.colors.get('foreground'),
                font=("Segoe UI", 9, "italic"),
                padx=8, pady=6
            ).pack()
            return

        for idx, step in enumerate(self._onto_steps):
            is_selected = (self._selected_step == idx)
            header_bg = self.colors.get('accent') if is_selected else self.colors.get('panel_bg')
            header_fg = self.colors.get('button_fg', 'white') if is_selected else self.colors.get('foreground')

            card = tk.Frame(
                self.onto_steps_frame,
                bg=self.colors.get('panel_bg'),
                bd=1, relief='solid'
            )
            card.pack(fill='x', padx=4, pady=2)

            # Header row
            header = tk.Frame(card, bg=header_bg, cursor='hand2')
            header.pack(fill='x')

            tk.Label(
                header,
                text=f"Step {idx + 1} — Source: {step['source']}",
                bg=header_bg, fg=header_fg,
                font=("Segoe UI", 8, "bold"),
                padx=6, pady=3
            ).pack(side='left')

            _hbtn = {"bg": header_bg, "fg": header_fg, "relief": "flat",
                     "font": ("Segoe UI", 9), "cursor": "hand2", "padx": 3}
            tk.Button(header, text="✕", **_hbtn,
                command=lambda i=idx: self._remove_onto_step(i)).pack(side='right', padx=(0, 4))
            tk.Button(header, text="▼", **_hbtn,
                command=lambda i=idx: self._move_step_down(i)).pack(side='right')
            tk.Button(header, text="▲", **_hbtn,
                command=lambda i=idx: self._move_step_up(i)).pack(side='right')

            header.bind('<Button-1>', lambda e, i=idx: self._select_step(i))
            for child in header.winfo_children():
                if isinstance(child, tk.Label):
                    child.bind('<Button-1>', lambda e, i=idx: self._select_step(i))

            # Content (read-only)
            txt = tk.Text(
                card, height=3, wrap='word',
                bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                fg=self.colors.get('entry_fg', self.colors.get('foreground')),
                font=("Consolas", 9)
            )
            txt.insert('1.0', step['content'])
            txt.configure(state='disabled')
            txt.pack(fill='x', padx=4, pady=(0, 4))

    def _select_step(self, idx: int):
        """Selects or deselects a step (toggle)."""
        self._selected_step = idx if self._selected_step != idx else None
        self._rebuild_steps_ui()

    def _remove_onto_step(self, idx: int):
        """Removes a step by index."""
        if 0 <= idx < len(self._onto_steps):
            self._onto_steps.pop(idx)
            if self._selected_step == idx:
                self._selected_step = None
            elif self._selected_step is not None and self._selected_step > idx:
                self._selected_step -= 1
            self._rebuild_steps_ui()

    def _move_step_up(self, idx: int):
        """Moves a step up one position."""
        if idx > 0:
            self._onto_steps[idx], self._onto_steps[idx - 1] = \
                self._onto_steps[idx - 1], self._onto_steps[idx]
            if self._selected_step == idx:
                self._selected_step = idx - 1
            elif self._selected_step == idx - 1:
                self._selected_step = idx
            self._rebuild_steps_ui()

    def _move_step_down(self, idx: int):
        """Moves a step down one position."""
        if idx < len(self._onto_steps) - 1:
            self._onto_steps[idx], self._onto_steps[idx + 1] = \
                self._onto_steps[idx + 1], self._onto_steps[idx]
            if self._selected_step == idx:
                self._selected_step = idx + 1
            elif self._selected_step == idx + 1:
                self._selected_step = idx
            self._rebuild_steps_ui()

    def _serialize_onto_steps(self) -> str:
        """Serializes the Ontological Steps stack for prompt injection.
        
        Each step is clearly labeled for both human and LLM readability.
        Injected between system prompt and task at run time.
        """
        if not self._onto_steps:
            return ""
        parts = []
        for i, step in enumerate(self._onto_steps):
            parts.append(
                f"### ONTOLOGICAL STEP {i + 1} | Source: {step['source']} ###\n"
                f"{step['content']}"
            )
        return "\n\n".join(parts)

    def _handle_incoming_push(self, payload):
        """Routes incoming content from another cell to steps stack or task box."""
        if payload.get('target_id') != self.session_id:
            return
        content = payload.get('content', '')
        source_name = payload.get('source_name', payload.get('source_id', 'Unknown Cell'))
        destination = payload.get('destination', 'task')

        if destination == 'steps':
            self.add_onto_step(source_name, content)
        else:
            self.append_to_task(content)

    def _on_log_append(self, content):
        """Marshals background thread signal to main UI thread."""
        self.shell.root.after(0, lambda: self.append_log(content))

    def _on_process_complete(self, artifact):
        """Marshals completion signal to main UI thread."""
        text = artifact.get('response', '')
        self.shell.root.after(0, lambda: self.display_result(text))

    def _setup_main_window(self):
        # PANEL 1 (Prompt Setup): left column
        # Panels 2-4 (Inference / HITL / Export): right column
        self.main_row = tk.Frame(self.container, bg=self.colors.get('background'))
        self.main_row.pack(fill='both', expand=True)

        self.left_col = tk.Frame(self.main_row, bg=self.colors.get('background'))
        self.left_col.pack(side='left', fill='both', expand=True)

        self.right_col = tk.Frame(self.main_row, bg=self.colors.get('background'))
        self.right_col.pack(side='right', fill='y', padx=(8, 0))

        # PANEL 1 (Prompt Setup)
        self.panel_prompt = tk.Frame(self.container, bg=self.colors.get('background'))
        self.panel_prompt.pack(in_=self.left_col, fill='both', expand=True)

        # --- Cell Identity Bar ---
        self.identity_bar = tk.Frame(self.panel_prompt, bg=self.colors.get('background'))
        self.identity_bar.pack(pady=(10, 5), padx=10, fill='x')
        
        # Cell ID (read-only, left side)
        self.cell_id_label = tk.Label(
            self.identity_bar,
            text=f"ID: {self.backend.cell_id}",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            font=("Segoe UI", 9)
        )
        self.cell_id_label.pack(side='left', padx=(0, 10))
        
        # Cell Name (editable, center-left)
        self.cell_name_label = tk.Label(
            self.identity_bar,
            text=self.backend.cell_name,
            fg=self.colors.get('accent'),
            bg=self.colors.get('background'),
            font=("Segoe UI", 12, "bold"),
            cursor="hand2"
        )
        self.cell_name_label.pack(side='left', padx=(0, 5))
        self.cell_name_label.bind("<Double-Button-1>", lambda e: self._toggle_name_edit())
        
        # Cell Name Entry (hidden by default)
        self.cell_name_entry = tk.Entry(
            self.identity_bar,
            fg=self.colors.get('foreground'),
            bg=self.colors.get('entry_bg'),
            insertbackground=self.colors.get('foreground'),
            font=("Segoe UI", 12, "bold"),
            relief="flat"
        )
        self.cell_name_entry.bind("<Return>", lambda e: self._save_name_edit())
        self.cell_name_entry.bind("<Tab>", lambda e: self._save_name_edit())
        self.cell_name_entry.bind("<Escape>", lambda e: self._cancel_name_edit())
        
        # Pencil button (edit toggle)
        self.pencil_btn = tk.Button(
            self.identity_bar,
            text="✏",
            bg=self.colors.get('background'),
            fg=self.colors.get('foreground'),
            relief="flat",
            font=("Segoe UI", 12),
            cursor="hand2",
            command=self._toggle_name_edit
        )
        self.pencil_btn.pack(side='left', padx=(5, 0))
        
        # Track edit mode state
        self._name_edit_mode = False

        # --- Tabbed Formatting Toolbar ---
        self.toolbar_frame = tk.Frame(self.panel_prompt, bg=self.colors.get('panel_bg'))
        self.toolbar_frame.pack(fill='x', padx=10)
        
        # Tab bar (top row)
        self.tab_bar = tk.Frame(self.toolbar_frame, bg=self.colors.get('panel_bg'))
        self.tab_bar.pack(fill='x')
        
        _tab_btn_opts = {"relief": "flat", "padx": 8, "pady": 2, "font": ("Segoe UI", 8, "bold"), "cursor": "hand2"}
        self._active_tab = "MD"
        
        self.tab_btn_md = tk.Button(self.tab_bar, text="MD",
            bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'),
            command=lambda: self._switch_toolbar_tab("MD"), **_tab_btn_opts)
        self.tab_btn_md.pack(side='left')
        
        self.tab_btn_json = tk.Button(self.tab_bar, text="JSON",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'),
            command=lambda: self._switch_toolbar_tab("JSON"), **_tab_btn_opts)
        self.tab_btn_json.pack(side='left', padx=(2, 0))
        
        self.tab_btn_py = tk.Button(self.tab_bar, text="PY",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'),
            command=lambda: self._switch_toolbar_tab("PY"), **_tab_btn_opts)
        self.tab_btn_py.pack(side='left', padx=(2, 0))
        
        # Settings always pinned right
        self.btn_settings = tk.Button(self.tab_bar, text="⚙",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'),
            relief="flat", padx=5, command=self._open_settings)
        self.btn_settings.pack(side='right')
        
        # Button row container (swaps on tab change)
        self.toolbar_content = tk.Frame(self.toolbar_frame, bg=self.colors.get('panel_bg'))
        self.toolbar_content.pack(fill='x')
        
        # -- MD Button Row --
        self.toolbar_md = tk.Frame(self.toolbar_content, bg=self.colors.get('panel_bg'))
        self.toolbar_md.pack(fill='x')
        
        _btn = {"bg": self.colors.get('panel_bg'), "fg": self.colors.get('foreground'), "relief": "flat", "padx": 4, "pady": 1, "font": ("Segoe UI", 9), "cursor": "hand2"}
        
        # Headings group
        tk.Button(self.toolbar_md, text="H1", font=("Segoe UI", 9, "bold"), **{k: v for k, v in _btn.items() if k != 'font'}, command=lambda: self._md_heading(1)).pack(side='left')
        tk.Button(self.toolbar_md, text="H2", font=("Segoe UI", 9, "bold"), **{k: v for k, v in _btn.items() if k != 'font'}, command=lambda: self._md_heading(2)).pack(side='left')
        tk.Button(self.toolbar_md, text="H3", font=("Segoe UI", 9, "bold"), **{k: v for k, v in _btn.items() if k != 'font'}, command=lambda: self._md_heading(3)).pack(side='left')
        
        tk.Label(self.toolbar_md, text="│", bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'), padx=2).pack(side='left')
        
        # Inline formatting group
        tk.Button(self.toolbar_md, text="B", font=("Segoe UI", 9, "bold"), **{k: v for k, v in _btn.items() if k != 'font'}, command=self._md_bold).pack(side='left')
        tk.Button(self.toolbar_md, text="I", font=("Segoe UI", 9, "italic"), **{k: v for k, v in _btn.items() if k != 'font'}, command=self._md_italic).pack(side='left')
        tk.Button(self.toolbar_md, text="`code`", **_btn, command=self._md_inline_code).pack(side='left')
        tk.Button(self.toolbar_md, text="```block", **_btn, command=self._md_code_block).pack(side='left')
        
        tk.Label(self.toolbar_md, text="│", bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'), padx=2).pack(side='left')
        
        # Structure group
        tk.Button(self.toolbar_md, text="- List", **_btn, command=self._md_bullet_list).pack(side='left')
        tk.Button(self.toolbar_md, text="1. List", **_btn, command=self._md_numbered_list).pack(side='left')
        tk.Button(self.toolbar_md, text="❝ Quote", **_btn, command=self._md_blockquote).pack(side='left')
        
        tk.Label(self.toolbar_md, text="│", bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'), padx=2).pack(side='left')
        
        tk.Button(self.toolbar_md, text="---", **_btn, command=self._md_hr).pack(side='left')
        
        # Clear always pinned right
        tk.Button(self.toolbar_md, text="✕ Clear",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('error', '#e06c75'),
            relief="flat", padx=4, pady=1, font=("Segoe UI", 9), cursor="hand2",
            command=self._md_clear_format).pack(side='right')
        
        # -- JSON stub row (hidden by default) --
        self.toolbar_json = tk.Frame(self.toolbar_content, bg=self.colors.get('panel_bg'))
        tk.Label(self.toolbar_json, text="JSON formatting — coming soon",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'),
            font=("Segoe UI", 9, "italic"), padx=6).pack(side='left')
        
        # -- PY stub row (hidden by default) --
        self.toolbar_py = tk.Frame(self.toolbar_content, bg=self.colors.get('panel_bg'))
        tk.Label(self.toolbar_py, text="Python formatting — coming soon",
            bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'),
            font=("Segoe UI", 9, "italic"), padx=6).pack(side='left')

        # --- Inference Config Section ---
        self.config_frame = tk.LabelFrame(self.panel_prompt, text=" Inference Parameters ", 
                                     fg=self.colors.get('foreground'), bg=self.colors.get('background'),
                                     relief='solid', bd=1, font=("Segoe UI", 9, "bold"))
        self.config_frame.pack(fill='x', padx=10, pady=10)

        # Model Selection
        self.model_lbl = tk.Label(self.config_frame, text="Model:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.model_lbl.grid(row=0, column=0, sticky='w', padx=5)
        self.model_var = tk.StringVar()
        self.model_dropdown = ttk.Combobox(self.config_frame, textvariable=self.model_var)
        self.model_dropdown['values'] = self.backend.get_models()
        self.model_dropdown.grid(row=0, column=1, sticky='ew', padx=5, pady=2)
        
        # Direct Role Input
        self.role_lbl = tk.Label(self.config_frame, text="System Role:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.role_lbl.grid(row=1, column=0, sticky='w', padx=5)
        self.role_inner = tk.Frame(self.config_frame, bg=self.colors.get('background'))
        self.role_inner.grid(row=1, column=1, sticky='ew')
        
        self.role_entry = tk.Entry(
            self.role_inner,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
        )
        self.role_entry.insert(0, self.backend.system_role)
        self.role_entry.pack(side='left', fill='x', expand=True, padx=(5, 2), pady=2)
        
        self.btn_role_save = tk.Button(self.role_inner, text="💾", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._save_repo_dialog('saved_roles', self.role_entry.get()))
        self.btn_role_save.pack(side='left', padx=2)
        self.btn_role_open = tk.Button(self.role_inner, text="📂", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._open_viewer('saved_roles', lambda c: self._update_widget(self.role_entry, c)))
        self.btn_role_open.pack(side='left', padx=2)

        # Direct Prompt Input
        self.prompt_lbl = tk.Label(self.config_frame, text="System Prompt:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.prompt_lbl.grid(row=2, column=0, sticky='nw', padx=5)
        self.prompt_inner = tk.Frame(self.config_frame, bg=self.colors.get('background'))
        self.prompt_inner.grid(row=2, column=1, sticky='ew')
        
        self.prompt_text = tk.Text(
            self.prompt_inner,
            height=3,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Segoe UI", 9)
        )
        self.prompt_text.pack(side='left', fill='x', expand=True, padx=(5, 2), pady=2)
        
        self.prompt_btns_frame = tk.Frame(self.prompt_inner, bg=self.colors.get('background'))
        self.prompt_btns_frame.pack(side='left', fill='y')
        self.btn_prompt_save = tk.Button(self.prompt_btns_frame, text="💾", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._save_repo_dialog('saved_sys_prompts', self.prompt_text.get('1.0', 'end-1c')))
        self.btn_prompt_save.pack(pady=2)
        self.btn_prompt_open = tk.Button(self.prompt_btns_frame, text="📂", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._open_viewer('saved_sys_prompts', lambda c: self._update_widget(self.prompt_text, c)))
        self.btn_prompt_open.pack(pady=2)

        self.config_frame.columnconfigure(1, weight=1)

        # --- Ontological Steps Stack ---
        self.onto_steps_lf = tk.LabelFrame(
            self.panel_prompt,
            text=" Ontological Steps ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1,
            font=("Segoe UI", 8, "bold")
        )
        self.onto_steps_lf.pack(fill='x', padx=10, pady=(0, 6))

        self._onto_canvas = tk.Canvas(
            self.onto_steps_lf,
            bg=self.colors.get('background'),
            highlightthickness=0,
            height=120
        )
        self._onto_scrollbar = ttk.Scrollbar(
            self.onto_steps_lf,
            orient='vertical',
            command=self._onto_canvas.yview
        )
        self.onto_steps_frame = tk.Frame(self._onto_canvas, bg=self.colors.get('background'))
        self._onto_canvas_window = self._onto_canvas.create_window((0, 0), window=self.onto_steps_frame, anchor='nw')
        self._onto_canvas.configure(yscrollcommand=self._onto_scrollbar.set)
        self.onto_steps_frame.bind('<Configure>', lambda e: self._onto_canvas.configure(
            scrollregion=self._onto_canvas.bbox('all')
        ))
        self._onto_canvas.bind('<Configure>', lambda e: self._onto_canvas.itemconfig(
            self._onto_canvas_window, width=e.width
        ))
        self._onto_canvas.pack(side='left', fill='both', expand=True)
        self._onto_scrollbar.pack(side='right', fill='y')

        # Step data model
        self._onto_steps = []    # list of {"source": str, "content": str}
        self._selected_step = None

        # Initial empty state
        self._rebuild_steps_ui()

        # --- User Request (The Ask) ---
        tk.Label(self.panel_prompt, text="Your Request / Task:", bg=self.colors.get('background'), fg=self.colors.get('foreground'), font=("Segoe UI", 9, "bold")).pack(anchor='w', padx=10)
        self.input_box = tk.Text(
            self.panel_prompt,
            undo=True, wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            selectbackground=self.colors.get('select_bg', self.colors.get('accent')),
            font=("Consolas", 11)
        )
        self.input_box.pack(fill='both', expand=True, padx=10, pady=(0, 5))
        self.input_box.focus_set()

        # --- Action Bar ---
        self.action_frame = tk.Frame(self.panel_prompt, bg=self.colors.get('background'))
        self.action_frame.pack(fill='x', padx=10, pady=(0, 10))

        self.btn_save_template = tk.Button(
            self.action_frame,
            text="SAVE AS TEMPLATE",
            bg=self.colors.get('panel_bg'),
            fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')),
            font=("Segoe UI", 9),
            command=self._save_full_template
        )
        self.btn_save_template.pack(side='left', fill='x', expand=True, padx=(0, 2))

        self.btn_load_template = tk.Button(
            self.action_frame,
            text="LOAD TEMPLATE",
            bg=self.colors.get('panel_bg'),
            fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')),
            font=("Segoe UI", 9),
            command=lambda: self._open_viewer('personas', None)
        )
        self.btn_load_template.pack(side='left', fill='x', expand=True, padx=(2, 5))

        self.btn_submit = tk.Button(
            self.action_frame,
            text="RUN CELL",
            bg=self.colors.get('accent'),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            font=("Segoe UI", 10, "bold"),
            command=self._submit
        )
        self.btn_submit.pack(side='left', fill='x', expand=True)

        # ------------------------------------------------------------------
        # PANEL 2 — Inference Console
        # ------------------------------------------------------------------
        self.panel_inference = tk.LabelFrame(
            self.container,
            text=" Inference Console ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_inference.pack(in_=self.right_col, fill='x', padx=10, pady=(0, 10))

        self.infer_log = tk.Text(
            self.panel_inference,
            height=6,
            wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Consolas", 10)
        )
        self.infer_log.insert('1.0', "[Stub] Inference logs will stream here during the run.\n")
        self.infer_log.configure(state='disabled')
        self.infer_log.pack(fill='x', expand=False, padx=10, pady=8)

        # ------------------------------------------------------------------
        # PANEL 3 — Result + HITL
        # ------------------------------------------------------------------
        self.panel_result = tk.LabelFrame(
            self.container,
            text=" Result + HITL ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_result.pack(in_=self.right_col, fill='both', expand=True, padx=10, pady=(0, 10))

        self.result_text = tk.Text(
            self.panel_result,
            height=8,
            wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Consolas", 11)
        )
        self.result_text.insert('1.0', "[Stub] Model response will appear here.\n")
        self.result_text.configure(state='disabled')
        self.result_text.pack(fill='both', expand=True, padx=10, pady=(8, 6))

        hitl_bar = tk.Frame(self.panel_result, bg=self.colors.get('background'))
        hitl_bar.pack(fill='x', padx=10, pady=(0, 10))

        self.btn_accept = tk.Button(
            hitl_bar,
            text="ACCEPT",
            bg=self.colors.get('accent'),
            fg=self.colors.get('button_fg', 'white'),
            relief="flat",
            state='disabled',
            command=self._on_accept
        )
        self.btn_accept.pack(side='left', padx=(0, 6))

        self.btn_reject = tk.Button(
            hitl_bar,
            text="REJECT & EDIT",
            bg=self.colors.get('button_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            relief="flat",
            state='disabled',
            command=self._on_reject
        )
        self.btn_reject.pack(side='left', padx=(0, 6))

        self.btn_exit = tk.Button(
            hitl_bar,
            text="EXIT CELL",
            bg=self.colors.get('button_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            relief="flat",
            command=self.shell.root.destroy
        )
        self.btn_exit.pack(side='right')


        # PANEL 4 — Send To
        self.panel_sendto = tk.LabelFrame(
            self.container,
            text=" Send To ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_sendto.pack(in_=self.right_col, fill='x', padx=10, pady=(0, 12))

        _st = tk.Frame(self.panel_sendto, bg=self.colors.get('background'))
        _st.pack(fill='x', padx=10, pady=8)

        # Row 1: Target selector
        _row1 = tk.Frame(_st, bg=self.colors.get('background'))
        _row1.pack(fill='x', pady=(0, 4))
        tk.Label(_row1, text="Send To:", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), font=("Segoe UI", 9, "bold"),
            width=10, anchor='w').pack(side='left')
        self.sendto_var = tk.StringVar(value="Select...")
        self.sendto_cb = ttk.Combobox(_row1, textvariable=self.sendto_var,
            state='readonly', values=["New Cell"])
        self.sendto_cb.pack(side='left', fill='x', expand=True, padx=(4, 0))
        self.sendto_cb.bind('<<ComboboxSelected>>', lambda e: self._update_sendto_state())

        # Row 2: What to send
        _row2 = tk.Frame(_st, bg=self.colors.get('background'))
        _row2.pack(fill='x', pady=(0, 4))
        tk.Label(_row2, text="Send:", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), font=("Segoe UI", 9, "bold"),
            width=10, anchor='w').pack(side='left')
        self.sendto_content_var = tk.StringVar(value="response")
        tk.Radiobutton(_row2, text="Current Response", variable=self.sendto_content_var,
            value="response", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), selectcolor=self.colors.get('panel_bg'),
            font=("Segoe UI", 9)).pack(side='left')
        tk.Radiobutton(_row2, text="Task Input", variable=self.sendto_content_var,
            value="task", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), selectcolor=self.colors.get('panel_bg'),
            font=("Segoe UI", 9)).pack(side='left', padx=(8, 0))

        # Row 3: Destination within target cell
        _row3 = tk.Frame(_st, bg=self.colors.get('background'))
        _row3.pack(fill='x', pady=(0, 6))
        tk.Label(_row3, text="Into:", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), font=("Segoe UI", 9, "bold"),
            width=10, anchor='w').pack(side='left')
        self.sendto_dest_var = tk.StringVar(value="steps")
        tk.Radiobutton(_row3, text="Ontological Steps", variable=self.sendto_dest_var,
            value="steps", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), selectcolor=self.colors.get('panel_bg'),
            font=("Segoe UI", 9)).pack(side='left')
        tk.Radiobutton(_row3, text="Task Box", variable=self.sendto_dest_var,
            value="task", bg=self.colors.get('background'),
            fg=self.colors.get('foreground'), selectcolor=self.colors.get('panel_bg'),
            font=("Segoe UI", 9)).pack(side='left', padx=(8, 0))

        # Send button (greyed out until response exists and target selected)
        self.sendto_btn = tk.Button(
            _st, text="SEND",
            bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'),
            relief='flat', state='disabled',
            command=self._on_send_execute
        )
        self.sendto_btn.pack(fill='x')


    def _get_current_artifact(self):
        """Helper to package UI state into a standard artifact."""
        return {
            "payload": self.result_text.get("1.0", "end-1c"),
            "instructions": {
                "system_role": self.role_entry.get(),
                "system_prompt": self.prompt_text.get("1.0", "end-1c")
            },
            "metadata": {"model": self.model_var.get(), "source": "ui_action"}
        }


    def _on_accept(self):
        """HITL: User approves the result."""
        artifact = self._get_current_artifact()
        self.backend.record_feedback(artifact, is_accepted=True)
        self.btn_accept.configure(state='disabled', text="ACCEPTED")
        self.btn_reject.configure(state='disabled')

    def _on_reject(self):
        """HITL: User rejects. Unlock input for editing."""
        artifact = self._get_current_artifact()
        self.backend.record_feedback(artifact, is_accepted=False)
        
        # Move result back to input box for refinement
        rejected_content = self.result_text.get("1.0", "end-1c")
        self.input_box.delete("1.0", "end")
        self.input_box.insert("1.0", rejected_content)
        
        # Reset UI state
        self.result_text.configure(state='normal')
        self.result_text.delete("1.0", "end")
        self.result_text.insert("1.0", "[Drafting refinement...]")
        self.result_text.configure(state='disabled')
        
        self.btn_accept.configure(state='disabled')
        self.btn_reject.configure(state='disabled')
        self.input_box.focus_set()

    # -------------------------------------------------------------------------
    # Toolbar Tab Switching
    # -------------------------------------------------------------------------

    def _switch_toolbar_tab(self, tab_name):
        """Swaps the visible toolbar button row and updates tab highlight."""
        self._active_tab = tab_name
        
        # Hide all content rows
        self.toolbar_md.pack_forget()
        self.toolbar_json.pack_forget()
        self.toolbar_py.pack_forget()
        
        # Show selected row
        tab_map = {"MD": self.toolbar_md, "JSON": self.toolbar_json, "PY": self.toolbar_py}
        tab_map[tab_name].pack(fill='x')
        
        # Update tab button highlight
        btn_map = {"MD": self.tab_btn_md, "JSON": self.tab_btn_json, "PY": self.tab_btn_py}
        for name, btn in btn_map.items():
            if name == tab_name:
                btn.configure(bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'))
            else:
                btn.configure(bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'))

    # -------------------------------------------------------------------------
    # MD Formatting Helpers
    # -------------------------------------------------------------------------

    def _md_wrap_selection(self, prefix, suffix=None):
        """Wraps selected text with prefix/suffix. If no selection, inserts placeholder."""
        suffix = suffix if suffix is not None else prefix
        try:
            start = self.input_box.index("sel.first")
            end = self.input_box.index("sel.last")
            selected = self.input_box.get(start, end)
            self.input_box.delete(start, end)
            self.input_box.insert(start, f"{prefix}{selected}{suffix}")
        except tk.TclError:
            self.input_box.insert("insert", f"{prefix}{suffix}")
            # Move cursor between the markers
            cursor = self.input_box.index("insert")
            line, col = cursor.split('.')
            self.input_box.mark_set("insert", f"{line}.{int(col) - len(suffix)}")

    def _md_prefix_lines(self, prefix):
        """Prefixes each selected line. Falls back to inserting on current line."""
        try:
            start = self.input_box.index("sel.first linestart")
            end = self.input_box.index("sel.last lineend")
            lines = self.input_box.get(start, end).splitlines()
            prefixed = [f"{prefix}{line}" for line in lines]
            self.input_box.delete(start, end)
            self.input_box.insert(start, "\n".join(prefixed))
        except tk.TclError:
            line_start = self.input_box.index("insert linestart")
            self.input_box.insert(line_start, prefix)

    def _md_heading(self, level):
        """Inserts or replaces heading prefix on selected lines."""
        prefix = "#" * level + " "
        try:
            start = self.input_box.index("sel.first linestart")
            end = self.input_box.index("sel.last lineend")
            lines = self.input_box.get(start, end).splitlines()
            # Strip existing heading markers before applying new ones
            stripped = [l.lstrip("# ") for l in lines]
            prefixed = [f"{prefix}{l}" for l in stripped]
            self.input_box.delete(start, end)
            self.input_box.insert(start, "\n".join(prefixed))
        except tk.TclError:
            line_start = self.input_box.index("insert linestart")
            line_text = self.input_box.get(line_start, f"{line_start} lineend")
            self.input_box.delete(line_start, f"{line_start} lineend")
            self.input_box.insert(line_start, f"{prefix}{line_text.lstrip('# ')}")

    def _md_bold(self):
        self._md_wrap_selection("**")

    def _md_italic(self):
        self._md_wrap_selection("_")

    def _md_inline_code(self):
        self._md_wrap_selection("`")

    def _md_code_block(self):
        """Wraps selection in a fenced code block."""
        try:
            start = self.input_box.index("sel.first linestart")
            end = self.input_box.index("sel.last lineend")
            selected = self.input_box.get(start, end)
            self.input_box.delete(start, end)
            self.input_box.insert(start, f"```\n{selected}\n```")
        except tk.TclError:
            self.input_box.insert("insert", "```\n\n```")
            # Move cursor inside the block
            cursor = self.input_box.index("insert")
            line, _ = cursor.split('.')
            self.input_box.mark_set("insert", f"{int(line) - 1}.0")

    def _md_bullet_list(self):
        """Prefixes selected lines with - for a bulleted list."""
        self._md_prefix_lines("- ")

    def _md_numbered_list(self):
        """Prefixes selected lines with incrementing numbers."""
        try:
            start = self.input_box.index("sel.first linestart")
            end = self.input_box.index("sel.last lineend")
            lines = self.input_box.get(start, end).splitlines()
            numbered = [f"{i + 1}. {line}" for i, line in enumerate(lines)]
            self.input_box.delete(start, end)
            self.input_box.insert(start, "\n".join(numbered))
        except tk.TclError:
            self.input_box.insert("insert", "1. ")

    def _md_blockquote(self):
        """Prefixes selected lines with > for a blockquote."""
        self._md_prefix_lines("> ")

    def _md_hr(self):
        """Inserts a horizontal rule on a new line."""
        cursor = self.input_box.index("insert")
        self.input_box.insert(cursor, "\n---\n")

    def _md_clear_format(self):
        """Strips all Markdown formatting from selected text (or entire box)."""
        import re
        try:
            start = self.input_box.index("sel.first")
            end = self.input_box.index("sel.last")
            text = self.input_box.get(start, end)
        except tk.TclError:
            start = "1.0"
            end = "end-1c"
            text = self.input_box.get(start, end)
        
        # Strip fenced code blocks markers
        text = re.sub(r'^```[\w]*\n?', '', text, flags=re.MULTILINE)
        # Strip headings
        text = re.sub(r'^#{1,6}\s+', '', text, flags=re.MULTILINE)
        # Strip bold/italic (order matters: bold first)
        text = re.sub(r'\*\*(.+?)\*\*', r'\1', text)
        text = re.sub(r'__(.+?)__', r'\1', text)
        text = re.sub(r'\*(.+?)\*', r'\1', text)
        text = re.sub(r'_(.+?)_', r'\1', text)
        # Strip inline code
        text = re.sub(r'`(.+?)`', r'\1', text)
        # Strip bullet/number list prefixes
        text = re.sub(r'^[-*+]\s+', '', text, flags=re.MULTILINE)
        text = re.sub(r'^\d+\.\s+', '', text, flags=re.MULTILINE)
        # Strip blockquotes
        text = re.sub(r'^>\s+', '', text, flags=re.MULTILINE)
        # Strip horizontal rules
        text = re.sub(r'^---+\s*$', '', text, flags=re.MULTILINE)
        
        self.input_box.delete(start, end)
        self.input_box.insert(start, text)

    def _update_widget(self, widget, content):
        if isinstance(widget, tk.Entry):
            widget.delete(0, 'end')
            widget.insert(0, content)
        elif isinstance(widget, tk.Text):
            # Ensure widget is editable before update
            original_state = widget.cget('state')
            widget.configure(state='normal')
            widget.delete('1.0', 'end')
            widget.insert('1.0', content)
            # Only lock it back if it was originally disabled (e.g. logs), otherwise leave editable
            if original_state == 'disabled':
                widget.configure(state='disabled')

    def append_log(self, message: str):
        """Appends text to the inference console (Thread-Safe via _on_log_append)."""
        if self.infer_log is None: return
        self.infer_log.configure(state='normal')
        self.infer_log.insert('end', message) # Streamed tokens don't force newlines
        self.infer_log.see('end')
        self.infer_log.configure(state='disabled')

    def display_result(self, text: str):
        """Displays the final artifact and enables HITL + Send To controls."""
        self.result_text.configure(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', text)
        self.result_text.configure(state='disabled')

        if self.btn_accept:
            self.btn_accept.configure(state='normal')
        if self.btn_reject:
            self.btn_reject.configure(state='normal')

        self._response_ready = True
        self._update_sendto_state()

    def _save_repo_dialog(self, table, content):
        """Modular save dialog for individual repositories."""
        dialog = tk.Toplevel(self.shell.root)
        dialog.title(f"Save to {table.split('_')[-1].title()}")
        dialog.geometry("300x150")
        dialog.configure(bg=self.colors.get('background'))

        dialog.transient(self.shell.root)
        dialog.grab_set()

        tk.Label(dialog, text="Name Selection:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white')).pack(pady=5)
        name_entry = tk.Entry(dialog)
        name_entry.pack(padx=10, fill='x')
        name_entry.focus_set()

        default_var = tk.BooleanVar()
        tk.Checkbutton(
            dialog,
            text="Set as Default",
            variable=default_var,
            bg=self.colors.get('background'),
            fg=self.colors.get('foreground', 'white'),
            selectcolor=self.colors.get('panel_bg', '#444')
        ).pack()

        def confirm():
            name = name_entry.get().strip()
            if not name:
                messagebox.showwarning("Missing name", "Please enter a name.", parent=dialog)
                return

            try:
                if table == 'personas':
                    success = self.backend.save_persona(name, content[0], content[1], content[2], default_var.get())
                else:
                    success = self.backend.save_repository_item(table, name, content, default_var.get())
            except Exception as e:
                messagebox.showerror("Save failed", f"Unexpected error: {e}", parent=dialog)
                return

            if success:
                messagebox.showinfo("Success", "Saved successfully!", parent=dialog)
                dialog.destroy()
            else:
                messagebox.showerror("Save failed", "Could not save. Check the app log for the SQLite error.", parent=dialog)

        btn_frame = tk.Frame(dialog, bg=self.colors.get('background'))
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="Save", width=10, command=confirm).pack(side='left', padx=5)
        tk.Button(btn_frame, text="Cancel", width=10, command=dialog.destroy).pack(side='left', padx=5)

        dialog.bind("<Return>", lambda _e: confirm())
        dialog.bind("<Escape>", lambda _e: dialog.destroy())

    def _open_viewer(self, table, callback):
        """Opens the Universal Cell Viewer Modal with context-aware callbacks."""
        if table == 'personas':
            def persona_callback(data):
                self._update_widget(self.role_entry, data[0])
                self._update_widget(self.prompt_text, data[1])
                self._update_widget(self.input_box, data[2])
            callback = persona_callback
            
        CellViewerModal(self.shell.root, self.colors, table, self.backend, callback)

    def _open_settings(self):
        # Enforce singleton Settings modal
        if self._settings_window is not None:
            try:
                if self._settings_window.winfo_exists():
                    self._settings_window.deiconify()
                    self._settings_window.lift()
                    self._settings_window.focus_force()
                    return
            except Exception:
                self._settings_window = None

        settings = tk.Toplevel(self.shell.root)
        self._settings_window = settings
        settings.title("Settings")
        settings.geometry("350x250")
        settings.configure(bg=self.colors.get('background'))

        def _close_settings():
            self._settings_window = None
            try:
                settings.destroy()
            except Exception:
                pass

        settings.protocol("WM_DELETE_WINDOW", _close_settings)

        # Load persisted theme (default Dark)
        current_theme = (self.backend.get_setting('theme_preference') or 'Dark').strip().title()
        if current_theme not in ('Dark', 'Light'):
            current_theme = 'Dark'

        # Theme Section
        lbl_theme = tk.Label(settings, text="Theme:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        lbl_theme.pack(pady=(15, 2))
        
        theme_var = tk.StringVar(value=current_theme)
        theme_cb = ttk.Combobox(settings, textvariable=theme_var, values=["Dark", "Light"], state='readonly')
        theme_cb.pack(pady=2)

        # Geometry Section
        lbl_size = tk.Label(settings, text="Window Size (WxH):", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        lbl_size.pack(pady=(15, 2))
        
        size_entry = tk.Entry(
            settings,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            relief="flat"
        )
        current_geo = self.shell.root.geometry().split('+')[0]
        size_entry.insert(0, current_geo)
        size_entry.pack(pady=2)

        btn_frame = tk.Frame(settings, bg=self.colors.get('background'))
        btn_frame.pack(side='bottom', fill='x', pady=20)

        def apply_changes():
            # 1. Apply Geometry
            new_geo = size_entry.get().strip()
            if new_geo:
                try:
                    self.shell.root.geometry(new_geo)
                    self.backend.save_setting('window_geometry', new_geo)
                except Exception:
                    pass # Ignore invalid geometry strings

            # 2. Apply Theme
            selected_theme = (theme_var.get() or 'Dark').strip().title()
            if selected_theme not in ('Dark', 'Light'):
                selected_theme = 'Dark'

            self.backend.save_setting('theme_preference', selected_theme)
            if hasattr(self.shell, 'set_theme'):
                self.shell.set_theme(selected_theme)
                self.colors = self.shell.colors
                self.refresh_theme()
                
                # Refresh settings window colors immediately (including entry/button surfaces)
                settings.configure(bg=self.colors.get('background'))
                lbl_theme.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                lbl_size.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                btn_frame.configure(bg=self.colors.get('background'))

                try:
                    size_entry.configure(
                        bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                        fg=self.colors.get('entry_fg', self.colors.get('foreground')),
                        insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
                    )
                except Exception:
                    pass

                # Theme all buttons we created in this window
                try:
                    for w in container.winfo_children():
                        if isinstance(w, tk.Button):
                            w.configure(
                                bg=self.colors.get('panel_bg'),
                                fg=self.colors.get('button_fg', self.colors.get('foreground')),
                                activebackground=self.colors.get('panel_bg'),
                                activeforeground=self.colors.get('button_fg', self.colors.get('foreground'))
                            )
                except Exception:
                    pass

                # Recursive cleanup pass: remove any lingering OS-default surfaces
                try:
                    def _walk(w):
                        for child in w.winfo_children():
                            try:
                                if isinstance(child, (tk.Frame, tk.LabelFrame, tk.Toplevel)):
                                    child.configure(bg=self.colors.get('background'))
                                elif isinstance(child, tk.Label):
                                    child.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                                elif isinstance(child, tk.Entry):
                                    child.configure(
                                        bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                                        fg=self.colors.get('entry_fg', self.colors.get('foreground')),
                                        insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
                                    )
                                elif isinstance(child, tk.Button):
                                    child.configure(
                                        bg=self.colors.get('panel_bg'),
                                        fg=self.colors.get('button_fg', self.colors.get('foreground')),
                                        activebackground=self.colors.get('panel_bg'),
                                        activeforeground=self.colors.get('button_fg', self.colors.get('foreground'))
                                    )
                            except Exception:
                                pass
                            _walk(child)
                    _walk(settings)
                except Exception:
                    pass

        def on_ok():
            apply_changes()
            _close_settings()

        # Buttons: Apply | OK | Cancel
        # We use pack with side to center them or space them out
        container = tk.Frame(btn_frame, bg=self.colors.get('background'))
        container.pack(anchor='center')

        btn_opts = {
            "bg": self.colors.get('panel_bg'), 
            "fg": self.colors.get('button_fg', self.colors.get('foreground')),
            "relief": "flat",
            "width": 8
        }

        tk.Button(container, text="Apply", command=apply_changes, **btn_opts).pack(side='left', padx=5)
        tk.Button(container, text="OK", command=on_ok, **btn_opts).pack(side='left', padx=5)
        tk.Button(container, text="Cancel", command=_close_settings, **btn_opts).pack(side='left', padx=5)

    def _build_context_menu(self):
        self.menu = tk.Menu(self.input_box, tearoff=0)
        self.menu.add_command(label="Cut", command=lambda: self.input_box.event_generate("<<Cut>>"))
        self.menu.add_command(label="Copy", command=lambda: self.input_box.event_generate("<<Copy>>"))
        self.menu.add_command(label="Paste", command=lambda: self.input_box.event_generate("<<Paste>>"))
        self.menu.add_separator()
        self.menu.add_command(label="Rename Cell...", command=self._open_rename_dialog)
        self.input_box.bind("<Button-3>", lambda e: self.menu.post(e.x_root, e.y_root))

    def _save_full_template(self):
        """Captures the entire state of the config bar as a bonded Persona."""
        role = self.role_entry.get()
        sys_p = self.prompt_text.get("1.0", "end-1c")
        task_p = self.input_box.get("1.0", "end-1c")
        self._save_repo_dialog('personas', (role, sys_p, task_p))

    def _restore_component_state(self):
        """Restores components using Defaults first, then Session state."""
        default_role = self.backend.get_default_item('saved_roles')
        last_role = self.backend.get_setting('last_system_role')
        self._update_widget(self.role_entry, default_role or last_role or "")

        default_sys = self.backend.get_default_item('saved_sys_prompts')
        last_sys = self.backend.get_setting('last_system_prompt')
        self._update_widget(self.prompt_text, default_sys or last_sys or "")

        last_model = self.backend.get_setting('last_model')
        if last_model in self.model_dropdown['values']:
            self.model_var.set(last_model)

    def _submit(self):
        """Process submission, persist parameters, and update UI consoles."""
        content = self.input_box.get("1.0", "end-1c")
        inherited = self._serialize_onto_steps()

        # Reset response state for new run
        self._response_ready = False
        self._update_sendto_state()
        model = self.model_var.get()
        role = self.role_entry.get()
        prompt = self.prompt_text.get("1.0", "end-1c")
        
        # Persist settings via backend
        self.backend.save_setting('last_model', model)
        self.backend.save_setting('last_system_role', role)
        self.backend.save_setting('last_system_prompt', prompt)

        # Prepare Inference Log
        self.infer_log.configure(state='normal')
        self.infer_log.delete('1.0', 'end')
        self.infer_log.insert('1.0', f"[System] Initiating run with {model}...\n")
        self.infer_log.configure(state='disabled')

        # Prepare Result Box
        self.result_text.configure(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', "Waiting for model response...\n")
        self.result_text.configure(state='disabled')
        
        # Trigger backend processing
        self.backend.process_submission(content, model, role, prompt, inherited_context=inherited)

    def refresh_theme(self, new_colors=None):
        """Re-applies the current theme to all primary UI widgets."""
        # Pull the newest palette. (If the shell swaps dict objects, this keeps us aligned.)
        self.colors = new_colors or self.shell.colors

        # Update Containers
        self.container.configure(bg=self.colors.get('background'))

        if self.main_row is not None:
            self.main_row.configure(bg=self.colors.get('background'))
        if self.left_col is not None:
            self.left_col.configure(bg=self.colors.get('background'))
        if self.right_col is not None:
            self.right_col.configure(bg=self.colors.get('background'))

        if self.panel_prompt is not None:
            self.panel_prompt.configure(bg=self.colors.get('background'))

        if self.action_frame is not None:
            self.action_frame.configure(bg=self.colors.get('background'))
        self.toolbar.configure(bg=self.colors.get('panel_bg'))
        self.config_frame.configure(fg=self.colors.get('foreground'), bg=self.colors.get('background'))
        self.role_inner.configure(bg=self.colors.get('background'))
        self.prompt_inner.configure(bg=self.colors.get('background'))
        self.prompt_btns_frame.configure(bg=self.colors.get('background'))

        if self.action_frame is not None:
            self.action_frame.configure(bg=self.colors.get('background'))

        # Right-column panels
        panel_list = [self.panel_inference, self.panel_result, self.panel_export]
        for panel in panel_list:
            if panel is not None:
                try:
                    panel.configure(
                        bg=self.colors.get('background'),
                        fg=self.colors.get('foreground'),
                        highlightbackground=self.colors.get('border')
                    )
                except Exception:
                    # Some Tk/ttk widgets may not accept fg/highlightbackground
                    try:
                        panel.configure(bg=self.colors.get('background'))
                    except Exception:
                        pass

        if self.export_router_frame is not None:
            self.export_router_frame.configure(bg=self.colors.get('background'))
            for child in self.export_router_frame.winfo_children():
                try:
                    child.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                except Exception:
                    try:
                        child.configure(bg=self.colors.get('background'))
                    except Exception:
                        pass

        if self.export_options_frame is not None:
            self.export_options_frame.configure(bg=self.colors.get('background'))

        # Update Labels
        self.top_label.configure(fg=self.colors.get('foreground'), bg=self.colors.get('background'))
        if self.model_lbl is not None:
            self.model_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
        self.role_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
        self.prompt_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))

        # Update Entries and Text widgets
        self.role_entry.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.prompt_text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.input_box.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'), selectbackground=self.colors.get('select_bg'))

        # TTK STYLES: ttk widgets (Combobox/Treeview/etc.) won't pick up tk bg/fg changes.
        # If we don't restyle them, they can keep OS-default (often white) surfaces after a swap.
        try:
            style = ttk.Style()
            style.configure(
                "TCombobox",
                fieldbackground=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                background=self.colors.get('panel_bg', self.colors.get('background')),
                foreground=self.colors.get('entry_fg', self.colors.get('foreground')),
                arrowcolor=self.colors.get('foreground')
            )
            style.map(
                "TCombobox",
                fieldbackground=[('readonly', self.colors.get('entry_bg', self.colors.get('panel_bg')))],
                foreground=[('readonly', self.colors.get('entry_fg', self.colors.get('foreground')))]
            )
        except Exception:
            pass

        # Panel 2/3 stubs
        if self.infer_log is not None:
            self.infer_log.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        if self.result_text is not None:
            self.result_text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'), selectbackground=self.colors.get('select_bg'))

        # Update Buttons (toolbar + small repo buttons)
        btn_list = [self.btn_bold, self.btn_italic, self.btn_list, self.btn_settings, self.btn_role_save, self.btn_role_open, self.btn_prompt_save, self.btn_prompt_open]
        for btn in btn_list:
            btn.configure(bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'))

        # Update Action Bar buttons
        if self.btn_save_template is not None:
            self.btn_save_template.configure(
                bg=self.colors.get('panel_bg'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )
        if self.btn_load_template is not None:
            self.btn_load_template.configure(
                bg=self.colors.get('panel_bg'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )
        if self.btn_submit is not None:
            self.btn_submit.configure(
                bg=self.colors.get('accent'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )

        # HITL buttons
        if self.btn_accept is not None:
            self.btn_accept.configure(bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'))
        if self.btn_reject is not None:
            self.btn_reject.configure(bg=self.colors.get('button_bg', self.colors.get('panel_bg')), fg=self.colors.get('button_fg', self.colors.get('foreground')))
        if self.btn_exit is not None:
            self.btn_exit.configure(bg=self.colors.get('button_bg', self.colors.get('panel_bg')), fg=self.colors.get('button_fg', self.colors.get('foreground')))

        # Export buttons
        if self.export_execute_btn is not None:
            self.export_execute_btn.configure(bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'))

    def _on_cell_renamed(self, data):
        """Handles cell rename events."""
        # Update identity display when rename happens
        self._update_identity_display()
        # Exit edit mode if currently editing
        if self._name_edit_mode:
            self._exit_edit_mode()

    def _update_window_title(self, new_title):
        """Updates the window title."""
        self.shell.root.title(new_title)

    def _open_rename_dialog(self):
        """Opens a dialog to rename the current cell."""
        # Singleton pattern - only one rename dialog at a time
        if self._rename_window is not None and self._rename_window.winfo_exists():
            self._rename_window.focus()
            return
        
        new_name = simpledialog.askstring(
            "Rename Cell",
            f"Enter new name for '{self.backend.cell_name}':",
            initialvalue=self.backend.cell_name,
            parent=self.shell.root
        )
        
        if new_name and new_name.strip():
            self.backend.rename_cell(new_name.strip())
            self._update_identity_display()

    def _toggle_name_edit(self):
        """Toggles between label and entry mode for cell name."""
        if self._name_edit_mode:
            # Currently editing - save and exit edit mode
            self._save_name_edit()
        else:
            # Enter edit mode
            self._name_edit_mode = True
            
            # Hide label, show entry
            self.cell_name_label.pack_forget()
            self.cell_name_entry.delete(0, 'end')
            self.cell_name_entry.insert(0, self.backend.cell_name)
            self.cell_name_entry.pack(side='left', padx=(0, 5), fill='x', expand=True)
            self.cell_name_entry.focus()
            self.cell_name_entry.select_range(0, 'end')

    def _save_name_edit(self):
        """Saves the edited cell name and exits edit mode."""
        if not self._name_edit_mode:
            return
        
        new_name = self.cell_name_entry.get().strip()
        
        if new_name and new_name != self.backend.cell_name:
            # Name changed - propagate through backend
            self.backend.rename_cell(new_name)
        
        # Exit edit mode
        self._exit_edit_mode()

    def _cancel_name_edit(self):
        """Cancels editing without saving."""
        if self._name_edit_mode:
            self._exit_edit_mode()

    def _exit_edit_mode(self):
        """Exits edit mode and restores label display."""
        self._name_edit_mode = False
        
        # Hide entry, show label
        self.cell_name_entry.pack_forget()
        self.cell_name_label.configure(text=self.backend.cell_name)
        self.cell_name_label.pack(side='left', padx=(0, 5))

    def _update_identity_display(self):
        """Updates the cell identity display (called after rename)."""
        self.cell_name_label.configure(text=self.backend.cell_name)
        self.cell_id_label.configure(text=f"ID: {self.backend.cell_id}")



























--------------------------------------------------------------------------------
FILE: src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\base_service.py
--------------------------------------------------------------------------------
import logging
from typing import Dict, Any

class BaseService:
    """
    Standard parent class for all microservices. 
    Provides consistent logging and identity management.
    """
    def __init__(self, name: str):
        self._service_info = {
            "name": name, 
            "id": name.lower().replace(" ", "_")
        }
        
        # Setup standard logging
        logging.basicConfig(
            level=logging.INFO, 
            format='%(asctime)s [%(levelname)s] %(message)s',
            datefmt='%H:%M:%S'
        )
        self.logger = logging.getLogger(name)

    def log_info(self, message: str):
        self.logger.info(message)

    def log_error(self, message: str):
        self.logger.error(message)

    def log_warning(self, message: str):
        self.logger.warning(message)

--------------------------------------------------------------------------------
FILE: src\microservices\document_utils.py
--------------------------------------------------------------------------------
from ._ContentExtractorMS import ContentExtractorMS

# Singleton instance to reuse the extractor logic
_extractor = ContentExtractorMS()

def extract_text_from_pdf(blob: bytes) -> str:
    """Proxy to ContentExtractorMS PDF logic."""
    return _extractor._extract_pdf(blob)

def extract_text_from_html(html_text: str) -> str:
    """Proxy to ContentExtractorMS HTML logic."""
    return _extractor._extract_html(html_text)

--------------------------------------------------------------------------------
FILE: src\microservices\fix.py
--------------------------------------------------------------------------------
import os
import re

def repair_microservices():
    # Targets for relative import conversion
    targets = ["base_service", "microservice_std_lib"]
    
    # Pattern: Matches 'from X import' or 'import X' where X is a target
    # but specifically avoids lines that already start with a dot.
    patterns = {
        target: (
            re.compile(rf"^(?!\s*from\s+\.)(\s*from\s+{target}\s+import)"),
            rf"from .{target} import"
        ) for target in targets
    }

    # Identify current directory (intended to be src/microservices/)
    current_dir = os.path.dirname(os.path.abspath(__file__))
    files_processed = 0
    files_repaired = 0

    print(f"--- Starting Import Repair in: {current_dir} ---")

    for filename in os.listdir(current_dir):
        if filename.endswith(".py") and filename not in ["repair_imports.py", "base_service.py", "microservice_std_lib.py"]:
            file_path = os.path.join(current_dir, filename)
            files_processed += 1
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            new_content = content
            modified = False

            for target, (pattern, replacement) in patterns.items():
                if pattern.search(new_content):
                    new_content = pattern.sub(replacement, new_content)
                    modified = True

            if modified:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                print(f"✅ Repaired: {filename}")
                files_repaired += 1
            else:
                # No change needed
                pass

    print(f"\n--- Scan Complete ---")
    print(f"Files Checked: {files_processed}")
    print(f"Files Repaired: {files_repaired}")

if __name__ == "__main__":
    repair_microservices()
--------------------------------------------------------------------------------
FILE: src\microservices\microservice_std_lib.py
--------------------------------------------------------------------------------
"""
LIBRARY: Microservice Standard Lib
VERSION: 2.1.0
ROLE: Provides decorators for tagging Python classes as AI-discoverable services.

Change (2.1.0):
- Split dependencies into:
    internal_dependencies: local modules / microservices to vendor with the app
    external_dependencies: pip-installable packages (requirements.txt)
- Keep legacy "dependencies" as an alias for external_dependencies for backward compatibility.
- Accept unknown keyword args in @service_metadata(...) to prevent older/newer services from crashing
  (e.g. when a runner passes additional fields).
"""

import functools
import inspect
from typing import Dict, List, Any, Optional, Type

# ==============================================================================
# DECORATORS (The "Writer" Tools)
# ==============================================================================

def service_metadata(
    name: str,
    version: str,
    description: str,
    tags: List[str],
    capabilities: Optional[List[str]] = None,

    # Legacy field (kept for backward compatibility):
    # Historically this mixed stdlib + pip deps. Going forward, treat this as *external* deps.
    dependencies: Optional[List[str]] = None,

    # New fields (preferred):
    internal_dependencies: Optional[List[str]] = None,
    external_dependencies: Optional[List[str]] = None,

    # Side effects / operational hints
    side_effects: Optional[List[str]] = None,

    # Forward-compat: ignore unknown keyword args instead of crashing older/newer services
    **_ignored_kwargs: Any,
):
    """
    Class Decorator.
    Labels a Microservice class with high-level metadata for the Catalog.

    Dependency semantics:
      - internal_dependencies: local modules and/or other microservice modules that must be shipped with an app
      - external_dependencies: third-party pip packages (requirements.txt)
      - dependencies (legacy): treated as external_dependencies when external_dependencies is not provided
    """
    # Prefer explicit new key, otherwise fall back to legacy dependencies
    ext = external_dependencies if external_dependencies is not None else (dependencies or [])
    intl = internal_dependencies or []

    def decorator(cls):
        cls._is_microservice = True
        cls._service_info = {
            "name": name,
            "version": version,
            "description": description,
            "tags": tags,
            "capabilities": capabilities or [],

            # New keys
            "internal_dependencies": intl,
            "external_dependencies": ext,

            # Legacy alias (keep existing tooling working)
            "dependencies": ext,

            "side_effects": side_effects or []
        }
        return cls
    return decorator


def service_endpoint(
    inputs: Dict[str, str],
    outputs: Dict[str, str],
    description: str,
    tags: Optional[List[str]] = None,
    side_effects: Optional[List[str]] = None,
    mode: str = "sync",
):
    """
    Method Decorator.
    Defines the 'Socket' that the AI Architect can plug into.

    :param inputs: Dict of {arg_name: type_string} (e.g. {"query": "str"})
    :param outputs: Dict of {return_name: type_string}
    :param description: What the endpoint does
    :param tags: List of categories (e.g. ["read", "write"])
    :param side_effects: List of side effects (e.g. ["filesystem:write", "db:write"])
    :param mode: "sync" or "async" (informational unless your runtime uses it)
    """

    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        # Attach metadata to the function object itself
        wrapper._is_endpoint = True
        wrapper._endpoint_info = {
            "name": func.__name__,
            "inputs": inputs,
            "outputs": outputs,
            "description": description,
            "tags": tags or [],
            "side_effects": side_effects or [],
            "mode": mode
        }
        return wrapper
    return decorator


# ==============================================================================
# INTROSPECTION (The "Reader" Tools)
# ==============================================================================

def extract_service_schema(service_cls: Type) -> Dict[str, Any]:
    """
    Scans a decorated Service Class and returns a JSON-serializable schema
    of its metadata and all its exposed endpoints.

    This is what the AI Agent uses to 'read' the manual.
    """
    if not getattr(service_cls, "_is_microservice", False):
        raise ValueError(f"Class {service_cls.__name__} is not decorated with @service_metadata")

    schema = {
        "meta": getattr(service_cls, "_service_info", {}),
        "endpoints": []
    }

    # Inspect all methods of the class
    for _, method in inspect.getmembers(service_cls, predicate=inspect.isfunction):
        endpoint_info = getattr(method, "_endpoint_info", None)
        if endpoint_info:
            schema["endpoints"].append(endpoint_info)

    return schema

--------------------------------------------------------------------------------
FILE: src\microservices\_CodeFormatterMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _CodeFormatterMS
ENTRY_POINT: _CodeFormatterMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import re
import json
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
logger = logging.getLogger('CodeFormatter')

class WhitespaceEngine:
    """
    Parses code into a granular map of (Indent + Content + Trailing).
    Can Normalize structure and generate 'Hunk' patches.
    """

    def __init__(self):
        self.raw_lines = []
        self.nodes = []
        self.normalized_text = ''
        self.patch_data = {'hunks': []}

    def load_source(self, text):
        self.raw_lines = text.splitlines()
        self.nodes = []
        indent_stack = [0]
        last_line_was_block_starter = False
        for i, line in enumerate(self.raw_lines):
            match = re.match('^([ \\t]*)(.*?)([ \\t]*)$', line)
            if not match:
                self.nodes.append({'id': i, 'indent': '', 'content': line, 'depth': 0, 'is_empty': True})
                continue
            indent, content, trailing = match.groups()
            is_empty = len(content) == 0
            current_width = 0
            for char in indent:
                current_width += 4 if char == '\t' else 1
            if is_empty:
                depth = len(indent_stack) - 1
            else:
                if current_width > indent_stack[-1]:
                    if last_line_was_block_starter:
                        indent_stack.append(current_width)
                    else:
                        pass
                while len(indent_stack) > 1 and current_width < indent_stack[-1]:
                    indent_stack.pop()
                depth = len(indent_stack) - 1
                clean_content = content.split('#')[0].strip()
                last_line_was_block_starter = clean_content.endswith(':')
            self.nodes.append({'id': i, 'raw_indent': indent, 'depth': depth, 'content': content, 'trailing': trailing, 'is_empty': is_empty})

    def normalize(self, use_tabs=False, space_count=4):
        """Reconstructs the code with strict indentation rules."""
        char = '\t' if use_tabs else ' ' * space_count
        clean_lines = []
        for node in self.nodes:
            if node['is_empty']:
                clean_lines.append('')
            else:
                new_indent = char * node['depth']
                clean_lines.append(f"{new_indent}{node['content']}")
        self.normalized_text = '\n'.join(clean_lines)
        return self.normalized_text

    def generate_patch(self):
        """Compares Raw vs Normalized and generates JSON Schema Hunks."""
        clean_lines = self.normalized_text.splitlines()
        if not clean_lines:
            return {'hunks': []}
        hunks = []
        current_hunk = None
        for i, (raw, clean) in enumerate(zip(self.raw_lines, clean_lines)):
            if raw != clean:
                if current_hunk is None:
                    current_hunk = {'start_line': i, 'raw_block': [raw], 'clean_block': [clean]}
                elif i == current_hunk['start_line'] + len(current_hunk['raw_block']):
                    current_hunk['raw_block'].append(raw)
                    current_hunk['clean_block'].append(clean)
                else:
                    self._finalize_hunk(hunks, current_hunk)
                    current_hunk = {'start_line': i, 'raw_block': [raw], 'clean_block': [clean]}
            elif current_hunk:
                self._finalize_hunk(hunks, current_hunk)
                current_hunk = None
        if current_hunk:
            self._finalize_hunk(hunks, current_hunk)
        self.patch_data = {'hunks': hunks}
        return self.patch_data

    def _finalize_hunk(self, hunks_list, hunk_data):
        search_txt = '\n'.join(hunk_data['raw_block'])
        replace_txt = '\n'.join(hunk_data['clean_block'])
        schema_hunk = {'description': f"Normalize indentation (Lines {hunk_data['start_line']}-{hunk_data['start_line'] + len(hunk_data['raw_block'])})", 'search_block': search_txt, 'replace_block': replace_txt}
        hunks_list.append(schema_hunk)

@service_metadata(name='CodeFormatter', version='1.0.0', description='The Architect: Intelligent whitespace normalization and structural repair engine.', tags=['formatting', 'code', 'utility'], capabilities=['compute', 'filesystem:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class CodeFormatterMS(BaseService):
    """
    The Architect.
    Uses the WhitespaceEngine to enforce strict indentation rules, 
    fixing 'staircase' formatting and mixed tabs/spaces.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('CodeFormatter')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'use_tabs': 'bool', 'spaces': 'int'}, outputs={'normalized': 'str', 'patch': 'Dict'}, description='Takes raw code and returns the normalized version plus a JSON patch of changes.', tags=['formatting', 'compute'], side_effects=[])
    # ROLE: Takes raw code and returns the normalized version plus a JSON patch of changes.
    # INPUTS: {"content": "str", "spaces": "int", "use_tabs": "bool"}
    # OUTPUTS: {"normalized": "str", "patch": "Dict"}
    def normalize_code(self, content: str, use_tabs: bool=False, spaces: int=4) -> Dict[str, Any]:
        """
        Pure logic endpoint: Takes string, returns string + patch.
        Does not touch the filesystem.
        """
        engine = WhitespaceEngine()
        engine.load_source(content)
        normalized = engine.normalize(use_tabs=use_tabs, space_count=spaces)
        patch = engine.generate_patch()
        return {'normalized': normalized, 'patch': patch}

    @service_endpoint(inputs={'file_path': 'str', 'use_tabs': 'bool', 'spaces': 'int'}, outputs={'status': 'str', 'changes': 'int'}, description='Reads a file, normalizes it, and overwrites it if changes are needed.', tags=['formatting', 'filesystem'], side_effects=['filesystem:read', 'filesystem:write'])
    # ROLE: Reads a file, normalizes it, and overwrites it if changes are needed.
    # INPUTS: {"file_path": "str", "spaces": "int", "use_tabs": "bool"}
    # OUTPUTS: {"changes": "int", "status": "str"}
    def format_file(self, file_path: str, use_tabs: bool=False, spaces: int=4) -> Dict[str, Any]:
        """
        Filesystem endpoint: In-place repair of a file.
        """
        path = Path(file_path).resolve()
        if not path.exists():
            return {'status': 'error', 'message': 'File not found'}
        try:
            content = path.read_text(encoding='utf-8')
            engine = WhitespaceEngine()
            engine.load_source(content)
            normalized = engine.normalize(use_tabs=use_tabs, space_count=spaces)
            patch = engine.generate_patch()
            changes = len(patch['hunks'])
            if changes > 0:
                path.write_text(normalized, encoding='utf-8')
                logger.info(f'Formatted {path.name}: {changes} hunks applied.')
                return {'status': 'modified', 'changes': changes}
            else:
                return {'status': 'clean', 'changes': 0}
        except Exception as e:
            logger.error(f'Formatting failed for {path}: {e}')
            return {'status': 'error', 'message': str(e)}
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    svc = CodeFormatterMS()
    print('Service ready:', svc)
    broken_code = '\ndef hello():\n  print("Indented with 2 spaces")\n      print("Suddenly 6 spaces!")\n    '
    print('\n--- Processing Broken Code ---')
    result = svc.normalize_code(broken_code, spaces=4)
    print(f"Hunks Detected: {len(result['patch']['hunks'])}")
    print('\n--- Normalized Output ---')
    print(result['normalized'])


--------------------------------------------------------------------------------
FILE: src\microservices\_CognitiveMemoryMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _CognitiveMemoryMS
ENTRY_POINT: _CognitiveMemoryMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: pydantic
"""
import importlib.util
import sys
REQUIRED = ['pydantic']
MISSING = []
for lib in REQUIRED:
    if importlib.util.find_spec(lib) is None:
        MISSING.append(lib)
if MISSING:
    print(f"MISSING DEPENDENCIES: {' '.join(MISSING)}")
    print('Please run: pip install pydantic')
import datetime
import json
import logging
import uuid
import os
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional
from pydantic import BaseModel, Field
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
DEFAULT_MEMORY_FILE = Path('working_memory.jsonl')
FLUSH_THRESHOLD = 5
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger('CognitiveMem')

class MemoryEntry(BaseModel):
    """Atomic unit of memory."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime.datetime = Field(default_factory=datetime.datetime.utcnow)
    role: str
    content: str
    metadata: Dict[str, Any] = Field(default_factory=dict)

@service_metadata(name='CognitiveMemory', version='1.0.0', description='Manages Short-Term (Working) Memory and orchestrates flushing to Long-Term Memory.', tags=['memory', 'history', 'context'], capabilities=['filesystem:read', 'filesystem:write'], side_effects=['filesystem:write'], internal_dependencies=['base_service', 'microservice_std_lib'], external_dependencies=['pydantic'])
class CognitiveMemoryMS(BaseService):
    """
    The Hippocampus: Manages Short-Term (Working) Memory and orchestrates 
    flushing to Long-Term Memory (Vector Store).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('CognitiveMemory')
        self.config = config or {}
        self.file_path = Path(self.config.get('persistence_path', DEFAULT_MEMORY_FILE))
        self.summarizer = self.config.get('summarizer_func')
        self.ingestor = self.config.get('long_term_ingest_func')
        self.working_memory: List[MemoryEntry] = []
        self._load_working_memory()

    @service_endpoint(inputs={'role': 'str', 'content': 'str', 'metadata': 'Dict'}, outputs={'entry': 'MemoryEntry'}, description='Adds an item to working memory and persists it.', tags=['memory', 'write'], side_effects=['filesystem:write'])
    # ROLE: Adds an item to working memory and persists it.
    # INPUTS: {"content": "str", "metadata": "Dict", "role": "str"}
    # OUTPUTS: {"entry": "MemoryEntry"}
    def add_entry(self, role: str, content: str, metadata: Dict=None) -> MemoryEntry:
        """Adds an item to working memory and persists it."""
        entry = MemoryEntry(role=role, content=content, metadata=metadata or {})
        self.working_memory.append(entry)
        self._append_to_file(entry)
        log.info(f'Added memory: [{role}] {content[:30]}...')
        return entry

    @service_endpoint(inputs={'limit': 'int'}, outputs={'context': 'str'}, description='Returns the most recent conversation history formatted for an LLM.', tags=['memory', 'read', 'llm'], side_effects=['filesystem:read'])
    # ROLE: Returns the most recent conversation history formatted for an LLM.
    # INPUTS: {"limit": "int"}
    # OUTPUTS: {"context": "str"}
    def get_context(self, limit: int=10) -> str:
        """
        Returns the most recent conversation history formatted for an LLM.
        """
        recent = self.working_memory[-limit:]
        return '\n'.join([f'{e.role.upper()}: {e.content}' for e in recent])

    def get_full_history(self) -> List[Dict]:
        """Returns the raw list of memory objects."""
        return [e.dict() for e in self.working_memory]

    @service_endpoint(inputs={}, outputs={}, description='Signals that a turn is complete; checks if memory flush is needed.', tags=['memory', 'maintenance'], side_effects=['filesystem:write'])
    # ROLE: Signals that a turn is complete; checks if memory flush is needed.
    # INPUTS: {}
    # OUTPUTS: {}
    def commit_turn(self):
        """
        Signal that a "Turn" (User + AI response) is complete.
        Checks if memory is full and triggers a flush if needed.
        """
        if len(self.working_memory) >= FLUSH_THRESHOLD:
            self._flush_to_long_term()

    def _flush_to_long_term(self):
        """
        Compresses working memory into a summary and moves it to Long-Term storage.
        """
        if not self.summarizer or not self.ingestor:
            log.warning('Flush triggered but Summarizer/Ingestor not configured. Skipping.')
            return
        log.info('🌀 Flushing Working Memory to Long-Term Storage...')
        full_text = '\n'.join([f'{e.role}: {e.content}' for e in self.working_memory])
        try:
            summary = self.summarizer(full_text)
            log.info(f'Summary generated: {summary[:50]}...')
        except Exception as e:
            log.error(f'Summarization failed: {e}')
            return
        try:
            meta = {'source': 'cognitive_memory_flush', 'date': datetime.datetime.utcnow().isoformat(), 'original_entry_count': len(self.working_memory)}
            self.ingestor(summary, meta)
            log.info('✅ Saved to Long-Term Memory.')
        except Exception as e:
            log.error(f'Ingestion failed: {e}')
            return
        self.working_memory.clear()
        self._rotate_log_file()

    def _load_working_memory(self):
        """Rehydrates memory from the JSONL file."""
        if not self.file_path.exists():
            return
        try:
            with open(self.file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.strip():
                        self.working_memory.append(MemoryEntry.parse_raw(line))
            log.info(f'Loaded {len(self.working_memory)} items from {self.file_path}')
        except Exception as e:
            log.error(f'Corrupt memory file: {e}')

    def _append_to_file(self, entry: MemoryEntry):
        """Appends a single entry to the JSONL log."""
        with open(self.file_path, 'a', encoding='utf-8') as f:
            f.write(entry.json() + '\n')

    def _rotate_log_file(self):
        """Renames the current log to an archive timestamp."""
        if self.file_path.exists():
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            archive_name = self.file_path.with_name(f'memory_archive_{timestamp}.jsonl')
            self.file_path.rename(archive_name)
            log.info(f'Rotated memory log to {archive_name}')
if __name__ == '__main__':

    def mock_summarizer(text):
        return f'SUMMARY OF {len(text)} CHARS: The user and AI discussed AI architecture.'

    def mock_ingest(text, metadata):
        print(f"\n[VectorDB] Indexing: '{text}'\n[VectorDB] Meta: {metadata}")
    print('--- Initializing Cognitive Memory ---')
    mem = CognitiveMemoryMS({'summarizer_func': mock_summarizer, 'long_term_ingest_func': mock_ingest})
    print(f'Service ready: {mem}')
    print('\n--- Simulating Conversation ---')
    mem.add_entry('user', 'Hello, who are you?')
    mem.add_entry('assistant', 'I am a Cognitive Agent.')
    mem.add_entry('user', 'What is your memory capacity?')
    mem.add_entry('assistant', 'I have a tiered memory system.')
    mem.add_entry('user', 'That sounds complex.')
    print(f'\nCurrent Context:\n{mem.get_context()}')
    print('\n--- Triggering Memory Flush ---')
    mem.commit_turn()
    print(f'\nWorking Memory after flush: {len(mem.working_memory)} items')
    if Path('working_memory.jsonl').exists():
        os.remove('working_memory.jsonl')
    for p in Path('.').glob('memory_archive_*.jsonl'):
        os.remove(p)

--------------------------------------------------------------------------------
FILE: src\microservices\_ConfigStoreMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _ConfigStoreMS
ROLE: App Settings Persistence (Task 4.2)
"""
import json
import os
import logging
from typing import Dict, Any, Optional

class ConfigStoreMS:
    def __init__(self, filename="app_config.json"):
        self.filename = filename
        self.logger = logging.getLogger("ConfigStore")
        self.data = self._load_from_disk()

    def _load_from_disk(self) -> Dict[str, Any]:
        """Loads the JSON config or returns defaults if missing/corrupt."""
        if not os.path.exists(self.filename):
            return {}
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load config: {e}")
            return {}

    def get(self, key: str, default: Any = None) -> Any:
        return self.data.get(key, default)

    def set(self, key: str, value: Any):
        """Updates internal data and triggers an atomic save."""
        self.data[key] = value
        self.save()

    def save(self):
        """Atomic write: Save to temp, then rename to original."""
        temp_file = f"{self.filename}.tmp"
        try:
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4)
            os.replace(temp_file, self.filename)
        except Exception as e:
            self.logger.error(f"Atomic save failed: {e}")
            if os.path.exists(temp_file):
                os.remove(temp_file)

--------------------------------------------------------------------------------
FILE: src\microservices\_DiffEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _DiffEngineMS
ENTRY_POINT: _DiffEngineMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import sqlite3
import difflib
import datetime
import uuid
import logging
from pathlib import Path
from typing import Optional, Dict, List, Tuple, Any
from microservice_std_lib import service_metadata, service_endpoint
DB_PATH = Path(__file__).parent / 'diff_engine.db'
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger('DiffEngine')

@service_metadata(name='DiffEngineMS', version='1.0.0', description='Implements hybrid versioning (Head + Diff History) for file content.', tags=['version-control', 'diff', 'db'], capabilities=['db:sqlite', 'filesystem:write'], side_effects=['db:read', 'db:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class DiffEngineMS:
    """
    The Timekeeper: Implements a 'Hybrid' versioning architecture.
    1. HEAD: Stores full current content for fast read access (UI/RAG).
    2. HISTORY: Stores diff deltas using difflib for audit trails.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        self.config = config or {}
        self.db_path = Path(self.config.get('db_path', DB_PATH))
        self._init_db()

    def _get_conn(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn

    def _init_db(self):
        with self._get_conn() as conn:
            conn.execute('\n                CREATE TABLE IF NOT EXISTS files (\n                    id TEXT PRIMARY KEY,\n                    path TEXT UNIQUE NOT NULL,\n                    content TEXT,\n                    last_updated TIMESTAMP\n                )\n            ')
            conn.execute("\n                CREATE TABLE IF NOT EXISTS diff_log (\n                    id TEXT PRIMARY KEY,\n                    file_id TEXT NOT NULL,\n                    timestamp TIMESTAMP,\n                    change_type TEXT,  -- 'CREATE', 'EDIT', 'DELETE'\n                    diff_blob TEXT,    -- The text output of difflib\n                    author TEXT,\n                    FOREIGN KEY(file_id) REFERENCES files(id)\n                )\n            ")

    @service_endpoint(inputs={'path': 'str', 'new_content': 'str', 'author': 'str'}, outputs={'status': 'str', 'file_id': 'str'}, description='Updates a file, creating a diff history entry and updating the head state.', tags=['version-control', 'write'], side_effects=['db:write'])
    # ROLE: Updates a file, creating a diff history entry and updating the head state.
    # INPUTS: {"author": "str", "new_content": "str", "path": "str"}
    # OUTPUTS: {"file_id": "str", "status": "str"}
    def update_file(self, path: str, new_content: str, author: str='agent') -> Dict[str, Any]:
        """
        The Atomic Update Operation:
        1. Checks current state.
        2. Calculates Diff.
        3. Writes Diff to History.
        4. Updates Head to New Content.
        """
        path = str(Path(path).as_posix())
        now = datetime.datetime.utcnow()
        with self._get_conn() as conn:
            row = conn.execute('SELECT id, content FROM files WHERE path = ?', (path,)).fetchone()
            if not row:
                file_id = str(uuid.uuid4())
                conn.execute('INSERT INTO files (id, path, content, last_updated) VALUES (?, ?, ?, ?)', (file_id, path, new_content, now))
                self._log_diff(conn, file_id, 'CREATE', '[New File Created]', author, now)
                log.info(f'Created new file: {path}')
                return {'status': 'created', 'file_id': file_id}
            file_id = row['id']
            old_content = row['content'] or ''
            old_lines = old_content.splitlines(keepends=True)
            new_lines = new_content.splitlines(keepends=True)
            diff_gen = difflib.unified_diff(old_lines, new_lines, fromfile=f'a/{path}', tofile=f'b/{path}', lineterm='')
            diff_text = ''.join(diff_gen)
            if not diff_text:
                return {'status': 'unchanged', 'file_id': file_id}
            self._log_diff(conn, file_id, 'EDIT', diff_text, author, now)
            conn.execute('UPDATE files SET content = ?, last_updated = ? WHERE id = ?', (new_content, now, file_id))
            log.info(f'Updated file: {path}')
            return {'status': 'updated', 'file_id': file_id, 'diff_size': len(diff_text)}

    def _log_diff(self, conn, file_id, change_type, diff_text, author, timestamp):
        diff_id = str(uuid.uuid4())
        conn.execute('INSERT INTO diff_log (id, file_id, timestamp, change_type, diff_blob, author) VALUES (?, ?, ?, ?, ?, ?)', (diff_id, file_id, timestamp, change_type, diff_text, author))

    @service_endpoint(inputs={'path': 'str'}, outputs={'content': 'Optional[str]'}, description='Fast retrieval of current content.', tags=['version-control', 'read'], side_effects=['db:read'])
    # ROLE: Fast retrieval of current content.
    # INPUTS: {"path": "str"}
    # OUTPUTS: {"content": "Optional[str]"}
    def get_head(self, path: str) -> Optional[str]:
        """Fast retrieval of current content."""
        with self._get_conn() as conn:
            row = conn.execute('SELECT content FROM files WHERE path = ?', (path,)).fetchone()
            return row['content'] if row else None

    @service_endpoint(inputs={'path': 'str'}, outputs={'history': 'List[Dict]'}, description='Retrieves the full evolution history of a file.', tags=['version-control', 'read'], side_effects=['db:read'])
    # ROLE: Retrieves the full evolution history of a file.
    # INPUTS: {"path": "str"}
    # OUTPUTS: {"history": "List[Dict]"}
    def get_history(self, path: str) -> List[Dict]:
        """Retrieves the full evolution history of a file."""
        with self._get_conn() as conn:
            row = conn.execute('SELECT id FROM files WHERE path = ?', (path,)).fetchone()
            if not row:
                return []
            rows = conn.execute('SELECT timestamp, change_type, diff_blob, author FROM diff_log WHERE file_id = ? ORDER BY timestamp DESC', (row['id'],)).fetchall()
            return [dict(r) for r in rows]
if __name__ == '__main__':
    import os
    if DB_PATH.exists():
        os.remove(DB_PATH)
    engine = DiffEngineMS()
    print('Service ready:', engine)
    print('--- 1. Creating File ---')
    engine.update_file('notes.txt', 'Todo List:\n1. Buy Milk\n')
    print('\n--- 2. Updating File (The Rising Edge) ---')
    new_text = 'Todo List:\n1. Buy Eggs\n2. Code Python\n'
    res = engine.update_file('notes.txt', new_text, author='Jacob')
    print(f"Update Result: {res['status']}")
    print('\n--- 3. Inspecting History ---')
    history = engine.get_history('notes.txt')
    for event in history:
        print(f"\n[{event['timestamp']}] {event['change_type']} by {event['author']}")
        print(f"Diff Preview:\n{event['diff_blob'].strip()}")
    print('\n--- 4. Inspecting Head (Cache) ---')
    print(engine.get_head('notes.txt'))
    if DB_PATH.exists():
        os.remove(DB_PATH)

--------------------------------------------------------------------------------
FILE: src\microservices\_ErrorNotifierMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _ErrorNotifierMS
ROLE: Reactive Error Dispatcher (Task 3)
"""
import logging
from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='ErrorNotifier', 
    version='1.0.0', 
    description='Reactive service that normalizes and dispatches engine errors to UI/Logs.', 
    tags=['utility', 'error-handling'], 
    capabilities=['ui-notification'], 
    internal_dependencies=['microservice_std_lib']
)
class ErrorNotifierMS:
    def __init__(self, bus):
        self.bus = bus
        self.logger = logging.getLogger("ErrorNotifier")

    def on_engine_error(self, payload: Dict[str, Any]):
        """
        Subscribed handler for engine failures.
        Safely extracts error details and emits normalized UI/Logging events.
        """
        # 1. Safely extract message with fallback
        msg = payload.get('message') or payload.get('msg') or "Unknown Engine Error"
        file_ctx = f" in {payload['file']}" if 'file' in payload else ""
        hunk_ctx = f" (Hunk: {payload['hunk_name']})" if 'hunk_name' in payload else ""
        
        full_report = f"❌ ENGINE ERROR: {msg}{file_ctx}{hunk_ctx}"

        # 2. Dispatch to the UI via the Signal Bus
        # This keeps the notifier decoupled from the UI implementation details
        self.bus.emit("notify_error", {"message": full_report, "level": "ERROR"})
        
        # 3. Log internally for standard output
        self.logger.error(full_report)

    def on_commit_failed(self, payload: Dict[str, Any]):
        """Handles failures during file write operations."""
        file_path = payload.get('file', 'unknown file')
        error = payload.get('error', 'unknown write error')
        
        report = f"💾 COMMIT FAILED: Could not update {file_path}. Error: {error}"
        self.bus.emit("notify_error", {"message": report, "level": "CRITICAL"})


--------------------------------------------------------------------------------
FILE: src\microservices\_FeedbackValidationMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _FeedbackValidationMS
ENTRY_POINT: _FeedbackValidationMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: sqlite3, json
"""
import sqlite3
import json
import datetime
from typing import Dict, Any, List, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(
    name='FeedbackValidation', 
    version='1.0.0', 
    description='System-level memory layer for recording HITL feedback and transaction validation.',
    tags=['hitl', 'training', 'validation', 'context'],
    capabilities=['db:sqlite', 'training-data:export'],
    side_effects=['db:write'],
    internal_dependencies=['base_service', 'microservice_std_lib']
)
class FeedbackValidationMS(BaseService):
    """
    The Validator: Records accepted/rejected transactions into a dedicated
    training table within the knowledge graph for future prompt context.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('FeedbackValidation')
        self.config = config or {}
        self.db_path = self.config.get('db_path', 'knowledge.db')
        self._init_training_table()

    def _init_training_table(self):
        """Ensures the knowledge graph can store validated transactions."""
        conn = sqlite3.connect(self.db_path)
        # Create a specific table for training pairs
        conn.execute('''
            CREATE TABLE IF NOT EXISTS training_data (
                id INTEGER PRIMARY KEY,
                timestamp TEXT,
                prompt TEXT,
                response TEXT,
                is_accepted INTEGER,
                metadata_json TEXT
            )
        ''')
        conn.close()

    @service_endpoint(
        inputs={'prompt': 'str', 'response': 'str', 'is_accepted': 'bool', 'meta': 'Dict'},
        outputs={'success': 'bool'},
        description='Records a validated or rejected transaction as training context.',
        tags=['write', 'hitl'],
        side_effects=['db:write']
    )
    # ROLE: Records a validated or rejected transaction as training context.
    # INPUTS: {"is_accepted": "bool", "meta": "Dict", "prompt": "str", "response": "str"}
    # OUTPUTS: {"success": "bool"}
    def submit_feedback(self, prompt: str, response: str, is_accepted: bool, meta: Dict = None) -> bool:
        """
        Main entry point for the HITL UI to deposit the result of an inference turn.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            timestamp = datetime.datetime.utcnow().isoformat()
            
            # 1. Insert into raw training table
            cursor.execute(
                'INSERT INTO training_data (timestamp, prompt, response, is_accepted, metadata_json) VALUES (?, ?, ?, ?, ?)',
                (timestamp, prompt, response, 1 if is_accepted else 0, json.dumps(meta or {}))
            )
            
            # 2. Also register as a Graph Node for high-level mapping
            node_id = f"tx_{cursor.lastrowid}"
            cursor.execute(
                'INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json) VALUES (?, ?, ?, ?)',
                (node_id, 'validated_transaction', f"Feedback: {'Accepted' if is_accepted else 'Rejected'}", json.dumps({'is_accepted': is_accepted}))
            )
            
            conn.commit()
            conn.close()
            self.log_info(f"Transaction recorded: {'ACCEPTED' if is_accepted else 'REJECTED'}")
            return True
        except Exception as e:
            self.log_error(f"Failed to record feedback: {e}")
            return False

    @service_endpoint(
        inputs={'limit': 'int', 'only_accepted': 'bool'},
        outputs={'history': 'List[Dict]'},
        description='Retrieves past validated transactions to build few-shot prompts.',
        tags=['read', 'prompt-builder'],
        side_effects=['db:read']
    )
    # ROLE: Retrieves past validated transactions to build few-shot prompts.
    # INPUTS: {"limit": "int", "only_accepted": "bool"}
    # OUTPUTS: {"history": "List[Dict]"}
    def get_validated_context(self, limit: int = 5, only_accepted: bool = True) -> List[Dict]:
        """
        Called by the system building the prompt to find 'Gold Standard' examples.
        """
        conn = sqlite3.connect(self.db_path)
        query = "SELECT prompt, response FROM training_data WHERE 1=1"
        if only_accepted:
            query += " AND is_accepted = 1"
        query += " ORDER BY id DESC LIMIT ?"
        
        results = conn.execute(query, (limit,)).fetchall()
        conn.close()
        
        return [{"prompt": r[0], "response": r[1]} for r in results]

    @service_endpoint(
        inputs={'artifact': 'Dict', 'is_accepted': 'bool'},
        outputs={'success': 'bool'},
        description='Unwraps a standard Cell Artifact and submits it for validation.',
        tags=['write', 'hitl', 'helper']
    )
    # ROLE: Unwraps a standard Cell Artifact and submits it for validation.
    # INPUTS: {"artifact": "Dict", "is_accepted": "bool"}
    # OUTPUTS: {"success": "bool"}
    def validate_artifact(self, artifact: Dict[str, Any], is_accepted: bool) -> bool:
        """
        Convenience wrapper for Standard Artifacts.
        """
        try:
            meta = artifact.get('metadata', {})
            instructions = artifact.get('instructions', {})
            
            # Reconstruct the full prompt context
            sys_role = instructions.get('system_role', '')
            sys_prompt = instructions.get('system_prompt', '')
            user_payload = artifact.get('payload', '')
            
            full_prompt = f"Role: {sys_role}\nContext: {sys_prompt}\nTask: {user_payload}"
            response = artifact.get('response', '') # Assuming response is injected into artifact before validation
            
            return self.submit_feedback(full_prompt, response, is_accepted, meta)
        except Exception as e:
            self.log_error(f"Artifact validation failed: {e}")
            return False


--------------------------------------------------------------------------------
FILE: src\microservices\_HydrationFactoryMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _HydrationFactoryMS
ENTRY_POINT: _HydrationFactoryMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib, _CodeFormatterMS, _TreeMapperMS, _VectorFactoryMS
EXTERNAL_DEPENDENCIES: None
"""
import os
import json
import logging
from typing import Dict, Any, Optional, List, Union
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(
    name='HydrationFactory',
    version='1.0.0',
    description='The Fabricator: Converts raw Cell Artifacts into hydrated, usable products (Files, Maps, Memories).',
    tags=['utility', 'converter', 'factory', 'output'],
    capabilities=['filesystem:write', 'compute', 'db:vector'],
    side_effects=['filesystem:write', 'db:write'],
    internal_dependencies=['base_service', 'microservice_std_lib', '_CodeFormatterMS', '_TreeMapperMS', '_VectorFactoryMS']
)
class HydrationFactoryMS(BaseService):
    """
    The Fabricator.
    Takes a raw JSON Artifact from a Cell and "Hydrates" it into a final product
    based on the requested mode.
    
    Modes:
    1. SCAFFOLD (Code): Formats and writes source code to disk.
    2. BLUEPRINT (Doc): Generates a project tree map.
    3. MEMORY (Vector): Embeds the artifact into a Vector Store (Long-term memory).
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None, services: Optional[Dict[str, Any]] = None):
        super().__init__('HydrationFactory')
        self.config = config or {}
        self.services = services or {}

        # Specialists are injected by the orchestration layer.
        # Expected keys: formatter, mapper, vector_factory, ingest_engine
        self.formatter = self.services.get('formatter')
        self.mapper = self.services.get('mapper')
        self.vector_factory = self.services.get('vector_factory')
        self.ingest_engine = self.services.get('ingest_engine')

    @service_endpoint(
        inputs={'artifact': 'Dict', 'mode': 'str', 'destination': 'str'},
        outputs={'status': 'str', 'details': 'Dict'},
        description='Main entry point to hydrate an artifact into a concrete product.',
        tags=['factory', 'execute']
    )
    # ROLE: Main entry point to hydrate an artifact into a concrete product.
    # INPUTS: {"artifact": "Dict", "destination": "str", "mode": "str"}
    # OUTPUTS: {"details": "Dict", "status": "str"}
    def hydrate_artifact(self, artifact: Dict[str, Any], mode: str, destination: str) -> Dict[str, Any]:
        """
        :param artifact: The standardized JSON output from a Cell.
        :param mode: 'scaffold', 'blueprint', or 'memory'.
        :param destination: File path (for scaffold/blueprint) or Collection name (for memory).
        """
        self.log_info(f"Hydrating artifact via mode: {mode.upper()} -> {destination}")
        
        try:
            if mode.lower() == 'scaffold':
                return self._hydrate_scaffold(artifact, destination)
            elif mode.lower() == 'blueprint':
                return self._hydrate_blueprint(destination)
            elif mode.lower() == 'memory':
                return self._hydrate_memory(artifact, destination)
            else:
                raise ValueError(f"Unknown hydration mode: {mode}")
        except Exception as e:
            self.log_error(f"Hydration failed: {e}")
            return {"status": "error", "message": str(e)}

    def _hydrate_scaffold(self, artifact: Dict[str, Any], file_path: str) -> Dict[str, Any]:
        """Writes the payload to a file after passing it through the CodeFormatter."""
        content = artifact.get('payload', '')
        if not content:
            return {"status": "skipped", "reason": "Empty payload"}

        # 1. Format the code (The Architect)
        # We assume Python for now, but this could be dynamic based on extension
        formatted_result = self.formatter.normalize_code(content, spaces=4)
        final_code = formatted_result.get('normalized', content)
        hunks_applied = len(formatted_result.get('patch', {}).get('hunks', []))

        # 2. Write to disk
        os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(final_code)

        return {
            "status": "success",
            "type": "file_write",
            "path": file_path,
            "formatting_hunks_applied": hunks_applied
        }

    def _hydrate_blueprint(self, root_path: str) -> Dict[str, Any]:
        """Generates a project tree map and saves it to a file."""
        # 1. Generate Map (The Cartographer)
        tree_map = self.mapper.generate_tree(root_path)
        
        # 2. Save to _project_map.txt in the root
        output_path = os.path.join(root_path, '_project_map.txt')
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(tree_map)

        return {
            "status": "success",
            "type": "map_generation",
            "path": output_path,
            "size": len(tree_map)
        }

    def _hydrate_memory(self, artifact: Dict[str, Any], collection_name: str) -> Dict[str, Any]:
        """Embeds the artifact payload into the Vector Store."""
        # 1. Create Vector Store Connection (The Switchboard)
        # Defaulting to Chroma for persistence, could be config-driven
        store = self.vector_factory.create('chroma', {'path': './knowledge_base', 'collection': collection_name})
        
        # 2. Prepare Data
        # We embed the payload (content) and attach the metadata
        payload = artifact.get('payload', '')
        if not payload:
             return {"status": "skipped", "reason": "Empty payload"}
             
        # Generate a simple embedding (Mocked here, normally uses IngestEngine or internal embedder)
        # In a real flow, we'd call an embedding service. 
        # For the factory, we assume the artifact might already have a vector, 
        # or we generate a placeholder/call a service if we want to be fully self-contained.
        # SIMPLIFICATION: We will require the embedding to be passed or we skip it for this stub.
        # Ideally, we call self.ingest_engine.get_embedding(payload)
        
        # For now, we just store the text without vector search if no embedding provided (Chroma handles raw text too usually)
        # But our VectorStore protocol expects embeddings.
        # ENGINE: injected by orchestration layer
        if not getattr(self, 'ingest_engine', None):
            return {"status": "error", "message": "IngestEngine not injected"}

        engine = self.ingest_engine
        # We use a standard small model for embeddings (e.g., all-minilm)
        vector = engine._get_embedding(model="nomic-embed-text", text=payload)
        
        if not vector:
            self.log_warning("Could not generate embedding, falling back to mock.")
            vector = [0.0] * 384

        store.add(
            embeddings=[vector],
            metadatas=[artifact.get('metadata', {})]
        )

        return {
            "status": "success",
            "type": "memory_storage",
            "collection": collection_name,
            "item_count": store.count()
        }

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    
    # Test Harness
    factory = HydrationFactoryMS()
    print(f"Service Ready: {factory}")
    
    # Mock Artifact
    test_artifact = {
        "metadata": {"author": "TheCell", "version": "1.0"},
        "payload": "def hello_world():\n  print('Hello from the Factory!')",
        "instructions": {"system_prompt": "Write python code"}
    }
    
    print("\n--- Testing Code Hydration ---")
    res = factory.hydrate_artifact(test_artifact, mode='scaffold', destination='./_test_output.py')
    print(json.dumps(res, indent=2))
    
    print("\n--- Testing Clean Up ---")
    if os.path.exists('./_test_output.py'):
        os.remove('./_test_output.py')
        print("Cleaned up test file.")



--------------------------------------------------------------------------------
FILE: src\microservices\_IngestEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _IngestEngineMS
ENTRY_POINT: _IngestEngineMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: requests
"""
import importlib.util
import sys
REQUIRED = ['requests']
MISSING = []
for lib in REQUIRED:
    if importlib.util.find_spec(lib) is None:
        MISSING.append(lib)
if MISSING:
    print(f"MISSING DEPENDENCIES: {' '.join(MISSING)}")
    print('Please run: pip install requests')
import json
import os
import re
import sqlite3
import time
from dataclasses import dataclass
from typing import Any, Dict, Generator, List, Optional
import requests
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
from ._TextChunkerMS import TextChunkerMS
OLLAMA_API_URL = 'http://localhost:11434/api'

@dataclass
class IngestStatus:
    current_file: str
    progress_percent: float
    processed_files: int
    total_files: int
    log_message: str
    thought_frame: Optional[Dict] = None

class SynapseWeaver:
    """
    Parses source code to extract import dependencies.
    Used to generate the 'DEPENDS_ON' edges in the Knowledge Graph.
    """

    def __init__(self):
        self.py_pattern = re.compile('^\\s*(?:from|import)\\s+([\\w\\.]+)')
        self.js_pattern = re.compile('(?:import\\s+.*?from\\s+[\\\'"]|require\\([\\\'"])([\\.\\/\\w\\-_]+)[\\\'"]')

    def extract_dependencies(self, content: str, file_path: str) -> List[str]:
        dependencies = []
        ext = os.path.splitext(file_path)[1].lower()
        lines = content.split('\n')
        for line in lines:
            match = None
            if ext == '.py':
                match = self.py_pattern.match(line)
            elif ext in ['.js', '.ts', '.tsx', '.jsx']:
                match = self.js_pattern.search(line)
            if match:
                raw_dep = match.group(1)
                clean_dep = raw_dep.split('.')[-1].split('/')[-1]
                if clean_dep not in dependencies:
                    dependencies.append(clean_dep)
        return dependencies

@service_metadata(name='IngestEngine', version='1.0.0', description='Reads files, chunks text, fetches embeddings, and weaves graph edges.', tags=['ingest', 'rag', 'parsing', 'embedding'], capabilities=['filesystem:read', 'network:outbound', 'db:sqlite'], side_effects=['db:write', 'network:outbound'], internal_dependencies=['base_service', 'microservice_std_lib'], external_dependencies=['requests'])
class IngestEngineMS(BaseService):
    """
    The Heavy Lifter: Reads files, chunks text, fetches embeddings,
    populates the Graph Nodes, and weaves Graph Edges.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('IngestEngine')
        self.config = config or {}
        self.db_path = self.config.get('db_path', 'knowledge.db')
        self.stop_signal = False
        self.weaver = SynapseWeaver()
        self.chunker = TextChunkerMS()
        self._init_db()

    def _init_db(self):
        """Ensures the target database has the required schema."""
        conn = sqlite3.connect(self.db_path)
        conn.execute('CREATE TABLE IF NOT EXISTS files (id INTEGER PRIMARY KEY, path TEXT, last_updated REAL)')
        conn.execute('CREATE TABLE IF NOT EXISTS chunks (id INTEGER PRIMARY KEY, file_id INT, chunk_index INT, content TEXT, embedding BLOB)')
        conn.execute('CREATE TABLE IF NOT EXISTS graph_nodes (id TEXT PRIMARY KEY, type TEXT, label TEXT, data_json TEXT)')
        conn.execute('CREATE TABLE IF NOT EXISTS graph_edges (source TEXT, target TEXT, weight REAL)')
        conn.close()

    def abort(self):
        self.stop_signal = True

    def check_ollama_connection(self) -> bool:
        try:
            requests.get(f'{OLLAMA_API_URL}/tags', timeout=2)
            return True
        except:
            return False

    def get_available_models(self) -> List[str]:
        try:
            res = requests.get(f'{OLLAMA_API_URL}/tags')
            if res.status_code == 200:
                data = res.json()
                return [m['name'] for m in data.get('models', [])]
        except:
            pass
        return []

    @service_endpoint(
        inputs={'prompt': 'str', 'model': 'str', 'system': 'str'}, 
        outputs={'chunk': 'str'}, 
        description='Streams inference tokens from Ollama.', 
        tags=['inference', 'stream'], 
        mode='generator', 
        side_effects=['network:outbound']
    )
    # ROLE: Streams inference tokens from Ollama.
    # INPUTS: {"model": "str", "prompt": "str", "system": "str"}
    # OUTPUTS: {"chunk": "str"}
    def generate_stream(self, prompt: str, model: str, system: str = '') -> Generator[str, None, None]:
        """Yields tokens from the LLM for real-time UI updates."""
        url = f"{OLLAMA_API_URL}/generate"
        payload = {
            "model": model,
            "prompt": prompt,
            "system": system,
            "stream": True
        }
        
        try:
            with requests.post(url, json=payload, stream=True, timeout=120) as r:
                if r.status_code != 200:
                    yield f"[Error: Ollama returned status {r.status_code}]"
                    return
                
                for line in r.iter_lines():
                    if self.stop_signal:
                        break
                    if line:
                        try:
                            body = json.loads(line)
                            token = body.get('response', '')
                            if token:
                                yield token
                            if body.get('done', False):
                                break
                        except json.JSONDecodeError:
                            continue
        except Exception as e:
            yield f"[Connection Error: {str(e)}]"

    @service_endpoint(inputs={'file_paths': 'List[str]', 'model_name': 'str'}, outputs={'status': 'IngestStatus'}, description='Processes a list of files, ingesting them into the knowledge graph.', tags=['ingest', 'processing'], mode='generator', side_effects=['db:write', 'network:outbound'])
    # ROLE: Processes a list of files, ingesting them into the knowledge graph.
    # INPUTS: {"file_paths": "List[str]", "model_name": "str"}
    # OUTPUTS: {"status": "IngestStatus"}
    def process_files(self, file_paths: List[str], model_name: str='none') -> Generator[IngestStatus, None, None]:
        total = len(file_paths)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('PRAGMA synchronous = OFF')
        cursor.execute('PRAGMA journal_mode = MEMORY')
        node_registry = {}
        file_contents = {}
        for idx, file_path in enumerate(file_paths):
            if self.stop_signal:
                yield IngestStatus(file_path, 0, idx, total, 'Ingestion Aborted.')
                break
            filename = os.path.basename(file_path)
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                file_contents[filename] = content
            except Exception as e:
                yield IngestStatus(file_path, idx / total * 100, idx, total, f'Error: {e}')
                continue
            try:
                cursor.execute('INSERT OR REPLACE INTO files (path, last_updated) VALUES (?, ?)', (file_path, time.time()))
                file_id = cursor.lastrowid
            except sqlite3.Error:
                continue
            cursor.execute('\n                INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json)\n                VALUES (?, ?, ?, ?)\n            ', (filename, 'file', filename, json.dumps({'path': file_path})))
            node_registry[filename] = filename
            chunks = self._chunk_text(content)
            for i, chunk_text in enumerate(chunks):
                if self.stop_signal:
                    break
                embedding = None
                if model_name != 'none':
                    embedding = self._get_embedding(model_name, chunk_text)
                emb_blob = json.dumps(embedding).encode('utf-8') if embedding else None
                cursor.execute('\n                    INSERT INTO chunks (file_id, chunk_index, content, embedding)\n                    VALUES (?, ?, ?, ?)\n                ', (file_id, i, chunk_text, emb_blob))
                thought_frame = {'id': f'{file_id}_{i}', 'file': filename, 'chunk_index': i, 'content': chunk_text, 'vector_preview': embedding[:20] if embedding else [], 'concept_color': '#007ACC'}
                yield IngestStatus(current_file=filename, progress_percent=(idx + i / len(chunks)) / total * 100, processed_files=idx, total_files=total, log_message=f'Processing {filename}...', thought_frame=thought_frame)
            conn.commit()
        yield IngestStatus('Graph', 100, total, total, 'Weaving Knowledge Graph...')
        edge_count = 0
        for filename, content in file_contents.items():
            if self.stop_signal:
                break
            deps = self.weaver.extract_dependencies(content, filename)
            for dep in deps:
                target_id = None
                for potential_match in node_registry.keys():
                    if potential_match.startswith(dep + '.') or potential_match == dep:
                        target_id = potential_match
                        break
                if target_id and target_id != filename:
                    try:
                        cursor.execute('\n                            INSERT OR IGNORE INTO graph_edges (source, target, weight)\n                            VALUES (?, ?, 1.0)\n                        ', (filename, target_id))
                        edge_count += 1
                    except:
                        pass
        conn.commit()
        conn.close()
        yield IngestStatus(current_file='Complete', progress_percent=100, processed_files=total, total_files=total, log_message=f'Ingestion Complete. Created {edge_count} dependency edges.')

    def _chunk_text(self, text: str, chunk_size: int=1000, overlap: int=100) -> List[str]:
        # Delegate to the specialized service
        return self.chunker.chunk_by_chars(text, chunk_size, overlap)

    def _get_embedding(self, model: str, text: str) -> Optional[List[float]]:
        try:
            res = requests.post(f'{OLLAMA_API_URL}/embeddings', json={'model': model, 'prompt': text}, timeout=30)
            if res.status_code == 200:
                return res.json().get('embedding')
        except:
            return None
if __name__ == '__main__':
    TEST_DB = 'test_ingest_v2.db'
    engine = IngestEngineMS({'db_path': TEST_DB})
    print(f'Service Ready: {engine}')
    target_file = '__IngestEngineMS.py'
    if not os.path.exists(target_file):
        with open(target_file, 'w') as f:
            f.write("import os\nimport json\nprint('Hello World')")
    print(f'Running Ingest on {target_file}...')
    files = [target_file]
    for status in engine.process_files(files, 'none'):
        print(f'[{status.progress_percent:.0f}%] {status.log_message}')
    conn = sqlite3.connect(TEST_DB)
    edges = conn.execute('SELECT * FROM graph_edges').fetchall()
    nodes = conn.execute('SELECT * FROM graph_nodes').fetchall()
    print(f'\nResult: {len(nodes)} Nodes, {len(edges)} Edges.')
    conn.close()
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)
    if os.path.exists(target_file) and 'Hello World' in open(target_file).read():
        os.remove(target_file)


--------------------------------------------------------------------------------
FILE: src\microservices\_LogViewMS.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import scrolledtext, filedialog
import queue
import logging
import datetime
from typing import Any, Dict, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

class QueueHandler(logging.Handler):
    """
    Sends log records to a thread-safe queue.
    Used to bridge the gap between Python's logging system and the Tkinter UI.
    """

    def __init__(self, log_queue: queue.Queue):
        super().__init__()
        self.log_queue = log_queue

    def emit(self, record):
        self.log_queue.put(record)

@service_metadata(name='LogView', version='1.0.0', description='A thread-safe log viewer widget for Tkinter.', tags=['ui', 'logs', 'widget'], capabilities=['ui:gui', 'filesystem:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class LogViewMS(tk.Frame, BaseService):
    """
    The Console: A professional log viewer widget.
    Features:
    - Thread-safe (consumes from a Queue).
    - Message Consolidation ("Error occurred (x5)").
    - Level Filtering (Toggle INFO/DEBUG/ERROR).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None, theme: Optional[Dict[str, Any]]=None, bus: Optional[Any]=None):
        self.config = config or {}
        parent = self.config.get('parent')
        self.colors = theme or {}
        self.bus = bus
        
        tk.Frame.__init__(self, parent, bg=self.colors.get('background', '#1e1e1e'))
        BaseService.__init__(self, 'LogView')
        
        self.log_queue: queue.Queue = self.config.get('log_queue')
        if self.log_queue is None:
            self.log_queue = queue.Queue()
        
        self.last_msg = None
        self.last_count = 0
        self.last_line_index = None
        
        self._build_ui()
        self._poll_queue()

        if self.bus:
            self.bus.subscribe("theme_updated", self.refresh_theme)

    def _build_ui(self):
        self.toolbar = tk.Frame(self, bg=self.colors.get('panel_bg', '#2d2d2d'), height=30)
        self.toolbar.pack(fill='x', side='top')
        
        self.filters = {'INFO': tk.BooleanVar(value=True), 'DEBUG': tk.BooleanVar(value=True), 'WARNING': tk.BooleanVar(value=True), 'ERROR': tk.BooleanVar(value=True)}
        self.filter_btns = []
        
        for level, var in self.filters.items():
            cb = tk.Checkbutton(self.toolbar, text=level, variable=var, 
                                bg=self.colors.get('panel_bg', '#2d2d2d'), 
                                fg=self.colors.get('foreground', 'white'), 
                                selectcolor=self.colors.get('border', '#444'), 
                                activebackground=self.colors.get('panel_bg'))
            cb.pack(side='left', padx=5)
            self.filter_btns.append(cb)
            
        self.btn_clear = tk.Button(self.toolbar, text='Clear', command=self.clear, bg=self.colors.get('border', '#444'), fg=self.colors.get('foreground', 'white'), relief='flat')
        self.btn_clear.pack(side='right', padx=5)
        
        self.btn_save = tk.Button(self.toolbar, text='Save', command=self.save, bg=self.colors.get('border', '#444'), fg=self.colors.get('foreground', 'white'), relief='flat')
        self.btn_save.pack(side='right')
        
        self.text = scrolledtext.ScrolledText(self, state='disabled', bg=self.colors.get('entry_bg', '#1e1e1e'), fg=self.colors.get('entry_fg', '#d4d4d4'), font=('Consolas', 10), insertbackground=self.colors.get('entry_fg', 'white'))
        self.text.pack(fill='both', expand=True)
        
        self.text.tag_config('INFO', foreground=self.colors.get('entry_fg', '#d4d4d4'))
        self.text.tag_config('DEBUG', foreground=self.colors.get('accent', '#569cd6'))
        self.text.tag_config('WARNING', foreground='#ce9178')
        self.text.tag_config('ERROR', foreground=self.colors.get('error', '#f44747'))
        self.text.tag_config('timestamp', foreground='#608b4e')

    def _poll_queue(self):
        """Pulls logs from the queue and updates UI."""
        try:
            while True:
                record = self.log_queue.get_nowait()
                self._display(record)
        except queue.Empty:
            pass
        finally:
            self.after(100, self._poll_queue)

    def _display(self, record):
        level = record.levelname
        if not self.filters.get(level, tk.BooleanVar(value=True)).get():
            return
        msg = record.getMessage()
        ts = datetime.datetime.fromtimestamp(record.created).strftime('%H:%M:%S')
        self.text.config(state='normal')
        if msg == self.last_msg:
            self.last_count += 1
        else:
            self.last_msg = msg
            self.last_count = 1
        self.text.insert('end', f'[{ts}] ', 'timestamp')
        self.text.insert('end', f'{msg}\n', level)
        self.text.see('end')
        self.text.config(state='disabled')

    def refresh_theme(self, new_colors):
        """Re-applies new theme colors to the widget."""
        self.colors = new_colors
        self.configure(bg=self.colors.get('background'))
        self.toolbar.configure(bg=self.colors.get('panel_bg'))
        
        for btn in self.filter_btns:
            btn.configure(bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'), selectcolor=self.colors.get('border'))
            
        self.btn_clear.configure(bg=self.colors.get('border'), fg=self.colors.get('foreground'))
        self.btn_save.configure(bg=self.colors.get('border'), fg=self.colors.get('foreground'))
        
        self.text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.text.tag_config('INFO', foreground=self.colors.get('entry_fg'))
        self.text.tag_config('DEBUG', foreground=self.colors.get('accent'))
        self.text.tag_config('ERROR', foreground=self.colors.get('error'))

    @service_endpoint(inputs={}, outputs={}, description='Clears the log console.', tags=['ui', 'logs'], side_effects=['ui:update'])
    def clear(self):
        self.text.config(state='normal')
        self.text.delete('1.0', 'end')
        self.text.config(state='disabled')

    @service_endpoint(inputs={}, outputs={}, description='Opens a dialog to save logs to a file.', tags=['ui', 'filesystem'], side_effects=['filesystem:write', 'ui:dialog'])
    def save(self):
        path = filedialog.asksaveasfilename(defaultextension='.log', filetypes=[('Log Files', '*.log')])
        if path:
            try:
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(self.text.get('1.0', 'end'))
            except Exception as e:
                print(f'Save failed: {e}')
if __name__ == '__main__':
    root = tk.Tk()
    root.title('Log View Test')
    root.geometry('600x400')
    q = queue.Queue()
    logger = logging.getLogger('TestApp')
    logger.setLevel(logging.DEBUG)
    logger.addHandler(QueueHandler(q))
    log_view = LogViewMS({'parent': root, 'log_queue': q})
    print('Service ready:', log_view)
    log_view.pack(fill='both', expand=True)

    def generate_noise():
        logger.info('System initializing...')
        logger.debug('Checking sensors...')
        logger.warning('Sensor 4 response slow.')
        logger.error('Connection failed!')
        root.after(2000, generate_noise)
    generate_noise()
    root.mainloop()



--------------------------------------------------------------------------------
FILE: src\microservices\_MicroSpinnerMS.py
--------------------------------------------------------------------------------
import tkinter as tk
import math
import threading

class MicroSpinner:
    """
    A standalone ASCII spinner for Tkinter Text widgets.
    """
    def __init__(self, text_widget, center_row=5, center_col=20, radius=3, speed=0.2):
        self.txt = text_widget
        self.center_row = center_row
        self.center_col = center_col
        self.radius = radius
        self.speed = speed
        
        self.angle = 0.0
        self.is_running = False
        self.trail = []  # Stores (index, symbol)
        self.symbols = ["@", "#", "*", "+", ".", " "] # Fade sequence
        
        # Initialize a small blank area in the text box if empty
        if self.txt.get("1.0", tk.END).strip() == "":
            blank_block = (" " * 80 + "\n") * 20
            self.txt.insert("1.0", blank_block)

    def _get_pos(self, angle_offset=0):
        """Calculates a specific coordinate based on angle."""
        # 2.2 factor compensates for rectangular font pixels
        x = int(self.center_col + (self.radius * 2.2) * math.cos(self.angle - angle_offset))
        y = int(self.center_row + self.radius * math.sin(self.angle - angle_offset))
        return f"{y}.{x}"

    def update(self):
        if not self.is_running:
            # Clean up the trail when stopping
            for pos in self.trail:
                self._write_at(pos, " ")
            self.trail = []
            return

        # 1. Calculate current head position
        head_pos = self._get_pos(0)
        
        # 2. Add new head to trail, remove oldest if too long
        self.trail.insert(0, head_pos)
        if len(self.trail) > len(self.symbols):
            old_pos = self.trail.pop()
            self._write_at(old_pos, " ")

        # 3. Draw the trail with fading symbols
        for i, pos in enumerate(self.trail):
            symbol = self.symbols[i] if i < len(self.symbols) else " "
            self._write_at(pos, symbol)

        self.angle += self.speed
        self.txt.after(50, self.update)

    def _write_at(self, index, char):
        """Surgically replaces a single character at a Tkinter index."""
        try:
            self.txt.delete(index)
            self.txt.insert(index, char)
        except tk.TclError:
            pass # Handle case where text widget might be cleared externally

    def start(self):
        if not self.is_running:
            self.is_running = True
            self.update()

    def stop(self):
        self.is_running = False
--------------------------------------------------------------------------------
FILE: src\microservices\_OllamaModelSelectorMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _OllamaModelSelectorMS
ENTRY_POINT: _OllamaModelSelectorMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: requests
"""
import tkinter as tk
from tkinter import ttk
import requests
import threading
import logging
from typing import Dict, Any, Optional, List, Callable
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

OLLAMA_TAGS_URL = "http://localhost:11434/api/tags"

@service_metadata(
    name='OllamaModelSelector', 
    version='1.0.0', 
    description='The Lens: A UI widget that fetches and displays available local Ollama models.', 
    tags=['ui', 'ai', 'ollama', 'widget'], 
    capabilities=['ui:gui', 'network:outbound'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=['requests']
)
class OllamaModelSelectorMS(tk.Frame, BaseService):
    """
    The Lens.
    A dropdown widget that automatically polls the local Ollama API for models.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None, theme: Optional[Dict[str, Any]] = None, bus: Optional[Any] = None):
        # Initialize BaseService first for logging
        BaseService.__init__(self, 'OllamaModelSelector')
        
        self.config_data = config or {}
        self.colors = theme or {}
        self.bus = bus
        
        parent = self.config_data.get('parent')
        self.on_change_callback = self.config_data.get('on_change')
        
        # Initialize the Tkinter Frame
        tk.Frame.__init__(self, parent, bg=self.colors.get('panel_bg', '#252526'))

        if self.bus:
            self.bus.subscribe("theme_updated", self.refresh_theme)
        
        self.models: List[str] = ["Scanning..."]
        self._build_ui()
        
        # Start background scan so the UI doesn't hang
        threading.Thread(target=self.refresh_models, daemon=True).start()

    def _build_ui(self):
        """Creates the label and combobox."""
        self.label = tk.Label(
            self, text="AI MODEL:", 
            bg=self.colors.get('panel_bg', self.cget('bg')), 
            fg=self.colors.get('foreground', 'white'), 
            font=('Segoe UI', 9, 'bold')
        )
        self.label.pack(side='left', padx=(5, 10))

        self.combo = ttk.Combobox(self, values=self.models, state="readonly", width=25)
        self.combo.set(self.models[0])
        self.combo.pack(side='left', padx=5)
        self.combo.bind("<<ComboboxSelected>>", self._on_selection)

    @service_endpoint(
        inputs={}, 
        outputs={'models': 'List[str]'}, 
        description='Queries local Ollama API to refresh the list of available models.', 
        tags=['network', 'refresh']
    )
    # ROLE: Queries local Ollama API to refresh the list of available models.
    # INPUTS: {}
    # OUTPUTS: {"models": "List[str]"}
    def refresh_models(self) -> List[str]:
        """Fetches models from Ollama tags endpoint."""
        try:
            response = requests.get(OLLAMA_TAGS_URL, timeout=3)
            if response.status_code == 200:
                data = response.json()
                self.models = [m['name'] for m in data.get('models', [])]
                self.log_info(f"Discovered {len(self.models)} local models.")
            else:
                self.models = ["Ollama Offline"]
        except Exception as e:
            self.log_error(f"Failed to reach Ollama: {e}")
            self.models = ["Connection Error"]

        # Update the UI from the main thread
        self.after(0, lambda: self.combo.config(values=self.models))
        if self.models and self.models[0] not in ["Connection Error", "Ollama Offline"]:
            self.after(0, lambda: self.combo.current(0))
        
        return self.models

    def _on_selection(self, event):
        """Triggered when the user picks a new model."""
        selected = self.combo.get()
        self.log_info(f"Model selected: {selected}")
        if self.on_change_callback:
            self.on_change_callback(selected)

    @service_endpoint(
        inputs={}, 
        outputs={'selected_model': 'str'}, 
        description='Returns the currently selected model string.', 
        tags=['ui', 'read']
    )
    # ROLE: Returns the currently selected model string.
    # INPUTS: {}
    # OUTPUTS: {"selected_model": "str"}
    def get_selected_model(self) -> str:
        """Retrieves current selection from the combobox."""
        return self.combo.get()

    def refresh_theme(self, new_colors):
        """Re-applies new theme colors to the widget."""
        self.colors = new_colors
        self.configure(bg=self.colors.get('panel_bg'))
        self.label.configure(
            bg=self.colors.get('panel_bg'), 
            fg=self.colors.get('foreground')
        )

if __name__ == '__main__':
    root = tk.Tk()
    root.title("Ollama Selector Test")
    root.geometry("400x100")
    
    # Simple callback test
    def log_change(m): print(f"Signal emitted for model: {m}")
    
    selector = OllamaModelSelectorMS({'parent': root, 'on_change': log_change})
    selector.pack(pady=20)
    
    root.mainloop()


--------------------------------------------------------------------------------
FILE: src\microservices\_RegexWeaverMS.py
--------------------------------------------------------------------------------
import re
import logging
from typing import Any, Dict, List, Optional, Set
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
PY_IMPORT = re.compile('^\\s*(?:from|import)\\s+([\\w\\.]+)')
JS_IMPORT = re.compile('(?:import\\s+.*?from\\s+[\\\'"]|require\\([\\\'"])([\\.\\/\\w\\-_]+)[\\\'"]')
logger = logging.getLogger('RegexWeaver')

@service_metadata(name='RegexWeaver', version='1.0.0', description='Fault-tolerant dependency extractor using Regex.', tags=['parsing', 'dependencies', 'regex'], capabilities=['compute'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class RegexWeaverMS(BaseService):
    """
    The Weaver: A fault-tolerant dependency extractor.
    Uses Regex to find imports, making it faster and more permissive
    than AST parsers (works on broken code).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('RegexWeaver')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'language': 'str'}, outputs={'dependencies': 'List[str]'}, description='Scans code content for import statements.', tags=['parsing', 'dependencies'], side_effects=[])
    # ROLE: Scans code content for import statements.
    # INPUTS: {"content": "str", "language": "str"}
    # OUTPUTS: {"dependencies": "List[str]"}
    def extract_dependencies(self, content: str, language: str) -> List[str]:
        """
        Scans code content for import statements.
        :param language: 'python' or 'javascript' (includes ts/jsx).
        """
        dependencies: Set[str] = set()
        lines = content.splitlines()
        pattern = PY_IMPORT if language == 'python' else JS_IMPORT
        for line in lines:
            if line.strip().startswith(('#', '//')):
                continue
            if language == 'python':
                match = pattern.match(line)
            else:
                match = pattern.search(line)
            if match:
                raw_dep = match.group(1)
                clean_dep = raw_dep.split('.')[-1].split('/')[-1]
                dependencies.add(clean_dep)
        return sorted(list(dependencies))
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    weaver = RegexWeaverMS()
    print('Service ready:', weaver)
    py_code = '\n    import os\n    from backend.utils import helper\n    # from commented.out import ignore_me\n    import pandas as pd\n    '
    print(f"Python Deps: {weaver.extract_dependencies(py_code, 'python')}")
    js_code = "\n    import React from 'react';\n    const utils = require('./lib/utils');\n    // import hidden from 'hidden';\n    "
    print(f"JS Deps:     {weaver.extract_dependencies(js_code, 'javascript')}")


--------------------------------------------------------------------------------
FILE: src\microservices\_RulesEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _RulesEngineMS
ROLE: Operator Governance (Task 4.3)
"""
import logging
from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
def get_default_rules() -> Dict[str, Any]:
    """
    Returns the default safety contracts.
    Hardcoded here to remove dependency on external contract files.
    """
    return {
        "max_hunk_size": 10000,
        "protected_files": [
            "LICENSE.md", 
            "setup_env.bat", 
            ".gitignore",
            "requirements.txt"
        ],
        "forbidden_patterns": [
            "sk-proj-",  # OpenAI keys
            "ghp_",      # GitHub tokens
            "password ="
        ]
    }

@service_metadata(
    name='RulesEngine', 
    version='1.0.0', 
    description='Governance engine for safety and file protection.',
    tags=['governance', 'safety'],
    internal_dependencies=['base_service', 'microservice_std_lib']
)
class RulesEngineMS(BaseService):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('RulesEngine')
        self.rules = get_default_rules()

    @service_endpoint(
        inputs={}, 
        outputs={'rules': 'Dict'},
        description='Returns current active ruleset.'
    )
    # ROLE: Returns current active ruleset.
    # INPUTS: {}
    # OUTPUTS: {"rules": "Dict"}
    def get_rules(self) -> Dict[str, Any]:
        return self.rules.copy()

    def get_rules(self) -> Dict[str, Any]:
        return self.rules.copy()

    def set_rules(self, new_rules: Dict[str, Any]):
        self.rules.update(new_rules)
        self.logger.info("Ruleset updated.")

    def evaluate_file(self, file_path: str) -> tuple:
        """Checks if a file is protected."""
        for p in self.rules.get("protected_files", []):
            if p in file_path:
                return False, f"File is protected by rule: {p}"
        return True, ""

    def evaluate_hunk(self, hunk: dict) -> tuple:
        """Checks hunk constraints like size or forbidden patterns."""
        content = hunk.get('content', '')
        if len(content) > self.rules.get("max_hunk_size", 99999):
            return False, "Hunk exceeds max_hunk_size"
            
        for pattern in self.rules.get("forbidden_patterns", []):
            if pattern in content:
                return False, f"Hunk contains forbidden pattern: {pattern}"
                
        return True, ""





--------------------------------------------------------------------------------
FILE: src\microservices\_SemanticChunkerMS.py
--------------------------------------------------------------------------------
import ast
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@dataclass
class CodeChunk:
    name: str
    type: str
    content: str
    start_line: int
    end_line: int
    docstring: str = ''

@service_metadata(name='SemanticChunker', version='1.0.0', description='The Surgeon: Intelligent Code Splitter that parses source code into logical semantic units (Classes, Functions) using AST.', tags=['utility', 'nlp', 'parser'], capabilities=['python-ast', 'semantic-chunking'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class SemanticChunkerMS(BaseService):
    """
    Intelligent Code Splitter.
    Parses source code into logical units (Classes, Functions) 
    rather than arbitrary text windows.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('SemanticChunker')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'filename': 'str'}, outputs={'chunks': 'List[Dict]'}, description='Main entry point to split a file into semantic chunks based on its extension and content.', tags=['processing', 'chunking'], side_effects=[])
    # ROLE: Main entry point to split a file into semantic chunks based on its extension and content.
    # INPUTS: {"content": "str", "filename": "str"}
    # OUTPUTS: {"chunks": "List[Dict]"}
    def chunk_file(self, content: str, filename: str) -> List[Dict[str, Any]]:
        """
        Splits file content into chunks.
        Returns a list of dictionaries suitable for JSON response.
        """
        chunks: List[CodeChunk] = []
        if filename.endswith('.py'):
            chunks = self._chunk_python(content)
        elif filename.lower().endswith(('.md', '.txt', '.pdf', '.html', '.htm', '.rst')):
            chunks = self._chunk_generic(content, window_size=800)
        else:
            chunks = self._chunk_generic(content, window_size=1500)
        return [asdict(c) for c in chunks]

    def _chunk_python(self, source: str) -> List[CodeChunk]:
        chunks = []
        try:
            tree = ast.parse(source)
            lines = source.splitlines(keepends=True)

            def get_segment(node):
                start = node.lineno - 1
                end = node.end_lineno if hasattr(node, 'end_lineno') and node.end_lineno else start + 1
                return (''.join(lines[start:end]), start + 1, end)
            for node in tree.body:
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ''
                    chunks.append(CodeChunk(name=f'def {node.name}', type='function', content=text, start_line=s, end_line=e, docstring=doc))
                elif isinstance(node, ast.ClassDef):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ''
                    chunks.append(CodeChunk(name=f'class {node.name}', type='class', content=text, start_line=s, end_line=e, docstring=doc))
            if not chunks:
                return self._chunk_generic(source)
        except SyntaxError:
            return self._chunk_generic(source)
        return chunks

    def _chunk_generic(self, text: str, window_size: int=1500) -> List[CodeChunk]:
        """Sliding window for non-code files."""
        chunks = []
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        lines = text.splitlines(keepends=True)
        current_chunk = []
        current_size = 0
        chunk_idx = 1
        start_line = 1
        for i, line in enumerate(lines):
            current_chunk.append(line)
            current_size += len(line)
            if current_size >= window_size:
                chunks.append(CodeChunk(name=f'Chunk {chunk_idx}', type='text_block', content=''.join(current_chunk), start_line=start_line, end_line=i + 1))
                current_chunk = []
                current_size = 0
                chunk_idx += 1
                start_line = i + 2
        if current_chunk:
            chunks.append(CodeChunk(name=f'Chunk {chunk_idx}', type='text_block', content=''.join(current_chunk), start_line=start_line, end_line=len(lines)))
        return chunks
if __name__ == '__main__':
    svc = SemanticChunkerMS()
    print('Service ready:', svc)
    test_code = "def hello():\n    print('world')\n\nclass Test:\n    pass"
    results = svc.chunk_file(test_code, 'test.py')
    print(f'Extracted {len(results)} semantic chunks.')
    for c in results:
        print(f" - [{c['type']}] {c['name']} ({c['start_line']}-{c['end_line']})")
        print(f" - [{c['type']}] {c['name']} ({c['start_line']}-{c['end_line']})")


--------------------------------------------------------------------------------
FILE: src\microservices\_SessionRecorderMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _SessionRecorderMS
ENTRY_POINT: _SessionRecorderMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import os
import datetime
import json
from typing import Dict, Any, Optional
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='SessionRecorder', 
    version='1.0.0', 
    description='The Black Box: Records all project tidying events to a persistent audit log.', 
    tags=['utility', 'logging', 'audit'], 
    capabilities=['filesystem:write'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=[]
)
class SessionRecorderMS(BaseService):
    """
    The Black Box.
    Listens to the SignalBus and writes a chronological record of all actions to disk.
    """

    def __init__(self, state, config: Optional[Dict[str, Any]] = None):
        super().__init__('SessionRecorder')
        self.state = state
        self.config = config or {}
        
        # Set up the log directory
        self.logs_dir = self.config.get('logs_dir', 'tidy_logs')
        os.makedirs(self.logs_dir, exist_ok=True)
        
        # Create a unique filename for this session
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = os.path.join(self.logs_dir, f"tidy_session_{timestamp}.log")
        
        self.log_info(f"Session Recorder initialized. Logging to: {self.log_file}")
        self._write_entry("SESSION_START", {"msg": "Project Tidier session initiated."})

    def _write_entry(self, event_type: str, data: Any):
        """Writes a structured, timestamped entry to the log file."""
        timestamp = datetime.datetime.now().isoformat()
        entry = {
            "timestamp": timestamp,
            "event": event_type,
            "data": data
        }
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            self.log_error(f"Failed to write to audit log: {e}")

    # --- Signal Handlers ---

    def on_scan_started(self, data: Dict[str, Any]):
        self._write_entry("SCAN_INITIATED", data)

    def on_hunk_detected(self, data: Dict[str, Any]):
        # Log that clutter was found, including the filename and hunk name
        log_payload = {
            "file": data.get("file"),
            "hunk": data.get("hunk_name"),
            "chars_before": len(data.get("before", "")),
            "chars_after": len(data.get("after", ""))
        }
        self._write_entry("CLUTTER_DETECTED", log_payload)

    def on_user_decision(self, approved: bool):
        status = "APPROVED" if approved else "SKIPPED"
        # Record decision alongside the current authoritative state phase
        log_payload = {
            "status": status,
            "phase_at_decision": self.state.phase.name,
            "file_affected": self.state.pending_review.get('file') if self.state.pending_review else None
        }
        self._write_entry("USER_DECISION", log_payload)

    def on_commit_success(self, file_path: str):
        self._write_entry("FILE_COMMITTED", {"path": file_path})

if __name__ == '__main__':
    # Test Harness
    recorder = SessionRecorderMS({'logs_dir': '_test_logs'})
    recorder.on_scan_started({"paths": ["C:/test/project"]})
    recorder.on_hunk_detected({"file": "test.py", "hunk_name": "def test()", "before": "...", "after": ".."})
    print(f"Test entries written to: {recorder.log_file}")


--------------------------------------------------------------------------------
FILE: src\microservices\_SignalBusMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _SignalBusMS
ENTRY_POINT: _SignalBusMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import logging
import threading
from typing import Dict, List, Any, Optional, Callable
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='SignalBus', 
    version='1.0.0', 
    description='The Spine: A central pub/sub event hub for decoupled communication between services.', 
    tags=['utility', 'events', 'communication'], 
    capabilities=['pub-sub', 'event-routing'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=[]
)
class SignalBusMS(BaseService):
    """
    The Spine.
    Provides a thread-safe mechanism for services to subscribe to and emit named signals.
    """
    
    # --- Standard Event Contracts ---
    SIGNAL_PROCESS_START = "process_start"
    SIGNAL_PROCESS_COMPLETE = "process_complete"
    SIGNAL_SPAWN_REQUESTED = "cell_spawn_requested"
    SIGNAL_LOG_APPEND = "log_append"
    SIGNAL_ERROR = "notify_error"

    # --- Nexus / Ledger Signals ---
    SIGNAL_PUSH_DATA = "push_to_nexus"          # Data transfer between cells
    SIGNAL_REGISTER_CELL = "register_cell"      # Notify Shell of new cell presence
    SIGNAL_UPDATE_REGISTRY = "update_registry"  # Sync dropdowns with active cells

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('SignalBus')
        self.config = config or {}
        self._subscribers: Dict[str, List[Callable]] = {}
        self._lock = threading.RLock()

    @service_endpoint(
        inputs={'signal_name': 'str', 'callback': 'Callable'}, 
        outputs={}, 
        description='Registers a callback function to trigger when a specific signal is emitted.', 
        tags=['events', 'subscribe']
    )
    # ROLE: Registers a callback function to trigger when a specific signal is emitted.
    # INPUTS: {"callback": "Callable", "signal_name": "str"}
    # OUTPUTS: {}
    def subscribe(self, signal_name: str, callback: Callable):
        """Adds a listener for a specific signal."""
        with self._lock:
            if signal_name not in self._subscribers:
                self._subscribers[signal_name] = []
            if callback not in self._subscribers[signal_name]:
                self._subscribers[signal_name].append(callback)
                self.log_info(f"New subscriber for signal: {signal_name}")

    @service_endpoint(
        inputs={'signal_name': 'str', 'data': 'Any'}, 
        outputs={'delivered_to': 'int'}, 
        description='Broadcasts data to all subscribers of a specific signal.', 
        tags=['events', 'emit']
    )
    # ROLE: Broadcasts data to all subscribers of a specific signal.
    # INPUTS: {"data": "Any", "signal_name": "str"}
    # OUTPUTS: {"delivered_to": "int"}
    def emit(self, signal_name: str, data: Any = None) -> int:
        """Broadcasts a signal to all registered listeners."""
        count = 0
        with self._lock:
            listeners = self._subscribers.get(signal_name, []).copy()
        
        if listeners:
            self.log_info(f"Emitting signal: {signal_name}")
            for callback in listeners:
                try:
                    # Trigger the callback with the data payload
                    callback(data)
                    count += 1
                except Exception as e:
                    self.log_error(f"Error in signal '{signal_name}' callback: {e}")
        
        return count

    @service_endpoint(
        inputs={'signal_name': 'str', 'callback': 'Callable'}, 
        outputs={}, 
        description='Removes a previously registered callback.', 
        tags=['events', 'unsubscribe']
    )
    # ROLE: Removes a previously registered callback.
    # INPUTS: {"callback": "Callable", "signal_name": "str"}
    # OUTPUTS: {}
    def unsubscribe(self, signal_name: str, callback: Callable):
        """Removes a listener from a signal."""
        with self._lock:
            if signal_name in self._subscribers:
                try:
                    self._subscribers[signal_name].remove(callback)
                    self.log_info(f"Unsubscribed from signal: {signal_name}")
                except ValueError:
                    pass

if __name__ == '__main__':
    # Test Harness
    bus = SignalBusMS()
    
    def on_hunk_ready(data):
        print(f"UI received hunk: {data}")

    print("--- Testing SignalBusMS ---")
    bus.subscribe("hunk_processed", on_hunk_ready)
    
    # Simulate a backend event
    delivered = bus.emit("hunk_processed", {"file": "app.py", "lines": 50})
    print(f"Signal delivered to {delivered} listeners.")



--------------------------------------------------------------------------------
FILE: src\microservices\_TelemetryServiceMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TelemetryServiceMS
ROLE: Authoritative Session Journal (Task 3)
"""
import logging
import queue
import time
import datetime
from typing import Dict, Any, Optional, List
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

try:
    from .event_contract import summarize_event, normalize_error
except ImportError:
    # Fallback if contract file is missing
    def summarize_event(e, p): return f"Event: {e}"
    def normalize_error(e): return str(e)

logger = logging.getLogger('TelemetryService')

@service_metadata(
    name='TelemetryService', 
    version='2.0.0', 
    description='Authoritative Session Journal: Maintains a structured event buffer and state snapshot.', 
    tags=['utility', 'logging', 'telemetry'], 
    capabilities=['event-journaling', 'state-snapshotting']
)
class TelemetryServiceMS(BaseService):
    def __init__(self, state, config: Optional[Dict[str, Any]]=None):
        super().__init__('TelemetryService')
        self.state_authority = state # The AppRuntimeState object
        self.config = config or {}
        
        # 1. Authoritative Journal Storage
        self.event_buffer: List[Dict[str, Any]] = []
        self.buffer_limit = self.config.get('buffer_limit', 1000)
        
        # 2. Local State Snapshot (Enriched for UI consumption)
        self.snapshot = {
            "phase": "IDLE",
            "active_file": None,
            "waiting_for_review": False,
            "current_model": "unknown",
            "last_error": None,
            "counters": {"errors": 0, "commits": 0, "hunks": 0}
        }

    def track(self, event_name: str, payload: Any = None, source: str = "system"):
        """Records a structured event into the ring buffer."""
        try:
            timestamp = datetime.datetime.now().strftime("%H:%M:%S")

            # Normalize payload if it's an error
            safe_payload = payload
            if "error" in event_name:
                normalized = normalize_error(payload)
                safe_payload = normalized
                if isinstance(normalized, dict):
                    self.snapshot["last_error"] = normalized.get("message")
                else:
                    self.snapshot["last_error"] = str(normalized)

            if event_name == "model_swapped":
                self.snapshot["current_model"] = str(payload)

            entry = {
                "ts": timestamp,
                "event": event_name,
                "source": source,
                "payload": self._sanitize_payload(safe_payload),
                "summary": self._generate_summary(event_name, safe_payload),
            }

            self.event_buffer.append(entry)
            if len(self.event_buffer) > self.buffer_limit:
                # Keep only the most recent N entries
                self.event_buffer = self.event_buffer[-self.buffer_limit:]

        except Exception as e:
            # Fallback if logging fails to prevent recursion loops
            print(f"Telemetry Error: {e}")

        # Update local counters based on event type
        self._update_counters(event_name)

        # Emit signal that telemetry has updated (for future UI refresh)
        # Note: We use a try/except in case the bus isn't available during tests
        try:
            if hasattr(self, 'bus'):
                self.bus.emit("telemetry_updated", self.get_snapshot())
        except Exception:
            pass
    def _sanitize_payload(self, payload: Any) -> Any:
        """Ensures payload is safe for storage and serialization."""
        if isinstance(payload, (str, int, float, bool, type(None))):
            return payload
        if isinstance(payload, dict):
            return {k: str(v)[:100] for k, v in payload.items()} # Limit string size
        return str(payload)[:200]

    def _generate_summary(self, event: str, payload: Any) -> str:
        """Uses the central event contract to generate a summary."""
        try:
            return summarize_event(event, payload)
        except Exception as e:
            return f"Event: {event} (Summary Error: {e})"

    def _update_counters(self, event: str):
        if "error" in event: self.snapshot["counters"]["errors"] += 1
        if "commit_success" == event: self.snapshot["counters"]["commits"] += 1
        if "hunk_ready_for_review" == event: self.snapshot["counters"]["hunks"] += 1

    def get_snapshot(self) -> Dict[str, Any]:
        """Returns a combined view of the authority state and local counters."""
        return {
            "phase": self.state_authority.phase.name,
            "engine_blocked": self.state_authority.engine_blocked,
            "active_file": self.state_authority.pending_review.get('file') if self.state_authority.pending_review else None,
            "current_model": self.snapshot["current_model"],
            "last_error": self.snapshot["last_error"],
            "counters": self.snapshot["counters"]
        }

    def get_recent_events(self, limit: int = 50) -> List[Dict[str, Any]]:
        return self.event_buffer[-limit:]




--------------------------------------------------------------------------------
FILE: src\microservices\_TextChunkerMS.py
--------------------------------------------------------------------------------
import logging
from typing import Any, Dict, List, Optional, Tuple
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
logger = logging.getLogger('TextChunker')

@service_metadata(name='TextChunker', version='1.0.0', description='Splits text into chunks using various strategies (chars, lines).', tags=['chunking', 'nlp', 'rag'], capabilities=['compute'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TextChunkerMS(BaseService):
    """
    The Butcher: A unified service for splitting text into digestible chunks
    for RAG (Retrieval Augmented Generation).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('TextChunker')
        self.config = config or {}

    @service_endpoint(inputs={'text': 'str', 'chunk_size': 'int', 'chunk_overlap': 'int'}, outputs={'chunks': 'List[str]'}, description='Standard sliding window split by character count.', tags=['chunking', 'chars'], side_effects=[])
    # ROLE: Standard sliding window split by character count.
    # INPUTS: {"chunk_overlap": "int", "chunk_size": "int", "text": "str"}
    # OUTPUTS: {"chunks": "List[str]"}
    def chunk_by_chars(self, text: str, chunk_size: int=500, chunk_overlap: int=50) -> List[str]:
        """
        Standard Sliding Window. Best for prose/documentation.
        Splits purely by character count.
        """
        if chunk_size <= 0:
            raise ValueError('chunk_size must be positive')
        chunks = []
        start = 0
        text_length = len(text)
        while start < text_length:
            end = start + chunk_size
            chunk = text[start:end]
            chunks.append(chunk)
            if end >= text_length:
                break
            start += chunk_size - chunk_overlap
        return chunks

    @service_endpoint(inputs={'text': 'str', 'max_lines': 'int', 'max_chars': 'int'}, outputs={'chunks': 'List[Dict]'}, description='Line-preserving chunker, best for code.', tags=['chunking', 'lines', 'code'], side_effects=[])
    # ROLE: Line-preserving chunker, best for code.
    # INPUTS: {"max_chars": "int", "max_lines": "int", "text": "str"}
    # OUTPUTS: {"chunks": "List[Dict]"}
    def chunk_by_lines(self, text: str, max_lines: int=200, max_chars: int=4000) -> List[Dict[str, Any]]:
        """
        Line-Preserving Chunker. Best for Code.
        Respects line boundaries and returns metadata about line numbers.
        """
        lines = text.splitlines()
        chunks = []
        start = 0
        while start < len(lines):
            end = min(start + max_lines, len(lines))
            chunk_str = '\n'.join(lines[start:end])
            while len(chunk_str) > max_chars and end > start + 1:
                end -= 1
                chunk_str = '\n'.join(lines[start:end])
            chunks.append({'text': chunk_str, 'start_line': start + 1, 'end_line': end})
            start = end
        return chunks
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    chunker = TextChunkerMS()
    print('Service ready:', chunker)
    print('--- Prose Chunking ---')
    lorem = 'A' * 100
    result = chunker.chunk_by_chars(lorem, chunk_size=40, chunk_overlap=10)
    for i, c in enumerate(result):
        print(f'Chunk {i}: len={len(c)}')
    print('\n--- Code Chunking ---')
    code = '\n'.join([f"print('Line {i}')" for i in range(1, 10)])
    result_code = chunker.chunk_by_lines(code, max_lines=3, max_chars=100)
    for i, c in enumerate(result_code):
        print(f"Chunk {i}: Lines {c['start_line']}-{c['end_line']}")


--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterAppShellMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterAppShellMS
ENTRY_POINT: _TkinterAppShellMS.py
INTERNAL_DEPENDENCIES: _TkinterThemeManagerMS, microservice_std_lib, base_service
EXTERNAL_DEPENDENCIES: None

This module provides the root Tkinter application shell. It owns the
Tkinter root window, manages global theme propagation and hosts
embedded UI components.
"""

import tkinter as tk
from tkinter import ttk
import logging
from typing import Dict, Any, Optional

from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

# Attempt to import our theme manager.
try:
    from ._TkinterThemeManagerMS import TkinterThemeManagerMS  # type: ignore
except Exception as ex:
    TkinterThemeManagerMS = None
    logging.getLogger("AppShell").warning(
        "Theme manager could not be imported: %s. Falling back to defaults.", ex
    )

logger = logging.getLogger("AppShell")


@service_metadata(
    name="TkinterAppShell",
    version="2.1.1",
    description="The Mother Ship: Root UI container that manages the lifecycle of recursive Cell windows.",
    tags=["ui", "shell", "container"],
    capabilities=["ui:gui", "window-management"],
    internal_dependencies=["_TkinterThemeManagerMS", "microservice_std_lib", "base_service"],
)
class TkinterAppShellMS(BaseService):
    """
    The Mother Ship.
    Owns the Tk root window and provides a stable lifecycle contract for the app.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("TkinterAppShell")
        self.config = config or {}

        # 1) Root Window
        self.root = tk.Tk()
        self.root.title(self.config.get("title", "_theCELL - Idea Ingestor"))
        self.root.geometry(self.config.get("geometry", "1000x800"))

        # 2) Theme Management
        self.theme_manager = None
        self.colors = {
            "background": "#1e1e1e",
            "foreground": "#cccccc",
            "panel_bg": "#252526",
            "accent": "#007acc",
            # optional UI keys some screens may ask for:
            "entry_bg": "#1e1e1e",
            "entry_fg": "#cccccc",
            "select_bg": "#264f78",
            "button_fg": "#cccccc",
        }

        if TkinterThemeManagerMS:
            theme_pref = (self.config.get("theme") or "Dark").strip().title()
            self.theme_manager = TkinterThemeManagerMS({"theme": theme_pref})
            try:
                self.colors = self.theme_manager.get_theme()
            except Exception:
                # fallback to defaults if theme manager is partially implemented
                pass
            self.log_info(f"Theme Manager initialized with '{theme_pref}' theme.")

        self.root.configure(bg=self.colors.get("background"))

        # 3) Main Container (the docking zone)
        self.main_container = tk.Frame(self.root, bg=self.colors.get("background"))
        self.main_container.pack(fill="both", expand=True)

        # If any build withdraws to avoid a flash, we still safely deiconify in launch()
        # (no-op if not withdrawn).
        # self.root.withdraw()

    # -------------------------------------------------------------------------
    # LIFECYCLE (IMPORTANT: app.py expects shell.launch())
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={},
        outputs={},
        description="Starts the GUI main loop.",
        tags=["lifecycle", "start"],
        side_effects=["ui:block"],
    )
    # ROLE: Starts the GUI main loop.
    # INPUTS: {}
    # OUTPUTS: {}
    def launch(self) -> None:
        """Ignition sequence start."""
        try:
            self.root.deiconify()
        except Exception:
            pass

        try:
            self.log_info("AppShell Launched.")
        except Exception:
            logger.info("AppShell Launched.")

        self.root.mainloop()

    @service_endpoint(
        inputs={},
        outputs={},
        description="Gracefully shuts down the application.",
        tags=["lifecycle", "stop"],
        side_effects=["ui:close"],
    )
    # ROLE: Gracefully shuts down the application.
    # INPUTS: {}
    # OUTPUTS: {}
    def shutdown(self) -> None:
        """Closes the Tkinter event loop and destroys the root window."""
        self.log_info("Shutting down Application Shell.")
        try:
            # quit() exits mainloop; destroy() removes windows
            self.root.quit()
            self.root.destroy()
        except Exception:
            pass

    # -------------------------------------------------------------------------
    # THEME
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={"theme_name": "str"},
        outputs={"success": "bool"},
        description="Switches the global application theme (e.g., Dark, Light).",
        tags=["ui", "theme"],
        side_effects=["ui:refresh"],
    )
    # ROLE: Switches the global application theme (e.g., Dark, Light).
    # INPUTS: {"theme_name": "str"}
    # OUTPUTS: {"success": "bool"}
    def set_theme(self, theme_name: str) -> bool:
        """Updates the theme and propagates colors to the shell."""
        if not self.theme_manager:
            return False

        theme_name = (theme_name or "Dark").strip().title()
        success = False
        try:
            success = bool(self.theme_manager.set_theme(theme_name))
        except Exception:
            success = False

        if success:
            try:
                self.colors = self.theme_manager.get_theme()
            except Exception:
                pass
            self.root.configure(bg=self.colors.get("background"))
            self.main_container.configure(bg=self.colors.get("background"))
            self.log_info(f"Theme switched to {theme_name}")

        return success

    # -------------------------------------------------------------------------
    # LAYOUT + WINDOWS
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={},
        outputs={"container": "tk.Frame"},
        description="Returns the main content area for other services to dock into.",
        tags=["ui", "layout"],
    )
    # ROLE: Returns the main content area for other services to dock into.
    # INPUTS: {}
    # OUTPUTS: {"container": "tk.Frame"}
    def get_main_container(self) -> tk.Frame:
        """Other services call this to know where to pack() themselves."""
        return self.main_container

    @service_endpoint(
        inputs={"title": "str", "geometry": "str"},
        outputs={"window": "tk.Toplevel"},
        description="Spawns a new top-level window for a child cell.",
        tags=["ui", "lifecycle"],
    )
    # ROLE: Spawns a new top-level window for a child cell.
    # INPUTS: {"geometry": "str", "title": "str"}
    # OUTPUTS: {"window": "tk.Toplevel"}
    def spawn_window(self, title: str = "Child Cell", geometry: str = "1000x800") -> tk.Toplevel:
        """Creates a new Toplevel window that inherits the shell's theme."""
        new_window = tk.Toplevel(self.root)
        new_window.title(title)
        new_window.geometry(geometry)
        bg = self.colors.get("background", "#1e1e1e")
        new_window.configure(bg=bg)
        self.log_info(f"Spawned new window: {title}")
        return new_window


if __name__ == "__main__":
    # Test Harness
    logging.basicConfig(level=logging.INFO)
    shell = TkinterAppShellMS({"title": "Shell Test Window"})
    print(f"Shell Ready: {shell._service_info['id']}")
    shell.launch()

--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterSmartExplorerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterSmartExplorerMS
ENTRY_POINT: _TkinterSmartExplorerMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import tkinter as tk
from tkinter import ttk
from typing import Dict, Any, Optional, List
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(name='TkinterSmartExplorer', version='1.0.0', description='A hierarchical tree viewer capable of displaying file systems or JSON data structures.', tags=['ui', 'widget', 'explorer'], capabilities=['ui:gui'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TkinterSmartExplorerMS(tk.Frame, BaseService):
    """
    The Navigator.
    A TreeView widget that expects standard 'Node' dictionaries (name, type, children).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        self.config = config or {}
        parent = self.config.get('parent')
        
        # Multi-inheritance initialization
        BaseService.__init__(self, 'TkinterSmartExplorer')
        theme = self.config.get('theme', {})
        tk.Frame.__init__(self, parent, bg=theme.get('panel_bg', '#252526'))
        self.tree = ttk.Treeview(self, show='tree headings', selectmode='browse')
        self.tree.heading('#0', text='Explorer', anchor='w')
        vsb = ttk.Scrollbar(self, orient='vertical', command=self.tree.yview)
        hsb = ttk.Scrollbar(self, orient='horizontal', command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        self.tree.pack(side='left', fill='both', expand=True)
        vsb.pack(side='right', fill='y')
        self.icons = {'folder': '📁', 'file': '📄', 'web': '🌐', 'unknown': '❓'}

    @service_endpoint(inputs={'data': 'Dict'}, outputs={}, description="Populates the tree view with a nested dictionary structure (Standard 'Node' format).", tags=['ui', 'update'], side_effects=['ui:update'])
    # ROLE: Populates the tree view with a nested dictionary structure (Standard 'Node' format).
    # INPUTS: {"data": "Dict"}
    # OUTPUTS: {}
    def load_data(self, data: Dict[str, Any]):
        """
        Ingests a dictionary tree (like from _ScoutMS or _TreeMapperMS).
        """
        for item in self.tree.get_children():
            self.tree.delete(item)
        self._build_node('', data)

    def _build_node(self, parent_id, node_data):
        ntype = node_data.get('type', 'unknown')
        icon = self.icons.get(ntype, self.icons['unknown'])
        text = f"{icon} {node_data.get('name', '???')}"
        item_id = self.tree.insert(parent_id, 'end', text=text, open=True)
        for child in node_data.get('children', []):
            self._build_node(item_id, child)
if __name__ == '__main__':
    root = tk.Tk()
    explorer = TkinterSmartExplorerMS({'parent': root})
    explorer.pack(fill='both', expand=True)
    dummy_data = {'name': 'Project Root', 'type': 'folder', 'children': [{'name': 'src', 'type': 'folder', 'children': []}, {'name': 'README.md', 'type': 'file'}]}
    explorer.load_data(dummy_data)
    root.mainloop()


--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterThemeManagerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterThemeManagerMS
ENTRY_POINT: _TkinterThemeManagerMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None

This module defines and manages the colour palette used throughout the
application.  A `TkinterThemeManagerMS` class encapsulates two
predefined themes—`Dark` and `Light`—inspired by the Visual Studio
Code default themes.  Themes can be swapped at runtime and are
returned as mutable dictionaries so that UI components can reference
their values directly and respond to changes.

To add a new theme, extend the `THEMES` dictionary with the
appropriate keys.  See the definitions of `DARK_THEME` and
`LIGHT_THEME` for guidance on required keys.
"""

from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint


"""
Defines colour palettes for supported themes.

These palettes draw inspiration from the Visual Studio Code default
dark and light themes to provide a comfortable and familiar
development environment.  Colours are carefully chosen to avoid
high‑contrast combinations that can lead to eye strain while still
maintaining adequate contrast for accessibility.  Should additional
themes be added in the future, follow the same structure and include
keys for all UI elements consumed throughout the UI.
"""

# Visual Studio Code inspired dark theme.  The underlying palette
# uses neutral greys and blue accents similar to VS Code’s default
# dark theme.  Colours have been adjusted to be less harsh while
# maintaining sufficient contrast.
DARK_THEME: Dict[str, Any] = {
    'name': 'Dark',
    # Primary backgrounds and foregrounds
    'background': '#1e1e1e',        # main window background
    'foreground': '#d4d4d4',        # primary text colour
    'panel_bg': '#252526',          # toolbar, config panels
    'border': '#3c3c3c',            # borders and separators
    'accent': '#007acc',            # accent colour for buttons and highlights
    'error': '#f44747',             # error messages / destructive actions
    'success': '#89d185',           # success messages

    # Fonts (kept here for completeness but rarely overridden)
    'font_main': ('Segoe UI', 10),
    'font_mono': ('Consolas', 11),

    # Button styling
    'button_bg': '#0e639c',         # primary button background
    'button_fg': '#ffffff',         # primary button text colour

    # Input/entry styling
    'entry_bg': '#1e1e1e',          # entry and text box background
    'entry_fg': '#d4d4d4',          # entry text colour

    # Selection colours
    'select_bg': '#264f78',         # selection background (lists/text)
    'select_fg': '#ffffff',         # selection text colour

    # Table/heading styling
    'heading_bg': '#3c3c3c',        # table headings background
    'heading_fg': '#ffffff',        # table headings text colour
    'heading_font': ('Segoe UI', 12, 'bold'),
}

# Visual Studio Code inspired light theme.  The palette uses soft
# greys with a blue accent, mirroring VS Code’s light theme while
# avoiding stark white backgrounds.  Text colours are dark greys
# to maintain readability without excessive contrast.
LIGHT_THEME: Dict[str, Any] = {
    'name': 'Light',
    # Primary backgrounds and foregrounds
    'background': '#ffffff',        # main window background (pure white)
    'foreground': '#333333',        # primary text colour (dark grey)
    'panel_bg': '#f3f3f3',          # toolbar, config panels
    'border': '#dcdcdc',            # borders and separators
    'accent': '#0066b8',            # accent colour for buttons and highlights
    'error': '#d13438',             # error messages / destructive actions
    'success': '#107c10',           # success messages

    # Fonts
    'font_main': ('Segoe UI', 10),
    'font_mono': ('Consolas', 11),

    # Button styling
    'button_bg': '#e7e7e7',         # primary button background
    'button_fg': '#333333',         # primary button text colour

    # Input/entry styling
    'entry_bg': '#ffffff',          # entry and text box background
    'entry_fg': '#333333',          # entry text colour

    # Selection colours
    'select_bg': '#add6ff',         # selection background (lists/text)
    'select_fg': '#000000',         # selection text colour

    # Table/heading styling
    'heading_bg': '#e2e2e2',        # table headings background
    'heading_fg': '#333333',        # table headings text colour
    'heading_font': ('Segoe UI', 12, 'bold'),
}

# Registry of all supported themes.  Keys should be title‑cased to
# simplify lookups when user preferences are normalised by
# `TkinterThemeManagerMS.set_theme()`.
THEMES: Dict[str, Dict[str, Any]] = {
    'Dark': DARK_THEME,
    'Light': LIGHT_THEME,
}


@service_metadata(
    name='TkinterThemeManager',
    version='1.2.0',
    description='Centralised configuration for UI colours and fonts.',
    tags=['ui', 'config', 'theme'],
    capabilities=['ui:style'],
    internal_dependencies=['microservice_std_lib'],
    external_dependencies=[],
)
class TkinterThemeManagerMS:
    """
    The Stylist: Holds the colour palette and font settings.

    All UI components query this service to decide how to draw themselves.
    The palette is returned as a mutable dictionary so that callers can
    hold a reference and receive updates in place when switching themes.

    Configuration options:
      - ``theme``: one of the keys defined in ``THEMES`` (default ``'Dark'``)
      - ``overrides``: a dictionary of key/value pairs used to override
        default theme values.  Overrides persist across theme changes.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        self.config = config or {}

        # Determine the requested base theme, falling back to Dark if unknown.
        requested = self.config.get('theme', 'Dark')
        requested = (requested or 'Dark').strip().title()
        if requested not in THEMES:
            requested = 'Dark'

        # Active theme name and palette.  ``self.theme`` is mutable and
        # updated in place on theme changes to preserve object identity.
        self.theme_name: str = requested
        # copy() to ensure modifications on ``self.theme`` do not affect
        # the global template stored in ``THEMES``.
        self.theme: Dict[str, Any] = THEMES[self.theme_name].copy()

        # Persist any user overrides.  If overrides are supplied they
        # should override defaults on initialisation and on subsequent
        # theme changes.  A shallow copy is sufficient because values
        # should be primitives or tuples.
        self._overrides = dict(self.config.get('overrides', {}))
        if self._overrides:
            self.theme.update(self._overrides)

    @service_endpoint(
        inputs={},
        outputs={'theme': 'Dict'},
        description='Returns the current active theme dictionary.',
        tags=['ui', 'read'],
    )
    # ROLE: Returns the current active theme dictionary.
    # INPUTS: {}
    # OUTPUTS: {"theme": "Dict"}
    def get_theme(self) -> Dict[str, Any]:
        """Return the current theme palette."""
        return self.theme

    @service_endpoint(
        inputs={},
        outputs={'theme_name': 'str'},
        description='Returns the current active theme name.',
        tags=['ui', 'read'],
    )
    # ROLE: Returns the current active theme name.
    # INPUTS: {}
    # OUTPUTS: {"theme_name": "str"}
    def get_theme_name(self) -> str:
        """Return the name of the current theme (e.g. ``'Dark'``)."""
        return self.theme_name

    @service_endpoint(
        inputs={'theme_name': 'str'},
        outputs={'applied': 'bool'},
        description='Switches the active theme (Dark/Light).',
        tags=['ui', 'write'],
        side_effects=['ui:refresh'],
    )
    # ROLE: Switches the active theme (Dark/Light).
    # INPUTS: {"theme_name": "str"}
    # OUTPUTS: {"applied": "bool"}
    def set_theme(self, theme_name: str) -> bool:
        """
        Switch the current theme to ``theme_name``.

        Unknown theme names fall back to ``'Dark'``.  Overrides stored
        during initialisation are re‑applied after the base palette is
        swapped so that user customisations persist across theme changes.
        The method always returns ``True``.
        """
        name = (theme_name or 'Dark').strip().title()
        if name not in THEMES:
            name = 'Dark'
        self.theme_name = name

        # Build a fresh palette from the base and reapply overrides.  The
        # resulting palette is merged into the existing ``self.theme``
        # dictionary to preserve its identity for any UI components holding
        # references.  This ensures calls like ``refresh_theme()`` only need
        # to reconfigure widget properties rather than replace entire dicts.
        new_theme: Dict[str, Any] = THEMES[self.theme_name].copy()
        if self._overrides:
            new_theme.update(self._overrides)

        # Update the existing dict in place rather than reassigning.
        self.theme.clear()
        self.theme.update(new_theme)
        return True

    @service_endpoint(
        inputs={'key': 'str', 'value': 'Any'},
        outputs={},
        description='Updates a specific theme attribute (e.g., changing accent colour).',
        tags=['ui', 'write'],
        side_effects=['ui:refresh'],
    )
    # ROLE: Updates a specific theme attribute (e.g., changing accent colour).
    # INPUTS: {"key": "str", "value": "Any"}
    # OUTPUTS: {}
    def update_key(self, key: str, value: Any) -> None:
        """
        Update an individual key in the current theme.

        Overrides are persisted so that subsequent calls to
        ``set_theme()`` do not wipe out the change.  A missing key will
        simply be added to the palette.
        """
        # Update the current palette
        self.theme[key] = value
        # Persist override for future theme switches
        self._overrides[key] = value


if __name__ == '__main__':  # pragma: no cover
    # Simple manual test: print palette names and accents
    svc = TkinterThemeManagerMS({'theme': 'Dark'})
    print('Initial:', svc.get_theme_name(), svc.get_theme()['accent'])
    svc.set_theme('Light')
    print('After switch:', svc.get_theme_name(), svc.get_theme()['accent'])
--------------------------------------------------------------------------------
FILE: src\microservices\_TreeMapperMS.py
--------------------------------------------------------------------------------
import os
import datetime
import logging
from pathlib import Path
from typing import Any, Dict, List, Set, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
DEFAULT_EXCLUDES = {'.git', '__pycache__', '.idea', '.vscode', 'node_modules', '.venv', 'env', 'venv', 'dist', 'build', '.DS_Store'}
logger = logging.getLogger('TreeMapper')

@service_metadata(name='TreeMapper', version='1.0.0', description='Generates ASCII-art style directory maps of the file system.', tags=['filesystem', 'map', 'visualization'], capabilities=['filesystem:read'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TreeMapperMS(BaseService):
    """
    The Cartographer: Generates ASCII-art style directory maps.
    Useful for creating context snapshots for LLMs.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('TreeMapper')
        self.config = config or {}

    @service_endpoint(inputs={'root_path': 'str', 'additional_exclusions': 'Set[str]', 'use_default_exclusions': 'bool'}, outputs={'tree_map': 'str'}, description='Generates an ASCII tree map of the directory.', tags=['filesystem', 'visualization'], side_effects=['filesystem:read'])
    # ROLE: Generates an ASCII tree map of the directory.
    # INPUTS: {"additional_exclusions": "Set[str]", "root_path": "str", "use_default_exclusions": "bool"}
    # OUTPUTS: {"tree_map": "str"}
    def generate_tree(self, root_path: str, additional_exclusions: Optional[Set[str]]=None, use_default_exclusions: bool=True) -> str:
        start_path = Path(root_path).resolve()
        if not start_path.exists():
            return f"Error: Path '{root_path}' does not exist."
        exclusions = set()
        if use_default_exclusions:
            exclusions.update(DEFAULT_EXCLUDES)
        if additional_exclusions:
            exclusions.update(additional_exclusions)
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        lines = [f'Project Map: {start_path.name}', f'Generated: {timestamp}', '-' * 40, f'📁 {start_path.name}/']
        logger.info(f'Mapping directory: {start_path}')
        self._walk(start_path, '', lines, exclusions)
        return '\n'.join(lines)

    def _walk(self, directory: Path, prefix: str, lines: List[str], exclusions: Set[str]):
        try:
            children = sorted([p for p in directory.iterdir() if p.name not in exclusions], key=lambda x: (not x.is_dir(), x.name.lower()))
        except PermissionError:
            lines.append(f'{prefix}└── 🚫 [Permission Denied]')
            return
        count = len(children)
        for index, path in enumerate(children):
            is_last = index == count - 1
            connector = '└── ' if is_last else '├── '
            if path.is_dir():
                lines.append(f'{prefix}{connector}📁 {path.name}/')
                extension = '    ' if is_last else '│   '
                self._walk(path, prefix + extension, lines, exclusions)
            else:
                lines.append(f'{prefix}{connector}📄 {path.name}')
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    svc = TreeMapperMS()
    print('Service ready:', svc)
    print('\n--- Map of Current Dir ---')
    tree = svc.generate_tree('.', additional_exclusions={'__pycache__'})
    print(tree)


--------------------------------------------------------------------------------
FILE: src\microservices\_VectorFactoryMS.py
--------------------------------------------------------------------------------
import importlib.util
import sys
import os
import uuid
import logging
import shutil
from typing import List, Dict, Any, Optional, Protocol, Union
from pathlib import Path

# Dependency Check
REQUIRED = ['chromadb', 'faiss-cpu', 'numpy']
MISSING = []
for lib in REQUIRED:
    clean_lib = lib.split('>=')[0].replace('-', '_')
    if clean_lib == 'faiss_cpu':
        clean_lib = 'faiss'
    if importlib.util.find_spec(clean_lib) is None:
        MISSING.append(lib)

if MISSING:
    print('\n' + '!' * 60)
    print(f'MISSING DEPENDENCIES for _VectorFactoryMS:')
    print(f"Run:  pip install {' '.join(MISSING)}")
    print('!' * 60 + '\\n')

from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

logger = logging.getLogger('VectorFactory')

class VectorStore(Protocol):
    """The contract that all vector backends must fulfill."""
    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]) -> None: ...
    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]: ...
    def count(self) -> int: ...
    def clear(self) -> None: ...

class FaissStore(VectorStore):
    """Local-first vector store using FAISS and flat-file metadata."""
    def __init__(self, path: str, dim: int):
        import faiss
        import numpy as np
        self.path = Path(path)
        self.meta_path = self.path.with_suffix(self.path.suffix + '.meta.json')
        self.dim = dim
        self.index = faiss.IndexFlatL2(dim)
        self.metadata = []
        self._load()

    def _load(self):
        import faiss
        if self.path.exists():
            self.index = faiss.read_index(str(self.path))
            if self.meta_path.exists():
                with open(self.meta_path, 'r') as f:
                    self.metadata = json.load(f)

    def _save(self):
        import faiss
        faiss.write_index(self.index, str(self.path))
        with open(self.meta_path, 'w') as f:
            json.dump(self.metadata, f)

    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]):
        import numpy as np
        vecs = np.array(embeddings).astype('float32')
        self.index.add(vecs)
        self.metadata.extend(metadatas)
        self._save()

    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]:
        import numpy as np
        vec = np.array([query_vector]).astype('float32')
        distances, indices = self.index.search(vec, k)
        results = []
        for idx in indices[0]:
            if idx != -1 and idx < len(self.metadata):
                results.append(self.metadata[idx])
        return results

    def count(self) -> int:
        return self.index.ntotal

    def clear(self) -> None:
        import faiss
        self.index = faiss.IndexFlatL2(self.dim)
        self.metadata = []
        if self.path.exists(): os.remove(self.path)
        if self.meta_path.exists(): os.remove(self.meta_path)

class ChromaStore(VectorStore):
    """Persistent vector store using ChromaDB."""
    def __init__(self, path: str, collection_name: str):
        import chromadb
        self.client = chromadb.PersistentClient(path=path)
        self.collection = self.client.get_or_create_collection(name=collection_name)

    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]):
        ids = [str(uuid.uuid4()) for _ in range(len(embeddings))]
        self.collection.add(embeddings=embeddings, metadatas=metadatas, ids=ids)

    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]:
        results = self.collection.query(query_embeddings=[query_vector], n_results=k)
        return results.get('metadatas', [[]])[0]

    def count(self) -> int:
        return self.collection.count()

    def clear(self) -> None:
        self.client.delete_collection(self.collection.name)

@service_metadata(
    name='VectorFactory',
    version='1.0.0',
    description='The Switchboard: Factory for creating and managing vector stores.',
    tags=['ai', 'vector', 'storage', 'factory'],
    capabilities=['db:vector'],
    internal_dependencies=['base_service', 'microservice_std_lib'],
    external_dependencies=['chromadb', 'faiss-cpu', 'numpy']
)
class VectorFactoryMS(BaseService):
    """
    The Switchboard: Standardized factory for vector store generation.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('VectorFactory')
        self.config = config or {}

    @service_endpoint(
        inputs={'backend': 'str', 'params': 'Dict'},
        outputs={'store': 'VectorStore'},
        description='Creates a vector store instance (faiss or chroma).',
        tags=['factory', 'create']
    )
    # ROLE: Creates a vector store instance (faiss or chroma).
    # INPUTS: {"backend": "str", "params": "Dict"}
    # OUTPUTS: {"store": "VectorStore"}
    def create(self, backend: str, params: Dict[str, Any]) -> VectorStore:
        """
        Instantiates a vector store backend.
        """
        backend = backend.lower()
        if backend == 'faiss':
            return FaissStore(params.get('path', 'vector.index'), params.get('dim', 384))
        elif backend == 'chroma':
            return ChromaStore(params.get('path', './chroma_db'), params.get('collection', 'default'))
        else:
            raise ValueError(f"Unsupported vector backend: {backend}")

if __name__ == '__main__':
    import json
    # Basic Test Harness
    logging.basicConfig(level=logging.INFO)
    factory = VectorFactoryMS()
    print(f"Service Ready: {factory}")
--------------------------------------------------------------------------------
FILE: src\microservices\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\_MicroServiceTOOLS\_MicroserviceDecoratorMSTOOL.py
--------------------------------------------------------------------------------
import ast
import json
import os
import queue
import threading
import time
from dataclasses import dataclass
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# ----------------------------
# Data model
# ----------------------------

@dataclass
class PlannedEdit:
    file_path: Path
    func_name: str
    insert_at_line_0based: int  # where we insert header (0-based index into lines)
    old_header_span: tuple | None  # (start_line_0based, end_line_0based_exclusive) if replacing
    new_header_lines: list[str]

# ----------------------------
# Logging (thread-safe UI)
# ----------------------------

class TkLog:
    def __init__(self, text_widget: tk.Text):
        self.text = text_widget
        self.q = queue.Queue()
        self._closed = False

    def write(self, msg: str):
        if self._closed:
            return
        ts = time.strftime("%H:%M:%S")
        self.q.put(f"[{ts}] {msg}\n")

    def pump(self):
        """Call periodically from Tk main thread."""
        try:
            while True:
                line = self.q.get_nowait()
                self.text.configure(state="normal")
                self.text.insert("end", line)
                self.text.see("end")
                self.text.configure(state="disabled")
        except queue.Empty:
            return

    def close(self):
        self._closed = True

# ----------------------------
# AST helpers
# ----------------------------

def _is_service_endpoint_decorator(dec: ast.expr) -> bool:
    """
    Matches:
      @service_endpoint(...)
      @microservice_std_lib.service_endpoint(...)
      @something.service_endpoint(...)
    """
    if isinstance(dec, ast.Call):
        f = dec.func
        if isinstance(f, ast.Name) and f.id == "service_endpoint":
            return True
        if isinstance(f, ast.Attribute) and f.attr == "service_endpoint":
            return True
    return False

def _literal_eval_safe(node: ast.AST):
    try:
        return ast.literal_eval(node)
    except Exception:
        return None

def _extract_endpoint_kwargs(dec_call: ast.Call) -> dict:
    """
    Extracts literal keyword args from @service_endpoint(inputs=..., outputs=..., description=...).
    In your library, these become wrapper._endpoint_info fields (inputs/outputs/description/etc.). 
    :contentReference[oaicite:4]{index=4}
    """
    out = {}
    for kw in dec_call.keywords or []:
        if kw.arg is None:
            # **kwargs unpack; ignore safely
            continue
        out[kw.arg] = _literal_eval_safe(kw.value)
    return out

# ----------------------------
# Text edit helpers (comment insertion/replacement)
# ----------------------------

ROLE_PREFIX = "# ROLE:"
INPUTS_PREFIX = "# INPUTS:"
OUTPUTS_PREFIX = "# OUTPUTS:"

def _format_inline(obj) -> str:
    """
    Formats dict-ish inputs/outputs compactly.
    """
    if obj is None:
        return "{}"
    if isinstance(obj, dict):
        # stable order for diffs
        return json.dumps(obj, sort_keys=True)
    return str(obj)

def _build_header(description: str | None, inputs_obj, outputs_obj, indent: str) -> list[str]:
    role = (description or "").strip() or "N/A"
    return [
        f"{indent}{ROLE_PREFIX} {role}\n",
        f"{indent}{INPUTS_PREFIX} {_format_inline(inputs_obj)}\n",
        f"{indent}{OUTPUTS_PREFIX} {_format_inline(outputs_obj)}\n",
    ]

def _leading_ws(line: str) -> str:
    i = 0
    while i < len(line) and line[i] in (" ", "\t"):
        i += 1
    return line[:i]

def _find_existing_header_block(lines: list[str], def_line_0: int) -> tuple | None:
    """
    If the lines immediately above the def contain ROLE/INPUTS/OUTPUTS comment block,
    return (start, end_exclusive) to replace it.

    We scan up to 6 lines above the def to be forgiving about blank lines.
    """
    start_scan = max(0, def_line_0 - 6)
    window = lines[start_scan:def_line_0]

    # Work from bottom upward to find a contiguous block that includes ROLE/INPUTS/OUTPUTS
    indices = []
    for i, line in enumerate(window):
        s = line.lstrip()
        if s.startswith((ROLE_PREFIX, INPUTS_PREFIX, OUTPUTS_PREFIX)):
            indices.append(start_scan + i)

    if not indices:
        return None

    # If these markers are not close to def, skip replacement
    if max(indices) < def_line_0 - 6:
        return None

    # Expand to contiguous-ish block: include blank lines between marker lines
    block_start = min(indices)
    block_end = max(indices) + 1

    # Pull block_end upward if there are trailing blank lines just before def
    while block_end < def_line_0 and lines[block_end].strip() == "":
        block_end += 1

    # Also include any blank lines directly above the first marker (optional)
    while block_start > 0 and lines[block_start - 1].strip() == "":
        block_start -= 1

    return (block_start, def_line_0)

def plan_edits_for_file(path: Path, log: TkLog) -> list[PlannedEdit]:
    raw = path.read_text(encoding="utf-8", errors="replace")
    # Normalize line endings only in memory; we preserve original by re-joining with existing \n in lines.
    lines = raw.splitlines(keepends=True)

    try:
        tree = ast.parse(raw)
    except SyntaxError as e:
        log.write(f"SKIP (syntax error): {path.name} :: {e}")
        return []

    edits: list[PlannedEdit] = []

    for node in ast.walk(tree):
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            continue
        if not node.decorator_list:
            continue

        dec_call = None
        for dec in node.decorator_list:
            if _is_service_endpoint_decorator(dec):
                dec_call = dec  # type: ignore[assignment]
                break
        if dec_call is None or not isinstance(dec_call, ast.Call):
            continue

        kwargs = _extract_endpoint_kwargs(dec_call)
        inputs_obj = kwargs.get("inputs")
        outputs_obj = kwargs.get("outputs")
        desc = kwargs.get("description")

        def_line_0 = (node.lineno - 1) if getattr(node, "lineno", None) else None
        if def_line_0 is None or def_line_0 < 0 or def_line_0 >= len(lines):
            continue

        indent = _leading_ws(lines[def_line_0])

        new_header = _build_header(desc, inputs_obj, outputs_obj, indent)

        existing = _find_existing_header_block(lines, def_line_0)
        if existing:
            insert_at = existing[0]
            span = existing
            log.write(f"PLAN replace header: {path.name} :: {node.name} @ line {def_line_0+1}")
        else:
            insert_at = def_line_0
            span = None
            log.write(f"PLAN insert header:  {path.name} :: {node.name} @ line {def_line_0+1}")

        edits.append(
            PlannedEdit(
                file_path=path,
                func_name=node.name,
                insert_at_line_0based=insert_at,
                old_header_span=span,
                new_header_lines=new_header,
            )
        )

    return edits

def apply_edits_to_text(raw: str, edits: list[PlannedEdit]) -> str:
    lines = raw.splitlines(keepends=True)

    # Apply from bottom to top to keep line indices stable.
    # For each file, edits must be sorted descending by insertion position.
    edits_sorted = sorted(edits, key=lambda e: e.insert_at_line_0based, reverse=True)

    for e in edits_sorted:
        if e.old_header_span:
            start, end = e.old_header_span
            # Replace that region with new header (and ensure exactly one blank line after header? no)
            lines[start:end] = e.new_header_lines
        else:
            lines[e.insert_at_line_0based:e.insert_at_line_0based] = e.new_header_lines

    return "".join(lines)

# ----------------------------
# Tkinter App
# ----------------------------

class MarkupApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Microservice Endpoint Markup Tool")
        self.geometry("920x620")

        self.log_text = tk.Text(self, height=24, wrap="word", state="disabled")
        self.log_text.pack(fill="both", expand=True, padx=10, pady=(10, 6))

        self.log = TkLog(self.log_text)

        bar = ttk.Frame(self)
        bar.pack(fill="x", padx=10, pady=(0, 10))

        self.dir_var = tk.StringVar(value=str(Path.cwd()))
        ttk.Label(bar, text="microservices dir:").grid(row=0, column=0, sticky="w")
        ttk.Entry(bar, textvariable=self.dir_var).grid(row=0, column=1, sticky="ew", padx=6)
        ttk.Button(bar, text="Browse...", command=self.browse_dir).grid(row=0, column=2, padx=(0, 6))

        self.scan_btn = ttk.Button(bar, text="Scan", command=self.start_scan)
        self.scan_btn.grid(row=0, column=3, padx=(0, 6))

        self.save_btn = ttk.Button(bar, text="Save Changes", command=self.save_changes, state="disabled")
        self.save_btn.grid(row=0, column=4, padx=(0, 6))

        self.cancel_btn = ttk.Button(bar, text="Cancel", command=self.cancel_run, state="disabled")
        self.cancel_btn.grid(row=0, column=5)

        bar.columnconfigure(1, weight=1)

        self._worker: threading.Thread | None = None
        self._cancel_flag = threading.Event()

        self._planned_by_file: dict[Path, list[PlannedEdit]] = {}
        self._touched_files: set[Path] = set()

        # UI log pump
        self.after(50, self._tick)

    def _tick(self):
        self.log.pump()
        self.after(50, self._tick)

    def browse_dir(self):
        d = filedialog.askdirectory(title="Select src/microservices folder")
        if d:
            self.dir_var.set(d)

    def start_scan(self):
        micro_dir = Path(self.dir_var.get()).expanduser().resolve()
        if not micro_dir.exists() or not micro_dir.is_dir():
            messagebox.showerror("Invalid folder", "Please select a valid microservices directory.")
            return

        self._planned_by_file.clear()
        self._touched_files.clear()
        self._cancel_flag.clear()

        self.save_btn.configure(state="disabled")
        self.cancel_btn.configure(state="normal")
        self.scan_btn.configure(state="disabled")

        self.log.write(f"Scan start: {micro_dir}")
        self._worker = threading.Thread(target=self._scan_worker, args=(micro_dir,), daemon=True)
        self._worker.start()

    def cancel_run(self):
        self.log.write("Cancel requested...")
        self._cancel_flag.set()

    def _scan_worker(self, micro_dir: Path):
        # Ignore library files
        ignore = {"__init__.py", "base_service.py", "microservice_std_lib.py", "fix.py", "document_utils.py"}
        py_files = sorted([p for p in micro_dir.glob("*.py") if p.name not in ignore])

        total_edits = 0

        for p in py_files:
            if self._cancel_flag.is_set():
                self.log.write("Scan cancelled.")
                break

            self.log.write(f"Parse AST: {p.name}")
            try:
                edits = plan_edits_for_file(p, self.log)
            except Exception as e:
                self.log.write(f"ERROR planning {p.name}: {e}")
                continue

            if edits:
                self._planned_by_file[p] = edits
                total_edits += len(edits)
                self.log.write(f"Planned {len(edits)} edit(s) in {p.name}")
            else:
                self.log.write(f"No endpoints found in {p.name}")

        if not self._cancel_flag.is_set():
            self.log.write(f"Scan complete. Files with changes: {len(self._planned_by_file)} | Total planned edits: {total_edits}")

        # Enable Save if we have edits and not cancelled
        def _enable():
            self.scan_btn.configure(state="normal")
            self.cancel_btn.configure(state="disabled")
            if self._planned_by_file and not self._cancel_flag.is_set():
                self.save_btn.configure(state="normal")
            else:
                self.save_btn.configure(state="disabled")

        self.after(0, _enable)

    def save_changes(self):
        if not self._planned_by_file:
            messagebox.showinfo("Nothing to do", "No planned edits.")
            return

        if not messagebox.askyesno("Confirm", f"Apply changes to {len(self._planned_by_file)} file(s)? Backups (.bak) will be created."):
            return

        self.save_btn.configure(state="disabled")
        self.cancel_btn.configure(state="normal")
        self.scan_btn.configure(state="disabled")
        self._cancel_flag.clear()

        self._worker = threading.Thread(target=self._save_worker, daemon=True)
        self._worker.start()

    def _save_worker(self):
        for path, edits in sorted(self._planned_by_file.items(), key=lambda kv: kv[0].name):
            if self._cancel_flag.is_set():
                self.log.write("Save cancelled.")
                break

            try:
                raw = path.read_text(encoding="utf-8", errors="replace")
                new_text = apply_edits_to_text(raw, edits)

                if new_text == raw:
                    self.log.write(f"SKIP unchanged: {path.name}")
                    continue

                bak = path.with_suffix(path.suffix + ".bak")
                if not bak.exists():
                    bak.write_text(raw, encoding="utf-8")
                    self.log.write(f"Backup created: {bak.name}")

                path.write_text(new_text, encoding="utf-8")
                self._touched_files.add(path)
                self.log.write(f"UPDATED: {path.name} ({len(edits)} endpoint header(s))")
            except Exception as e:
                self.log.write(f"ERROR writing {path.name}: {e}")

        def _done():
            self.scan_btn.configure(state="normal")
            self.cancel_btn.configure(state="disabled")
            # keep planned edits, but disable save if none actually written
            if self._touched_files:
                messagebox.showinfo("Done", f"Updated {len(self._touched_files)} file(s). Backups saved as *.bak.")
            else:
                messagebox.showinfo("Done", "No files were modified.")

        self.after(0, _done)

if __name__ == "__main__":
    # This tool is designed around your decorator contract:
    # @service_endpoint(inputs=..., outputs=..., description=..., tags=..., side_effects=..., mode=...)
    # :contentReference[oaicite:5]{index=5}
    app = MarkupApp()
    app.mainloop()

--------------------------------------------------------------------------------
FILE: src\microservices\_MicroServiceTOOLS\_TkinterUiMAPPER.py
--------------------------------------------------------------------------------
"""tk_ui_mapper.py

Tkinter UI Mapper (AST-first, optional Ollama inference, human-in-the-loop decisions)

What it does (MVP):
- Choose a project folder
- Crawl .py files (excluding common junk)
- Find entrypoint candidates ("if __name__ == '__main__':" blocks)
- If multiple entrypoints are found, ask the user to pick one (HITL)
- Parse all project python files with AST to:
  - discover widget creation calls (tk/ttk constructors)
  - discover layout calls (.pack/.grid/.place)
  - discover wiring (command=, .bind, menu add_command)
  - discover handlers (function/method defs) and link when resolvable
- Collect UNKNOWN cases (dynamic parents, loops, getattr handlers, etc.)
- Optional: use Ollama model (default qwen2.5-coder:0.5b) to infer UNKNOWN cases
  - Still HITL: user can approve/skip inference results when ambiguity is high
- Export monolithic report as Markdown + JSON

No external deps: uses stdlib only.

Notes:
- AST does NOT preserve comments; this tool maps structure for reporting.
- Import resolution is deliberately lightweight. The report marks PROVEN vs INFERRED.

Author: Prototype for Raithe's _UsefulHelperSCRIPTS ecosystem
"""

from __future__ import annotations

import ast
import json
import os
import queue
import threading
import time
import traceback
import urllib.request
import urllib.error
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from tkinter.scrolledtext import ScrolledText


# -----------------------------
# Config
# -----------------------------

DEFAULT_MODEL = "qwen2.5-coder:0.5b"
DEFAULT_OLLAMA_URL = "http://localhost:11434"

EXCLUDE_DIRS = {
    ".git", "__pycache__", ".venv", "venv", "env", ".mypy_cache", ".pytest_cache",
    "dist", "build", ".idea", ".vscode", "node_modules",
}

# ---- .gitignore support (stdlib-only, best-effort) ----
# We intentionally keep this lightweight (no pathspec dep).
# Supported patterns:
#   - blank lines / comments (# ...)
#   - directory patterns: .venv/  build/  dist/
#   - file globs: *.log  *.pyc
#   - simple basename entries: .env  thumbs.db
# Unsupported (will be ignored safely): negation (!pattern) and complex gitignore rules.

def _load_gitignore_patterns(project_root: Path) -> list[str]:
    gi = project_root / ".gitignore"
    if not gi.exists():
        return []
    try:
        raw = gi.read_text(encoding="utf-8", errors="replace")
    except Exception:
        return []

    patterns: list[str] = []
    for line in raw.splitlines():
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        # We intentionally do not implement negation in this MVP
        if s.startswith("!"):
            continue
        patterns.append(s)
    return patterns


def _is_ignored_by_gitignore(rel_posix: str, patterns: list[str]) -> bool:
    """Best-effort matcher for a subset of .gitignore patterns."""
    if not patterns:
        return False

    # normalize
    rel_posix = rel_posix.lstrip("/")
    base = rel_posix.split("/")[-1]

    for pat in patterns:
        p = pat.strip()
        if not p or p.startswith("#") or p.startswith("!"):
            continue

        # directory pattern
        if p.endswith("/"):
            dp = p.rstrip("/").lstrip("/")
            # match any segment == dp
            if f"/{dp}/" in f"/{rel_posix}/" or rel_posix.startswith(dp + "/"):
                return True
            continue

        # anchored path
        if "/" in p:
            ap = p.lstrip("/")
            # prefix match (treat like path glob without wildcards)
            if rel_posix == ap or rel_posix.startswith(ap.rstrip("/") + "/"):
                return True

        # glob (basename)
        if "*" in p or "?" in p:
            import fnmatch
            if fnmatch.fnmatch(base, p):
                return True
            continue

        # simple basename
        if base == p:
            return True

    return False

WIDGET_METHODS_LAYOUT = {"pack", "grid", "place"}
WIRING_METHODS = {"bind", "bind_all", "trace_add", "add_command", "add_checkbutton", "add_radiobutton"}


# -----------------------------
# Logging to Tk (queue-driven)
# -----------------------------

class TkLogger:
    def __init__(self, text: tk.Text):
        self.text = text
        self.q: "queue.Queue[str]" = queue.Queue()
        self.closed = False

    def log(self, msg: str):
        if self.closed:
            return
        ts = time.strftime("%H:%M:%S")
        self.q.put(f"[{ts}] {msg}\n")

    def pump(self):
        if self.closed:
            return
        try:
            while True:
                line = self.q.get_nowait()
                self.text.configure(state="normal")
                self.text.insert("end", line)
                self.text.see("end")
                self.text.configure(state="disabled")
        except queue.Empty:
            return

    def close(self):
        self.closed = True


# -----------------------------
# Data model
# -----------------------------

@dataclass
class EntrypointCandidate:
    file: str
    line: int
    summary: str


@dataclass
class WidgetNode:
    id: str
    file: str
    line: int
    name: str                    # variable or attribute name
    widget_type: str             # e.g., ttk.Button
    parent_expr: str             # textual expression
    kwargs: dict
    confidence: float            # 0..1 (AST confidence)


@dataclass
class LayoutCall:
    file: str
    line: int
    target: str                  # widget expression
    manager: str                 # pack/grid/place
    kwargs: dict


@dataclass
class WiringEdge:
    file: str
    line: int
    source: str                  # widget expression
    kind: str                    # command/bind/menu/trace
    event: Optional[str]         # e.g., "<Button-1>" for bind
    handler: str                 # handler expression
    confidence: float


@dataclass
class HandlerDef:
    file: str
    line: int
    qualname: str                # e.g., Class.method or function


@dataclass
class UnknownCase:
    case_type: str
    file: str
    line: int
    snippet: str
    question: str
    context: str


@dataclass
class InferenceResult:
    case: UnknownCase
    best_guess: str
    confidence: float
    evidence: list[str]
    explanation: str


@dataclass
class UiMap:
    project_root: str
    entrypoint: Optional[EntrypointCandidate]
    widgets: list[WidgetNode]
    layouts: list[LayoutCall]
    wiring: list[WiringEdge]
    handlers: list[HandlerDef]
    unknowns: list[UnknownCase]
    inferred: list[InferenceResult]


# -----------------------------
# Small AST utilities
# -----------------------------

class SourceLines:
    def __init__(self, text: str):
        self.text = text
        self.lines = text.splitlines()

    def snippet_around(self, line_1based: int, radius: int = 6) -> str:
        i = max(0, line_1based - 1 - radius)
        j = min(len(self.lines), line_1based - 1 + radius + 1)
        out = []
        for idx in range(i, j):
            out.append(f"{idx+1:>5}: {self.lines[idx]}")
        return "\n".join(out)

    def context_block(self, start_line_1based: int, end_line_1based: int) -> str:
        i = max(0, start_line_1based - 1)
        j = min(len(self.lines), end_line_1based)
        out = []
        for idx in range(i, j):
            out.append(f"{idx+1:>5}: {self.lines[idx]}")
        return "\n".join(out)


def is_main_guard_test(node: ast.AST) -> bool:
    # if __name__ == "__main__":
    if not isinstance(node, ast.Compare):
        return False
    if not isinstance(node.left, ast.Name) or node.left.id != "__name__":
        return False
    if len(node.ops) != 1 or not isinstance(node.ops[0], ast.Eq):
        return False
    if len(node.comparators) != 1:
        return False
    comp = node.comparators[0]
    return isinstance(comp, ast.Constant) and comp.value == "__main__"


def expr_to_str(node: ast.AST) -> str:
    # best-effort rendering
    try:
        return ast.unparse(node)  # py3.9+
    except Exception:
        return node.__class__.__name__


def literal_kwargs(call: ast.Call) -> dict:
    out: dict[str, Any] = {}
    for kw in call.keywords or []:
        if kw.arg is None:
            out["**kwargs"] = expr_to_str(kw.value)
            continue
        try:
            out[kw.arg] = ast.literal_eval(kw.value)
        except Exception:
            out[kw.arg] = expr_to_str(kw.value)
    return out


def looks_like_tk_constructor(func_expr: ast.AST) -> Optional[str]:
    """Return qualified name string if func looks like tk/ttk constructor, else None."""
    # Matches: tk.Button, ttk.Frame, tkinter.Tk, tkinter.ttk.Button, etc.
    if isinstance(func_expr, ast.Attribute):
        base = expr_to_str(func_expr.value)
        attr = func_expr.attr
        # simple heuristics
        if base in {"tk", "ttk", "tkinter", "tkinter.ttk"}:
            return f"{base}.{attr}"
        # some code uses aliased imports; we can't know. return None.
    return None


# -----------------------------
# Project crawling + entrypoints
# -----------------------------

def iter_py_files(project_root: Path) -> list[Path]:
    files: list[Path] = []

    # Load .gitignore patterns once (best-effort subset)
    gitignore_patterns = _load_gitignore_patterns(project_root)

    for root, dirs, filenames in os.walk(project_root):
        root_p = Path(root)
        rel_root = root_p.relative_to(project_root).as_posix() if root_p != project_root else ""

        # prune dirs by hard excludes + .gitignore
        kept_dirs: list[str] = []
        for d in dirs:
            if d in EXCLUDE_DIRS:
                continue

            rel_dir = f"{rel_root}/{d}" if rel_root else d

            # extra safety: never crawl common venv dirs even if gitignore missing
            if d.lower() in {".venv", "venv", "env"}:
                continue

            if _is_ignored_by_gitignore(rel_dir + "/", gitignore_patterns):
                continue

            kept_dirs.append(d)

        dirs[:] = kept_dirs

        for fn in filenames:
            if not fn.endswith(".py"):
                continue

            rel_file = f"{rel_root}/{fn}" if rel_root else fn
            if _is_ignored_by_gitignore(rel_file, gitignore_patterns):
                continue

            files.append(root_p / fn)

    return sorted(files)


def find_entrypoints(py_files: list[Path], log: TkLogger, cancel: threading.Event) -> list[EntrypointCandidate]:
    cands: list[EntrypointCandidate] = []
    for p in py_files:
        if cancel.is_set():
            return cands
        try:
            text = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(text)
        except Exception:
            continue

        for node in ast.walk(tree):
            if cancel.is_set():
                return cands
            if isinstance(node, ast.If) and is_main_guard_test(node.test):
                # summarize first non-empty line in the body
                body_summary = ""
                for b in node.body:
                    if isinstance(b, ast.Expr) and isinstance(b.value, ast.Constant) and isinstance(b.value.value, str):
                        continue
                    body_summary = expr_to_str(b)
                    break
                line = getattr(node, "lineno", 1)
                cands.append(EntrypointCandidate(file=str(p), line=int(line), summary=body_summary))
    log.log(f"Entrypoint candidates found: {len(cands)}")
    return cands


# -----------------------------
# AST Mapper
# -----------------------------

class TkUiAstMapper(ast.NodeVisitor):
    def __init__(self, file_path: Path, source: str, log: TkLogger):
        self.file_path = file_path
        self.src = source
        self.lines = SourceLines(source)
        self.log = log

        self.widgets: list[WidgetNode] = []
        self.layouts: list[LayoutCall] = []
        self.wiring: list[WiringEdge] = []
        self.handlers: list[HandlerDef] = []
        self.unknowns: list[UnknownCase] = []

        # scope tracking
        self._class_stack: list[str] = []

        # symbol tables: map var/attr name -> widget type
        self._widget_symbols: dict[str, str] = {}

    def current_qualprefix(self) -> str:
        return ".".join(self._class_stack) if self._class_stack else ""

    def visit_ClassDef(self, node: ast.ClassDef):
        self._class_stack.append(node.name)
        self.generic_visit(node)
        self._class_stack.pop()

    def visit_FunctionDef(self, node: ast.FunctionDef):
        q = self.current_qualprefix()
        qual = f"{q}.{node.name}" if q else node.name
        self.handlers.append(HandlerDef(file=str(self.file_path), line=getattr(node, "lineno", 1), qualname=qual))
        self.generic_visit(node)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        q = self.current_qualprefix()
        qual = f"{q}.{node.name}" if q else node.name
        self.handlers.append(HandlerDef(file=str(self.file_path), line=getattr(node, "lineno", 1), qualname=qual))
        self.generic_visit(node)

    def visit_Assign(self, node: ast.Assign):
        # widget creation if RHS is call to tk/ttk constructor
        if isinstance(node.value, ast.Call):
            ctor = looks_like_tk_constructor(node.value.func)
            if ctor:
                # name
                target_name = None
                if node.targets:
                    t0 = node.targets[0]
                    if isinstance(t0, ast.Name):
                        target_name = t0.id
                    elif isinstance(t0, ast.Attribute):
                        target_name = expr_to_str(t0)

                # parent expr = first arg if present
                parent_expr = expr_to_str(node.value.args[0]) if node.value.args else "<unknown>"
                kwargs = literal_kwargs(node.value)

                line = getattr(node, "lineno", 1)
                wid = f"{self.file_path}:{line}:{target_name or 'widget'}"

                confidence = 0.9 if parent_expr != "<unknown>" else 0.6

                self.widgets.append(
                    WidgetNode(
                        id=wid,
                        file=str(self.file_path),
                        line=int(line),
                        name=target_name or "<unnamed>",
                        widget_type=ctor,
                        parent_expr=parent_expr,
                        kwargs=kwargs,
                        confidence=confidence,
                    )
                )

                if target_name:
                    self._widget_symbols[target_name] = ctor

                # wiring: command=...
                if "command" in kwargs:
                    self.wiring.append(
                        WiringEdge(
                            file=str(self.file_path),
                            line=int(line),
                            source=target_name or wid,
                            kind="command",
                            event=None,
                            handler=str(kwargs["command"]),
                            confidence=0.85,
                        )
                    )

                # unknowns: if parent expr is complex
                if parent_expr.startswith("(") or "." in parent_expr and parent_expr.count("("):
                    self.unknowns.append(
                        UnknownCase(
                            case_type="DYNAMIC_PARENT",
                            file=str(self.file_path),
                            line=int(line),
                            snippet=self.lines.snippet_around(int(line), radius=3),
                            question="What is the likely parent container for this widget?",
                            context=self.lines.snippet_around(int(line), radius=12),
                        )
                    )

        self.generic_visit(node)

    def visit_Call(self, node: ast.Call):
        # layout calls: x.pack/grid/place(...)
        if isinstance(node.func, ast.Attribute):
            attr = node.func.attr
            if attr in WIDGET_METHODS_LAYOUT:
                line = getattr(node, "lineno", 1)
                target = expr_to_str(node.func.value)
                kwargs = literal_kwargs(node)
                self.layouts.append(
                    LayoutCall(
                        file=str(self.file_path),
                        line=int(line),
                        target=target,
                        manager=attr,
                        kwargs=kwargs,
                    )
                )

            # wiring calls
            if attr in WIRING_METHODS:
                line = getattr(node, "lineno", 1)
                source = expr_to_str(node.func.value)
                kind = attr
                event = None
                handler = ""

                if attr in {"bind", "bind_all"}:
                    if node.args:
                        event = expr_to_str(node.args[0])
                    if len(node.args) >= 2:
                        handler = expr_to_str(node.args[1])
                elif attr == "trace_add":
                    # var.trace_add(mode, callback)
                    if node.args:
                        event = expr_to_str(node.args[0])
                    if len(node.args) >= 2:
                        handler = expr_to_str(node.args[1])
                else:
                    # menu.add_command(label=..., command=...)
                    k = literal_kwargs(node)
                    if "command" in k:
                        handler = str(k["command"])

                if handler:
                    self.wiring.append(
                        WiringEdge(
                            file=str(self.file_path),
                            line=int(line),
                            source=source,
                            kind="bind" if attr in {"bind", "bind_all"} else ("trace" if attr == "trace_add" else "menu"),
                            event=event,
                            handler=handler,
                            confidence=0.75,
                        )
                    )

                # unknowns: getattr handler
                if "getattr" in handler:
                    self.unknowns.append(
                        UnknownCase(
                            case_type="DYNAMIC_HANDLER",
                            file=str(self.file_path),
                            line=int(line),
                            snippet=self.lines.snippet_around(int(line), radius=3),
                            question="What handler does this resolve to at runtime?",
                            context=self.lines.snippet_around(int(line), radius=12),
                        )
                    )

        self.generic_visit(node)


def map_project_ast(project_root: Path, py_files: list[Path], log: TkLogger, cancel: threading.Event) -> UiMap:
    widgets: list[WidgetNode] = []
    layouts: list[LayoutCall] = []
    wiring: list[WiringEdge] = []
    handlers: list[HandlerDef] = []
    unknowns: list[UnknownCase] = []

    for p in py_files:
        if cancel.is_set():
            break
        try:
            text = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(text)
        except Exception as e:
            log.log(f"SKIP parse error: {p} :: {e}")
            continue

        mapper = TkUiAstMapper(p, text, log)
        try:
            mapper.visit(tree)
        except Exception as e:
            log.log(f"ERROR mapping {p.name}: {e}")
            continue

        widgets.extend(mapper.widgets)
        layouts.extend(mapper.layouts)
        wiring.extend(mapper.wiring)
        handlers.extend(mapper.handlers)
        unknowns.extend(mapper.unknowns)

    return UiMap(
        project_root=str(project_root),
        entrypoint=None,
        widgets=widgets,
        layouts=layouts,
        wiring=wiring,
        handlers=handlers,
        unknowns=unknowns,
        inferred=[],
    )


# -----------------------------
# Ollama client (stdlib urllib)
# -----------------------------

class OllamaClient:
    def __init__(self, base_url: str, log: TkLogger):
        self.base_url = base_url.rstrip("/")
        self.log = log

    def list_models(self, timeout: float = 3.0) -> list[str]:
        url = f"{self.base_url}/api/tags"
        req = urllib.request.Request(url, method="GET")
        try:
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                data = json.loads(resp.read().decode("utf-8", errors="replace"))
            models = [m.get("name") for m in data.get("models", []) if m.get("name")]
            return sorted(models)
        except Exception as e:
            self.log.log(f"Ollama list_models failed: {e}")
            return []

    def generate_json(self, model: str, prompt: str, timeout: float = 30.0) -> dict:
        url = f"{self.base_url}/api/generate"
        payload = {
            "model": model,
            "prompt": prompt,
            "stream": False,
            "options": {
                "temperature": 0.1,
            },
        }
        data = json.dumps(payload).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"}, method="POST")
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            raw = resp.read().decode("utf-8", errors="replace")
        j = json.loads(raw)
        # Ollama returns {'response': '...'}
        txt = j.get("response", "")
        # Try parse as JSON
        try:
            return json.loads(txt)
        except Exception:
            return {"raw": txt}


def build_inference_prompt(case: UnknownCase) -> str:
    schema = {
        "best_guess": "string",
        "confidence": "0..1",
        "evidence": ["line refs or short quotes"],
        "explanation": "short"
    }
    return (
        "You are helping map a Tkinter UI using static AST evidence.\n"
        "Only infer what is strongly supported by the provided code context.\n"
        "Return ONLY valid JSON with keys: best_guess, confidence, evidence, explanation.\n\n"
        f"CASE_TYPE: {case.case_type}\n"
        f"QUESTION: {case.question}\n\n"
        "SNIPPET:\n"
        f"{case.snippet}\n\n"
        "CONTEXT:\n"
        f"{case.context}\n\n"
        "JSON_SCHEMA_EXAMPLE:\n"
        f"{json.dumps(schema, indent=2)}\n"
    )


# -----------------------------
# Reporting
# -----------------------------

def write_report_md(ui: UiMap, out_path: Path):
    def fmt_conf(x: float) -> str:
        return f"{x:.2f}"

    lines: list[str] = []
    lines.append(f"# Tkinter UI Map Report\n")
    lines.append(f"**Project Root:** `{ui.project_root}`\n")

    if ui.entrypoint:
        lines.append("## Entrypoint (Selected)\n")
        lines.append(f"- File: `{ui.entrypoint.file}`\n")
        lines.append(f"- Line: {ui.entrypoint.line}\n")
        lines.append(f"- Summary: `{ui.entrypoint.summary}`\n")

    lines.append("## Widgets (PROVEN via AST)\n")
    for w in sorted(ui.widgets, key=lambda x: (x.file, x.line)):
        lines.append(f"- **{w.widget_type}** `{w.name}`  ")
        lines.append(f"  - Location: `{w.file}`:{w.line}  ")
        lines.append(f"  - Parent: `{w.parent_expr}`  ")
        lines.append(f"  - Kwargs: `{json.dumps(w.kwargs, sort_keys=True)}`  ")
        lines.append(f"  - Confidence: {fmt_conf(w.confidence)}\n")

    lines.append("## Layout Calls (PROVEN via AST)\n")
    for lc in sorted(ui.layouts, key=lambda x: (x.file, x.line)):
        lines.append(f"- `{lc.target}`.{lc.manager}({json.dumps(lc.kwargs, sort_keys=True)})  ")
        lines.append(f"  - Location: `{lc.file}`:{lc.line}\n")

    lines.append("## Wiring (PROVEN via AST)\n")
    for e in sorted(ui.wiring, key=lambda x: (x.file, x.line)):
        ev = f" event={e.event}" if e.event else ""
        lines.append(f"- **{e.kind}** source=`{e.source}` handler=`{e.handler}`{ev}  ")
        lines.append(f"  - Location: `{e.file}`:{e.line}  ")
        lines.append(f"  - Confidence: {fmt_conf(e.confidence)}\n")

    lines.append("## Handlers Discovered (PROVEN via AST defs)\n")
    for h in sorted(ui.handlers, key=lambda x: (x.file, x.line, x.qualname)):
        lines.append(f"- `{h.qualname}`  ({h.file}:{h.line})")
    lines.append("\n")

    lines.append("## Unknowns (AST could not resolve)\n")
    for u in sorted(ui.unknowns, key=lambda x: (x.file, x.line)):
        lines.append(f"### {u.case_type} @ `{u.file}`:{u.line}\n")
        lines.append(f"**Question:** {u.question}\n")
        lines.append("```\n" + u.snippet + "\n```\n")

    if ui.inferred:
        lines.append("## Inferred (LLM-assisted)\n")
        for inf in ui.inferred:
            u = inf.case
            lines.append(f"### {u.case_type} @ `{u.file}`:{u.line}\n")
            lines.append(f"- **Best guess:** {inf.best_guess}\n")
            lines.append(f"- **Confidence:** {fmt_conf(inf.confidence)}\n")
            if inf.evidence:
                lines.append("- **Evidence:**\n")
                for ev in inf.evidence:
                    lines.append(f"  - {ev}\n")
            lines.append(f"- **Explanation:** {inf.explanation}\n")

    out_path.write_text("\n".join(lines), encoding="utf-8")


def write_report_json(ui: UiMap, out_path: Path):
    # Convert dataclasses to JSON-serializable
    def ser(o):
        if hasattr(o, "__dataclass_fields__"):
            return asdict(o)
        raise TypeError

    out_path.write_text(json.dumps(ui, default=ser, indent=2), encoding="utf-8")


# -----------------------------
# HITL dialogs
# -----------------------------

class CandidatePicker(tk.Toplevel):
    def __init__(self, master: tk.Tk, cands: list[EntrypointCandidate]):
        super().__init__(master)
        self.title("Select Entrypoint")
        self.geometry("820x380")
        self.resizable(True, True)
        self.choice: Optional[EntrypointCandidate] = None

        ttk.Label(self, text="Multiple entrypoints were found. Select the one that launches the UI.").pack(anchor="w", padx=10, pady=(10, 6))

        cols = ("file", "line", "summary")
        self.tree = ttk.Treeview(self, columns=cols, show="headings", height=12)
        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=220 if c == "file" else 80, stretch=True)
        self.tree.column("summary", width=460)
        self.tree.pack(fill="both", expand=True, padx=10)

        for i, c in enumerate(cands):
            self.tree.insert("", "end", iid=str(i), values=(c.file, c.line, c.summary))

        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10, pady=10)
        ttk.Button(btns, text="Select", command=self._select).pack(side="right")
        ttk.Button(btns, text="Cancel", command=self._cancel).pack(side="right", padx=(0, 8))

        self.tree.bind("<Double-1>", lambda e: self._select())

        self.grab_set()
        self.transient(master)

    def _select(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Pick one", "Select an entrypoint candidate.", parent=self)
            return
        idx = int(sel[0])
        vals = self.tree.item(sel[0], "values")
        self.choice = EntrypointCandidate(file=vals[0], line=int(vals[1]), summary=vals[2])
        self.destroy()

    def _cancel(self):
        self.choice = None
        self.destroy()


# -----------------------------
# Main App
# -----------------------------

class TkUiMapperApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Tkinter UI Mapper (AST + optional Ollama)")
        self.geometry("980x720")

        self.cancel_flag = threading.Event()
        self.worker: Optional[threading.Thread] = None

        # state
        self.project_dir = tk.StringVar(value=str(Path.cwd()))
        self.ollama_url = tk.StringVar(value=DEFAULT_OLLAMA_URL)
        self.model = tk.StringVar(value=DEFAULT_MODEL)
        self.use_llm = tk.BooleanVar(value=True)

        self.ui_map: Optional[UiMap] = None

        # top controls
        top = ttk.Frame(self)
        top.pack(fill="x", padx=10, pady=10)

        ttk.Label(top, text="Project folder:").grid(row=0, column=0, sticky="w")
        ttk.Entry(top, textvariable=self.project_dir).grid(row=0, column=1, sticky="ew", padx=6)
        ttk.Button(top, text="Browse…", command=self.pick_project).grid(row=0, column=2)

        ttk.Label(top, text="Ollama URL:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        ttk.Entry(top, textvariable=self.ollama_url).grid(row=1, column=1, sticky="ew", padx=6, pady=(8, 0))
        ttk.Button(top, text="Refresh models", command=self.refresh_models).grid(row=1, column=2, pady=(8, 0))

        ttk.Label(top, text="Model:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.model_combo = ttk.Combobox(top, textvariable=self.model, values=[DEFAULT_MODEL], state="readonly")
        self.model_combo.grid(row=2, column=1, sticky="w", padx=6, pady=(8, 0))

        ttk.Checkbutton(top, text="Use LLM to infer unknowns (HITL)", variable=self.use_llm).grid(row=2, column=2, sticky="w", pady=(8, 0))

        top.columnconfigure(1, weight=1)

        # buttons
        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10)
        self.run_btn = ttk.Button(btns, text="Run Map", command=self.run_map)
        self.run_btn.pack(side="left")
        self.save_btn = ttk.Button(btns, text="Save Report", command=self.save_report, state="disabled")
        self.save_btn.pack(side="left", padx=(8, 0))
        self.cancel_btn = ttk.Button(btns, text="Cancel", command=self.cancel, state="disabled")
        self.cancel_btn.pack(side="left", padx=(8, 0))

        # log
        self.log_text = ScrolledText(self, height=28)
        self.log_text.pack(fill="both", expand=True, padx=10, pady=10)
        self.log_text.configure(state="disabled")
        self.log = TkLogger(self.log_text)

        self.after(80, self._pump)

    def _pump(self):
        self.log.pump()
        self.after(80, self._pump)

    def pick_project(self):
        d = filedialog.askdirectory(title="Select project folder")
        if d:
            self.project_dir.set(d)

    def cancel(self):
        self.log.log("Cancel requested…")
        self.cancel_flag.set()

    def set_busy(self, busy: bool):
        self.run_btn.configure(state="disabled" if busy else "normal")
        self.save_btn.configure(state="disabled" if busy or not self.ui_map else "normal")
        self.cancel_btn.configure(state="normal" if busy else "disabled")

    def refresh_models(self):
        # async refresh
        self.log.log("Refreshing Ollama models…")
        url = self.ollama_url.get().strip()
        client = OllamaClient(url, self.log)

        def _work():
            models = client.list_models()
            def _apply():
                if models:
                    self.model_combo["values"] = models
                    # keep default if present
                    if self.model.get() not in models and DEFAULT_MODEL in models:
                        self.model.set(DEFAULT_MODEL)
                    elif self.model.get() not in models and models:
                        self.model.set(models[0])
                    self.log.log(f"Loaded {len(models)} model(s) from Ollama")
                else:
                    self.log.log("No models returned (is Ollama running?)")
            self.after(0, _apply)

        threading.Thread(target=_work, daemon=True).start()

    def run_map(self):
        root = Path(self.project_dir.get()).expanduser().resolve()
        if not root.exists() or not root.is_dir():
            messagebox.showerror("Invalid folder", "Select a valid project folder.")
            return

        self.cancel_flag.clear()
        self.ui_map = None
        self.set_busy(True)

        def _worker():
            try:
                self.log.log(f"Scanning project: {root}")
                py_files = iter_py_files(root)
                self.log.log(f"Python files found: {len(py_files)}")

                cands = find_entrypoints(py_files, self.log, self.cancel_flag)
                entry = None

                if self.cancel_flag.is_set():
                    raise RuntimeError("Cancelled")

                # HITL: select entrypoint when ambiguous
                if len(cands) == 0:
                    self.log.log("No __main__ entrypoints found. Proceeding with AST mapping anyway.")
                elif len(cands) == 1:
                    entry = cands[0]
                    self.log.log(f"Selected entrypoint: {entry.file}:{entry.line}")
                else:
                    # ask user on UI thread
                    entry = self._ask_pick_entrypoint(cands)
                    if entry is None:
                        raise RuntimeError("User cancelled entrypoint selection")
                    self.log.log(f"User selected entrypoint: {entry.file}:{entry.line}")

                if self.cancel_flag.is_set():
                    raise RuntimeError("Cancelled")

                ui_map = map_project_ast(root, py_files, self.log, self.cancel_flag)
                ui_map.entrypoint = entry

                self.log.log(f"AST map done: widgets={len(ui_map.widgets)} layouts={len(ui_map.layouts)} wiring={len(ui_map.wiring)} unknowns={len(ui_map.unknowns)}")

                if self.use_llm.get() and ui_map.unknowns and not self.cancel_flag.is_set():
                    self.log.log("LLM inference enabled: starting UNKNOWN case inference (HITL)…")
                    inferred = self._infer_unknowns_hitl(ui_map.unknowns)
                    ui_map.inferred = inferred
                    self.log.log(f"LLM inference complete: inferred={len(inferred)}")

                self.ui_map = ui_map

                def _done():
                    self.set_busy(False)
                    self.save_btn.configure(state="normal")
                    self.log.log("Run complete.")

                self.after(0, _done)

            except Exception as e:
                tb = traceback.format_exc()
                self.log.log(f"ERROR: {e}\n{tb}")
                self.after(0, lambda: self.set_busy(False))

        self.worker = threading.Thread(target=_worker, daemon=True)
        self.worker.start()

    def _ask_pick_entrypoint(self, cands: list[EntrypointCandidate]) -> Optional[EntrypointCandidate]:
        # synchronous ask (but must run on main thread)
        result_holder: dict[str, Any] = {"choice": None}
        ev = threading.Event()

        def _show():
            dlg = CandidatePicker(self, cands)
            self.wait_window(dlg)
            result_holder["choice"] = dlg.choice
            ev.set()

        self.after(0, _show)
        ev.wait()
        return result_holder["choice"]

    def _infer_unknowns_hitl(self, unknowns: list[UnknownCase]) -> list[InferenceResult]:
        url = self.ollama_url.get().strip()
        model = self.model.get().strip() or DEFAULT_MODEL
        client = OllamaClient(url, self.log)

        results: list[InferenceResult] = []

        for idx, case in enumerate(unknowns, start=1):
            if self.cancel_flag.is_set():
                self.log.log("Inference cancelled.")
                break

            self.log.log(f"Infer {idx}/{len(unknowns)}: {case.case_type} @ {Path(case.file).name}:{case.line}")
            prompt = build_inference_prompt(case)

            try:
                j = client.generate_json(model=model, prompt=prompt, timeout=45.0)
            except Exception as e:
                self.log.log(f"Ollama inference failed: {e}")
                continue

            # parse
            best_guess = str(j.get("best_guess", j.get("raw", ""))).strip()
            conf = j.get("confidence", 0.4)
            try:
                conf_f = float(conf)
            except Exception:
                conf_f = 0.4
            evidence = j.get("evidence", [])
            if not isinstance(evidence, list):
                evidence = [str(evidence)]
            explanation = str(j.get("explanation", "")).strip()

            inf = InferenceResult(
                case=case,
                best_guess=best_guess,
                confidence=max(0.0, min(1.0, conf_f)),
                evidence=[str(x) for x in evidence][:8],
                explanation=explanation,
            )

            # HITL approval for low confidence
            approved = self._ask_approve_inference(inf)
            if approved:
                results.append(inf)
                self.log.log(f"Approved inference: {inf.best_guess} (conf={inf.confidence:.2f})")
            else:
                self.log.log("Skipped inference (user declined).")

        return results

    def _ask_approve_inference(self, inf: InferenceResult) -> bool:
        # Always HITL prompt; user can skip noisy guesses.
        holder = {"ok": False}
        ev = threading.Event()

        def _show():
            msg = (
                f"UNKNOWN: {inf.case.case_type}\n"
                f"Location: {inf.case.file}:{inf.case.line}\n\n"
                f"Best guess: {inf.best_guess}\n"
                f"Confidence: {inf.confidence:.2f}\n\n"
                f"Explanation: {inf.explanation}\n\n"
                "Approve this inference to include it in the report?"
            )
            holder["ok"] = messagebox.askyesno("Approve inference?", msg, parent=self)
            ev.set()

        self.after(0, _show)
        ev.wait()
        return bool(holder["ok"])

    def save_report(self):
        if not self.ui_map:
            messagebox.showinfo("Nothing to save", "Run the mapper first.")
            return

        out_dir = filedialog.askdirectory(title="Select output folder")
        if not out_dir:
            return

        out = Path(out_dir)
        md_path = out / "ui_map_report.md"
        js_path = out / "ui_map_report.json"

        try:
            write_report_md(self.ui_map, md_path)
            write_report_json(self.ui_map, js_path)
            self.log.log(f"Saved report: {md_path}")
            self.log.log(f"Saved report: {js_path}")
            messagebox.showinfo("Saved", f"Report saved to:\n{md_path}\n{js_path}")
        except Exception as e:
            messagebox.showerror("Save failed", str(e))


if __name__ == "__main__":
    app = TkUiMapperApp()
    app.mainloop()


--------------------------------------------------------------------------------
FILE: _radomDOCS\architecture_overview.py
--------------------------------------------------------------------------------
"""
Enhanced Cell Identity System - Architecture Overview
=====================================================

ASCII ARCHITECTURE DIAGRAM
==========================

                         ┌─────────────────────────────┐
                         │   CellRegistry (Singleton)   │
                         │                             │
                         │  • Tracks all active cells  │
                         │  • Manages relationships    │
                         │  • Propagates name changes  │
                         └──────────────┬──────────────┘
                                        │
                    ┌───────────────────┼───────────────────┐
                    │                   │                   │
            ┌───────▼────────┐  ┌──────▼───────┐  ┌───────▼────────┐
            │  CellIdentity  │  │ CellIdentity │  │  CellIdentity  │
            │   (Root Cell)  │  │  (Child 1)   │  │  (Child 2)     │
            │                │  │              │  │                │
            │ ID: cell_abc   │  │ ID: cell_def │  │ ID: cell_ghi   │
            │ Name: "Root"   │  │ Name: "Mem"  │  │ Name: "Reason" │
            │ Parent: None   │  │ Parent: abc  │  │ Parent: abc    │
            │ Children:      │  │ Children:    │  │ Children:      │
            │  - cell_def    │  │  - cell_jkl  │  │   []           │
            │  - cell_ghi    │  │              │  │                │
            └────────────────┘  └──────┬───────┘  └────────────────┘
                                       │
                               ┌───────▼────────┐
                               │  CellIdentity  │
                               │  (Grandchild)  │
                               │                │
                               │ ID: cell_jkl   │
                               │ Name: "Store"  │
                               │ Parent: def    │
                               │ Children: []   │
                               └────────────────┘


NAME PROPAGATION FLOW
=====================

Step 1: User renames Child 1 from "Mem" to "Memory Specialist"
    │
    ├─> CellIdentity.rename("Memory Specialist")
    │       └─> Returns: ("Mem", "Memory Specialist")
    │
    ├─> CellRegistry.rename_cell(cell_def, "Memory Specialist")
    │       ├─> Updates Cell's own identity
    │       ├─> Finds Parent (cell_abc)
    │       │       └─> Updates parent.children["cell_def"] = "Memory Specialist"
    │       └─> Emits "cell_renamed" signal to all listeners
    │
    └─> SignalBus broadcasts to all Backends
            ├─> Root Cell UI updates its children list display
            ├─> Grandchild UI updates "Parent: Memory Specialist"
            └─> Nexus dropdowns update to show new name


RELATIONSHIP TRACKING
=====================

Parent → Child Relationship:
    parent.identity.children = {
        "cell_id_1": "Child Name 1",
        "cell_id_2": "Child Name 2"
    }

Child → Parent Relationship:
    child.identity.parent_id = "parent_cell_id"

Registry maintains BOTH directions simultaneously.


QUICK START INTEGRATION
========================

1. Copy enhanced_cell_identity.py to your src/ directory

2. In src/app.py, create global registry:
   
   from enhanced_cell_identity import CellRegistry
   
   global_registry = CellRegistry()

3. Pass registry to all Backend instances:
   
   backend = Backend(registry=global_registry, ...)

4. Add rename capability to UI:
   
   # In your settings or context menu:
   def rename_cell():
       new_name = simpledialog.askstring("Rename", "New name:")
       if new_name:
           backend.rename_cell(new_name)

5. Subscribe to rename events:
   
   backend.bus.subscribe("cell_renamed", handle_rename)


DATA STRUCTURES
===============

CellIdentity {
    cell_id: str                    # "cell_20260216210345_a3b4c5d6"
    cell_name: str                  # "Memory Specialist"
    parent_id: Optional[str]        # "cell_20260216205500_x1y2z3a4"
    children: Dict[str, str]        # {"child_id": "Child Name", ...}
    created_at: str                 # ISO timestamp
    renamed_at: Optional[str]       # ISO timestamp of last rename
}

CellRegistry {
    _cells: Dict[str, CellIdentity]  # All registered cells
    _lock: threading.Lock            # Thread-safe operations
    _change_listeners: List[callable] # For UI updates
}


EXAMPLE USAGE
=============

# Create registry
registry = CellRegistry()

# Create root cell
root = Backend(
    registry=registry,
    cell_name="Root Cognition"
)

# Spawn child
child = Backend(
    registry=registry,
    parent_id=root.cell_id,
    cell_name=f"Child of {root.cell_name}"
)

# Registry automatically updated!
print(root.identity.children)
# Output: {"cell_..._xyz": "Child of Root Cognition"}

# Rename child
child.rename_cell("Memory Module")

# Parent's record automatically updated!
print(root.identity.children)
# Output: {"cell_..._xyz": "Memory Module"}

# Get full lineage
lineage = registry.get_lineage(child.cell_id)
# Output: [root.cell_id, child.cell_id]


SIGNAL BUS EVENTS
=================

The system emits these events through your existing SignalBusMS:

1. "cell_registered"
   Data: CellIdentity object
   When: New cell created

2. "cell_unregistered"
   Data: CellIdentity object
   When: Cell window closed

3. "cell_renamed"
   Data: {
       "cell_id": "...",
       "old_name": "...",
       "new_name": "..."
   }
   When: Cell renamed

4. "update_window_title"
   Data: "New Title String"
   When: Cell renamed (convenience event)


THREADING CONSIDERATIONS
=========================

The CellRegistry uses a threading.Lock to ensure thread-safety.

All registry operations are atomic:
- register_cell()
- unregister_cell()
- rename_cell()
- get_cell()
- get_all_cells()

You can safely call these from:
- Main UI thread
- Background inference threads
- Signal bus callbacks


PERSISTENCE STRATEGY (Optional)
================================

To persist the registry across app restarts:

1. On registry change, save to disk:
   
   def save_registry():
       data = registry.export_registry()
       with open('registry.json', 'w') as f:
           f.write(data)

2. On app startup, restore:
   
   def load_registry():
       if os.path.exists('registry.json'):
           with open('registry.json') as f:
               data = json.load(f)
               # Recreate cells from saved data
               for cell_data in data['cells'].values():
                   # Restore backend instances...

3. Consider using SQLite instead of JSON for better concurrent access


DEBUGGING TIPS
==============

1. Export registry to see full state:
   print(registry.export_registry())

2. Check cell lineage:
   lineage = registry.get_lineage(cell_id)
   for cid in lineage:
       cell = registry.get_cell(cid)
       print(f"  {cell.cell_name} ({cid})")

3. Verify bidirectional relationships:
   parent = registry.get_cell(parent_id)
   child = registry.get_cell(child_id)
   
   assert child_id in parent.children
   assert child.parent_id == parent_id

4. Monitor events:
   def debug_listener(event_type, data):
       print(f"[REGISTRY EVENT] {event_type}: {data}")
   
   registry.add_change_listener(debug_listener)


MIGRATION CHECKLIST
===================

□ Copy enhanced_cell_identity.py to src/
□ Import CellRegistry in app.py
□ Create global_registry = CellRegistry()
□ Modify Backend.__init__ to accept registry
□ Pass registry to all Backend instances
□ Add backend.rename_cell() method
□ Add rename UI (dialog + menu item)
□ Subscribe to cell_renamed signal
□ Update window title on rename
□ Update nexus dropdown to show names
□ Test: create → rename → spawn → rename parent → verify propagation
□ Optional: Add cell info bar showing name/ID
□ Optional: Add family tree viewer
□ Optional: Persist registry to disk


NEXT STEPS
==========

Once integrated, you can build on this foundation:

1. Cell Specialization
   - Add cell_type field to CellIdentity
   - Track what each cell is good at
   - Auto-route tasks to specialized cells

2. Emergent Behavior Tracking
   - Record successful inference patterns per cell
   - Identify which cells produce best results
   - Spawn more of successful cell types

3. Cell Communication Patterns
   - Track which cells talk to which
   - Identify communication bottlenecks
   - Optimize information flow

4. Evolutionary Selection
   - Track cell performance metrics
   - "Kill" underperforming cells
   - Spawn from high-performers
"""


# =============================================================================
# VISUAL EXAMPLE: Cell Hierarchy Display
# =============================================================================

def print_cell_tree(registry: CellRegistry, root_id: str, indent: int = 0):
    """
    Pretty-prints the cell hierarchy as a tree.
    
    Example output:
    
    Root Cognition [cell_abc]
    ├── Memory Specialist [cell_def]
    │   └── Knowledge Store [cell_jkl]
    └── Reasoning Module [cell_ghi]
    """
    cell = registry.get_cell(root_id)
    if not cell:
        return
    
    prefix = "│   " * indent
    connector = "├── " if indent > 0 else ""
    
    print(f"{prefix}{connector}{cell.cell_name} [{cell.cell_id}]")
    
    children_ids = list(cell.children.keys())
    for i, child_id in enumerate(children_ids):
        is_last = (i == len(children_ids) - 1)
        child_connector = "└── " if is_last else "├── "
        child_prefix = "    " if is_last else "│   "
        
        child_cell = registry.get_cell(child_id)
        if child_cell:
            print(f"{prefix}{'│   ' * indent}{child_connector}{child_cell.cell_name} [{child_id}]")
            
            # Recurse for grandchildren
            if child_cell.children:
                print_cell_tree(registry, child_id, indent + 1)


if __name__ == "__main__":
    # Demonstration
    from enhanced_cell_identity import CellRegistry, CellIdentity
    
    registry = CellRegistry()
    
    # Create root
    root = CellIdentity(cell_id="cell_abc", cell_name="Root Cognition")
    registry.register_cell(root)
    
    # Create children
    mem = CellIdentity(
        cell_id="cell_def",
        cell_name="Memory Specialist",
        parent_id="cell_abc"
    )
    registry.register_cell(mem)
    
    reason = CellIdentity(
        cell_id="cell_ghi",
        cell_name="Reasoning Module",
        parent_id="cell_abc"
    )
    registry.register_cell(reason)
    
    # Create grandchild
    store = CellIdentity(
        cell_id="cell_jkl",
        cell_name="Knowledge Store",
        parent_id="cell_def"
    )
    registry.register_cell(store)
    
    print("=" * 60)
    print("CELL HIERARCHY")
    print("=" * 60)
    print_cell_tree(registry, "cell_abc")
    print()
    
    print("=" * 60)
    print("RENAME PROPAGATION TEST")
    print("=" * 60)
    print("Before rename:")
    print(f"  Parent's children: {root.children}")
    print()
    
    registry.rename_cell("cell_def", "Long-Term Memory System")
    
    print("After rename:")
    print(f"  Parent's children: {root.children}")
    print(f"  Cell's own name: {mem.cell_name}")

--------------------------------------------------------------------------------
FILE: _radomDOCS\enhanced_cell_identity.py
--------------------------------------------------------------------------------
"""
Enhanced Cell Identity System for _theCELL
==========================================

This module provides the architecture for:
1. Unique ID generation at cell instantiation
2. User-renameable cell names with defaults
3. Bidirectional parent-child relationship tracking
4. Name change propagation across the cell registry
"""

import uuid
from typing import Dict, List, Optional, Set
from datetime import datetime
import json
import threading


class CellIdentity:
    """Manages unique identity and relationships for a single cell."""
    
    def __init__(self, cell_id: str = None, cell_name: str = None, parent_id: str = None):
        # Unique identifier - generated if not provided
        self.cell_id: str = cell_id or self._generate_unique_id()
        
        # Human-readable name - defaults to ID-based name if not provided
        self.cell_name: str = cell_name or self._generate_default_name()
        
        # Relationship tracking
        self.parent_id: Optional[str] = parent_id
        self.children: Dict[str, str] = {}  # {child_id: child_name}
        
        # Metadata
        self.created_at: str = datetime.now().isoformat()
        self.renamed_at: Optional[str] = None
        
    def _generate_unique_id(self) -> str:
        """Generates a unique, collision-resistant cell ID."""
        # Format: cell_<timestamp>_<uuid_segment>
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        uuid_segment = uuid.uuid4().hex[:8]
        return f"cell_{timestamp}_{uuid_segment}"
    
    def _generate_default_name(self) -> str:
        """Generates a default name based on the cell ID."""
        # Extract the last 8 chars for readability
        short_id = self.cell_id.split('_')[-1]
        return f"Cell-{short_id.upper()}"
    
    def rename(self, new_name: str) -> tuple[str, str]:
        """
        Renames the cell and returns (old_name, new_name) for propagation.
        """
        old_name = self.cell_name
        self.cell_name = new_name
        self.renamed_at = datetime.now().isoformat()
        return old_name, new_name
    
    def add_child(self, child_id: str, child_name: str):
        """Records a child cell."""
        self.children[child_id] = child_name
    
    def update_child_name(self, child_id: str, new_name: str):
        """Updates a child's name in this parent's record."""
        if child_id in self.children:
            self.children[child_id] = new_name
    
    def to_dict(self) -> dict:
        """Serializes identity to dictionary."""
        return {
            "cell_id": self.cell_id,
            "cell_name": self.cell_name,
            "parent_id": self.parent_id,
            "children": self.children,
            "created_at": self.created_at,
            "renamed_at": self.renamed_at
        }


class CellRegistry:
    """
    Global registry that tracks all active cells and manages name propagation.
    This is the "Nexus" for cell-to-cell identity awareness.
    """
    
    def __init__(self):
        self._cells: Dict[str, CellIdentity] = {}  # {cell_id: CellIdentity}
        self._lock = threading.Lock()
        self._change_listeners: List[callable] = []  # For UI updates
        
    def register_cell(self, identity: CellIdentity) -> None:
        """Registers a new cell in the global registry."""
        with self._lock:
            self._cells[identity.cell_id] = identity
            
            # If this cell has a parent, update parent's children list
            if identity.parent_id and identity.parent_id in self._cells:
                parent = self._cells[identity.parent_id]
                parent.add_child(identity.cell_id, identity.cell_name)
            
            self._notify_listeners("cell_registered", identity)
    
    def unregister_cell(self, cell_id: str) -> None:
        """Removes a cell from the registry (on cell close)."""
        with self._lock:
            if cell_id in self._cells:
                identity = self._cells[cell_id]
                
                # Notify parent of child removal
                if identity.parent_id and identity.parent_id in self._cells:
                    parent = self._cells[identity.parent_id]
                    if cell_id in parent.children:
                        del parent.children[cell_id]
                
                del self._cells[cell_id]
                self._notify_listeners("cell_unregistered", identity)
    
    def rename_cell(self, cell_id: str, new_name: str) -> None:
        """
        Renames a cell and propagates the change to all references.
        This is the core propagation mechanism.
        """
        with self._lock:
            if cell_id not in self._cells:
                return
            
            identity = self._cells[cell_id]
            old_name, new_name = identity.rename(new_name)
            
            # Propagate to parent
            if identity.parent_id and identity.parent_id in self._cells:
                parent = self._cells[identity.parent_id]
                parent.update_child_name(cell_id, new_name)
            
            # Propagate to all children
            for child_id in identity.children.keys():
                if child_id in self._cells:
                    # Children might display parent name in their UI
                    # Emit a signal they can listen to
                    pass
            
            # Notify all listeners of the name change
            self._notify_listeners("cell_renamed", {
                "cell_id": cell_id,
                "old_name": old_name,
                "new_name": new_name
            })
    
    def get_cell(self, cell_id: str) -> Optional[CellIdentity]:
        """Retrieves a cell's identity by ID."""
        with self._lock:
            return self._cells.get(cell_id)
    
    def get_all_cells(self) -> Dict[str, CellIdentity]:
        """Returns a copy of all registered cells."""
        with self._lock:
            return self._cells.copy()
    
    def get_children(self, cell_id: str) -> Dict[str, str]:
        """Returns all children of a given cell."""
        with self._lock:
            if cell_id in self._cells:
                return self._cells[cell_id].children.copy()
            return {}
    
    def get_lineage(self, cell_id: str) -> List[str]:
        """
        Returns the full lineage from root to this cell.
        Format: [root_id, ..., parent_id, cell_id]
        """
        lineage = []
        current_id = cell_id
        
        with self._lock:
            while current_id and current_id in self._cells:
                lineage.insert(0, current_id)
                current_id = self._cells[current_id].parent_id
        
        return lineage
    
    def get_descendants(self, cell_id: str) -> Set[str]:
        """
        Returns all descendant cell IDs recursively.
        """
        descendants = set()
        
        def _recurse(cid: str):
            if cid in self._cells:
                for child_id in self._cells[cid].children.keys():
                    descendants.add(child_id)
                    _recurse(child_id)
        
        with self._lock:
            _recurse(cell_id)
        
        return descendants
    
    def add_change_listener(self, listener: callable):
        """Register a callback for registry changes."""
        self._change_listeners.append(listener)
    
    def _notify_listeners(self, event_type: str, data):
        """Notifies all listeners of a registry change."""
        for listener in self._change_listeners:
            try:
                listener(event_type, data)
            except Exception as e:
                print(f"Listener error: {e}")
    
    def export_registry(self) -> str:
        """Exports the entire registry as JSON."""
        with self._lock:
            data = {
                "cells": {cid: identity.to_dict() for cid, identity in self._cells.items()},
                "timestamp": datetime.now().isoformat()
            }
            return json.dumps(data, indent=2)


# =============================================================================
# Integration Example for Backend Class
# =============================================================================

class EnhancedBackend:
    """
    Example of how to integrate the identity system into your existing Backend class.
    """
    
    def __init__(self, 
                 registry: CellRegistry,
                 cell_id: str = None,
                 cell_name: str = None,
                 parent_id: str = None,
                 **kwargs):
        
        # Create identity
        self.identity = CellIdentity(cell_id, cell_name, parent_id)
        
        # Convenience accessors (backward compatible)
        self.cell_id = self.identity.cell_id
        self.cell_name = self.identity.cell_name
        self.parent_id = self.identity.parent_id
        
        # Register in global registry
        self.registry = registry
        self.registry.register_cell(self.identity)
        
        # ... rest of your existing Backend init ...
    
    def rename_cell(self, new_name: str):
        """User-facing method to rename this cell."""
        self.registry.rename_cell(self.cell_id, new_name)
        # Update local reference
        self.cell_name = self.identity.cell_name
    
    def spawn_child(self, inherited_context: str = "") -> 'EnhancedBackend':
        """
        Enhanced spawning that properly tracks relationships.
        """
        # Generate child identity
        child_id = None  # Will auto-generate
        child_name = f"Child of {self.cell_name}"
        
        # Create child backend
        child_backend = EnhancedBackend(
            registry=self.registry,
            cell_id=child_id,
            cell_name=child_name,
            parent_id=self.cell_id
        )
        
        # Parent's children list is auto-updated via registry
        
        return child_backend
    
    def get_family_tree(self) -> dict:
        """Returns a visualization of this cell's family relationships."""
        lineage = self.registry.get_lineage(self.cell_id)
        children = self.registry.get_children(self.cell_id)
        descendants = self.registry.get_descendants(self.cell_id)
        
        return {
            "cell_id": self.cell_id,
            "cell_name": self.cell_name,
            "lineage": lineage,
            "direct_children": children,
            "all_descendants": list(descendants)
        }
    
    def close(self):
        """Clean up when cell is destroyed."""
        self.registry.unregister_cell(self.cell_id)


# =============================================================================
# UI Integration Example
# =============================================================================

def create_rename_dialog(parent_window, backend: EnhancedBackend):
    """
    Example tkinter dialog for renaming a cell.
    This would integrate with your existing CELL_UI class.
    """
    import tkinter as tk
    from tkinter import simpledialog
    
    def rename_cell_callback():
        new_name = simpledialog.askstring(
            "Rename Cell",
            f"Enter new name for {backend.cell_name}:",
            initialvalue=backend.cell_name,
            parent=parent_window
        )
        
        if new_name and new_name.strip():
            backend.rename_cell(new_name.strip())
            # UI will be updated via signal bus
    
    return rename_cell_callback


# =============================================================================
# Signal Bus Integration
# =============================================================================

def integrate_with_signal_bus(registry: CellRegistry, signal_bus):
    """
    Connects the registry to your existing SignalBusMS for event propagation.
    """
    
    def on_registry_change(event_type: str, data):
        """Broadcasts registry changes through the signal bus."""
        signal_bus.emit(f"registry_{event_type}", data)
    
    registry.add_change_listener(on_registry_change)


# =============================================================================
# Usage Example
# =============================================================================

if __name__ == "__main__":
    # Create global registry (singleton in your app.py)
    global_registry = CellRegistry()
    
    # Create root cell
    root_cell = EnhancedBackend(
        registry=global_registry,
        cell_name="Root Cognition"
    )
    
    print(f"Root Cell: {root_cell.cell_id} | Name: {root_cell.cell_name}")
    
    # Spawn children
    child1 = root_cell.spawn_child()
    child2 = root_cell.spawn_child()
    
    print(f"Child 1: {child1.cell_id} | Name: {child1.cell_name}")
    print(f"Child 2: {child2.cell_id} | Name: {child2.cell_name}")
    
    # Spawn grandchild
    grandchild = child1.spawn_child()
    print(f"Grandchild: {grandchild.cell_id} | Name: {grandchild.cell_name}")
    
    # Show family tree
    print("\nRoot's Family Tree:")
    print(json.dumps(root_cell.get_family_tree(), indent=2))
    
    # Rename child
    print("\n--- Renaming Child 1 ---")
    child1.rename_cell("Memory Specialist")
    
    # Check propagation
    print(f"Child 1 new name: {child1.cell_name}")
    print(f"Root's children: {global_registry.get_children(root_cell.cell_id)}")
    print(f"Grandchild's parent: {grandchild.parent_id}")
    
    # Export registry
    print("\n--- Full Registry ---")
    print(global_registry.export_registry())

--------------------------------------------------------------------------------
FILE: _radomDOCS\integration_guide.py
--------------------------------------------------------------------------------
"""
Integration Guide: Enhanced Cell Identity System
================================================

This guide shows how to integrate the enhanced cell identity system
into your existing _theCELL project with minimal disruption.

STEP-BY-STEP INTEGRATION
"""

# =============================================================================
# STEP 1: Modify src/backend.py
# =============================================================================

"""
1. Import the new identity system at the top of backend.py:
"""

# Add to imports in src/backend.py
from enhanced_cell_identity import CellIdentity, CellRegistry

"""
2. Modify the Backend.__init__ method:
"""

class Backend:
    def __init__(self, 
                 registry: CellRegistry,  # NEW: Pass in global registry
                 memory_path: str = None, 
                 db_path: str = None, 
                 db_dir: str = "_db",
                 cell_id: str = None,      # MODIFIED: Now optional
                 parent_id: str = None,
                 cell_name: str = None):   # MODIFIED: Now optional
        
        # NEW: Create identity with auto-generation if not provided
        self.identity = CellIdentity(cell_id, cell_name, parent_id)
        
        # MODIFIED: Use identity properties
        self.cell_id = self.identity.cell_id
        self.cell_name = self.identity.cell_name
        self.parent_id = self.identity.parent_id
        
        # NEW: Store registry reference
        self.registry = registry
        
        # BACKWARD COMPATIBLE: Keep children_ids for now
        # But it will be managed through identity/registry
        self.children_ids = list(self.identity.children.keys())
        
        # Register this cell globally
        self.registry.register_cell(self.identity)
        
        # ... rest of existing __init__ code unchanged ...
        
        if db_path is None:
            db_path = os.path.join(db_dir, "app_internal.db")
        
        self.db_path = db_path
        # ... etc ...


# =============================================================================
# STEP 2: Add Cell Rename Method to Backend
# =============================================================================

"""
Add these methods to the Backend class:
"""

class Backend:
    # ... existing methods ...
    
    def rename_cell(self, new_name: str):
        """
        User-facing method to rename this cell.
        Propagates change through registry to all references.
        """
        old_name = self.cell_name
        self.registry.rename_cell(self.cell_id, new_name)
        
        # Update local reference
        self.cell_name = self.identity.cell_name
        
        # Emit signal for UI update
        self.bus.emit("cell_renamed", {
            "cell_id": self.cell_id,
            "old_name": old_name,
            "new_name": new_name
        })
        
        # Update window title if needed
        self.bus.emit("update_window_title", f"_theCELL [{self.cell_name}]")
    
    def get_family_tree(self) -> dict:
        """Returns detailed family relationship data."""
        return {
            "identity": self.identity.to_dict(),
            "lineage": self.registry.get_lineage(self.cell_id),
            "children": self.registry.get_children(self.cell_id),
            "descendants": list(self.registry.get_descendants(self.cell_id))
        }
    
    def close_cell(self):
        """Clean up when cell window is closed."""
        self.registry.unregister_cell(self.cell_id)
        # Any other cleanup...


# =============================================================================
# STEP 3: Modify src/app.py
# =============================================================================

"""
Update the main() function to create and pass the global registry:
"""

def main():
    from enhanced_cell_identity import CellRegistry
    
    # NEW: Create global cell registry (singleton for the application)
    global_registry = CellRegistry()
    
    # Initialize the logic hub with registry
    backend = Backend(registry=global_registry)  # NEW: Pass registry
    
    # Load persisted theme preference (default Dark)
    theme = (backend.get_setting('theme_preference') or 'Dark').strip().title()
    if theme not in ('Dark', 'Light'):
        theme = 'Dark'
    
    # Initialize the Mother Ship (Shell)
    shell = TkinterAppShellMS({
        "title": f"_theCELL [{backend.cell_name}]",  # MODIFIED: Show name in title
        "geometry": "1000x800",
        "theme": theme
    })
    
    # Dock the UI into the shell
    app_ui = CELL_UI(shell, backend)

    # --- Global Orchestration State ---
    # MODIFIED: Use registry instead of manual dict
    
    def broadcast_registry_update():
        """Informs all cells of the current list of available targets."""
        active_cells = global_registry.get_all_cells()
        active_data = {
            cid: {"id": cid, "name": identity.cell_name}
            for cid, identity in active_cells.items()
        }
        
        for cid, identity in active_cells.items():
            cell_backend = _get_backend_for_cell(cid)  # Helper method
            if cell_backend:
                cell_backend.bus.emit("update_registry", active_data)

    def register_cell_orchestration(target_backend):
        """Wires a backend into the global recursive and nexus pipelines."""
        
        # 1. Handle Recursive Spawning
        def on_spawn_request(data):
            print(f"[System] Spawning child from: {data.get('spawn_timestamp')}")
            
            # MODIFIED: Use identity system
            parent_identity = target_backend.identity
            
            # Create child window
            child_win = shell.spawn_window(
                title=f"_theCELL [Child of {parent_identity.cell_name}]",
                geometry="900x700"
            )
            
            # MODIFIED: Let identity system generate unique ID and name
            unique_session_id = None  # Will be auto-generated
            child_backend = Backend(
                registry=global_registry,  # NEW: Pass same registry
                memory_path=f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jsonl",
                cell_id=None,  # Auto-generate
                parent_id=parent_identity.cell_id,
                cell_name=None  # Will default to "Child of ParentName"
            )
            
            # Parent-child relationship is auto-managed by registry
            
            # Shell Proxy for Child Window
            # ... rest of existing code ...


# =============================================================================
# STEP 4: Add Rename UI to src/ui.py
# =============================================================================

"""
Add a rename dialog to the CELL_UI class:
"""

class CELL_UI:
    # ... existing code ...
    
    def _open_rename_dialog(self):
        """Opens a dialog to rename the current cell."""
        from tkinter import simpledialog
        
        new_name = simpledialog.askstring(
            "Rename Cell",
            f"Enter new name for '{self.backend.cell_name}':",
            initialvalue=self.backend.cell_name,
            parent=self.shell.root
        )
        
        if new_name and new_name.strip():
            self.backend.rename_cell(new_name.strip())
    
    def _register_signals(self):
        """Connects UI to the nervous system."""
        if hasattr(self.backend, 'bus'):
            self.backend.bus.subscribe("log_append", self._on_log_append)
            self.backend.bus.subscribe("process_complete", self._on_process_complete)
            self.backend.bus.subscribe("update_registry", self._update_nexus_list)
            self.backend.bus.subscribe("push_to_nexus", self._handle_incoming_push)
            self.backend.bus.subscribe("theme_updated", self.refresh_theme)
            
            # NEW: Handle cell rename events
            self.backend.bus.subscribe("cell_renamed", self._on_cell_renamed)
            self.backend.bus.subscribe("update_window_title", self._update_window_title)
    
    def _on_cell_renamed(self, data):
        """Handles cell rename events."""
        # Update any UI elements that display the cell name
        if hasattr(self, 'cell_name_label'):
            self.cell_name_label.config(text=data['new_name'])
    
    def _update_window_title(self, new_title):
        """Updates the window title."""
        self.shell.root.title(new_title)
    
    def _build_context_menu(self):
        """Build right-click context menu."""
        self.context_menu = tk.Menu(self.shell.root, tearoff=0)
        
        # ... existing menu items ...
        
        # NEW: Add rename option
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Rename Cell", command=self._open_rename_dialog)
        self.context_menu.add_command(label="View Family Tree", command=self._show_family_tree)
    
    def _show_family_tree(self):
        """Shows a dialog with the cell's family relationships."""
        import json
        from tkinter import messagebox
        
        tree_data = self.backend.get_family_tree()
        formatted = json.dumps(tree_data, indent=2)
        
        messagebox.showinfo(
            "Cell Family Tree",
            formatted,
            parent=self.shell.root
        )


# =============================================================================
# STEP 5: Add Menu Bar Rename Option
# =============================================================================

"""
In your existing menu creation code, add a rename option:
"""

def _build_menu_bar(self):
    """Creates the application menu bar."""
    menubar = tk.Menu(self.shell.root)
    self.shell.root.config(menu=menubar)
    
    # Cell menu
    cell_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Cell", menu=cell_menu)
    
    cell_menu.add_command(label="Rename Cell...", command=self._open_rename_dialog)
    cell_menu.add_command(label="View Family Tree...", command=self._show_family_tree)
    cell_menu.add_separator()
    cell_menu.add_command(label="Close Cell", command=self.shell.root.destroy)
    
    # ... rest of menu ...


# =============================================================================
# STEP 6: Update Nexus Dropdown to Show Names
# =============================================================================

"""
Modify the nexus update handler to display cell names instead of IDs:
"""

def _update_nexus_list(self, active_cells_data):
    """
    Updates the Nexus dropdown with currently active cells.
    
    active_cells_data format:
    {
        "cell_id": {"id": "cell_id", "name": "Cell Name"},
        ...
    }
    """
    # Filter out self
    targets = [
        f"{data['name']} ({cid})"
        for cid, data in active_cells_data.items()
        if cid != self.session_id
    ]
    
    self.nexus_cb['values'] = ["Select..."] + targets
    
    # Store mapping for lookup
    self._nexus_id_map = {
        f"{data['name']} ({cid})": cid
        for cid, data in active_cells_data.items()
    }

def _on_push_to_nexus(self):
    """Push result content to the selected target cell."""
    display_name = self.nexus_var.get()
    if display_name in ["Select...", ""]:
        return
    
    # Lookup actual cell ID from display name
    target_id = self._nexus_id_map.get(display_name)
    if not target_id:
        return
    
    content = self.result_text.get("1.0", "end-1c")
    self.backend.push_to_target(target_id, content)


# =============================================================================
# STEP 7: Add Cell Name Display in UI
# =============================================================================

"""
Add a visual indicator of the cell's name and lineage:
"""

def _add_cell_info_bar(self):
    """Adds an info bar showing cell identity."""
    info_bar = tk.Frame(self.container, bg=self.colors.get('panel_bg'))
    info_bar.pack(fill='x', padx=10, pady=(5, 0))
    
    # Cell name (clickable to rename)
    self.cell_name_label = tk.Label(
        info_bar,
        text=self.backend.cell_name,
        bg=self.colors.get('panel_bg'),
        fg=self.colors.get('accent'),
        font=("Segoe UI", 10, "bold"),
        cursor="hand2"
    )
    self.cell_name_label.pack(side='left', padx=5)
    self.cell_name_label.bind("<Button-1>", lambda e: self._open_rename_dialog())
    
    # Cell ID (smaller, grayed out)
    id_label = tk.Label(
        info_bar,
        text=f"({self.backend.cell_id})",
        bg=self.colors.get('panel_bg'),
        fg=self.colors.get('foreground'),
        font=("Segoe UI", 8)
    )
    id_label.pack(side='left')
    
    # Parent info (if applicable)
    if self.backend.parent_id:
        parent_identity = self.backend.registry.get_cell(self.backend.parent_id)
        if parent_identity:
            parent_label = tk.Label(
                info_bar,
                text=f"← Child of: {parent_identity.cell_name}",
                bg=self.colors.get('panel_bg'),
                fg=self.colors.get('foreground'),
                font=("Segoe UI", 8, "italic")
            )
            parent_label.pack(side='left', padx=(10, 0))


# =============================================================================
# STEP 8: Testing Checklist
# =============================================================================

"""
After integration, test these scenarios:

1. ✓ Create root cell - verify unique ID generated
2. ✓ Rename root cell - verify name updates in:
   - Window title
   - Cell info bar
   - Registry
3. ✓ Spawn child cell - verify:
   - Child has unique ID
   - Child's default name reflects parent
   - Parent's children list includes child
   - Child's parent_id points to parent
4. ✓ Rename parent cell - verify:
   - Child's record of parent name updates
   - No errors in console
5. ✓ Spawn grandchild - verify:
   - 3-generation lineage tracks correctly
   - get_lineage() returns proper chain
6. ✓ Close child cell - verify:
   - Registry removes child
   - Parent's children list updates
7. ✓ Nexus dropdown - verify:
   - Shows cell names (not just IDs)
   - Only shows other cells (not self)
   - Updates when cells renamed
8. ✓ Export registry - verify JSON structure correct
"""


# =============================================================================
# STEP 9: Optional Enhancements
# =============================================================================

"""
Consider these future enhancements:

1. PERSISTENCE
   - Save registry to disk on changes
   - Restore on app restart
   - Store in SQLite alongside other app data

2. VISUALIZATION
   - Create a tree view widget showing cell hierarchy
   - Show active cells in a graph
   - Highlight parent-child relationships

3. SEARCH
   - Search cells by name
   - Find cells by relationship
   - Filter by lineage depth

4. CELL METADATA
   - Add tags/labels to cells
   - Track cell purpose/specialization
   - Store creation time, activity stats

5. SMART NAMING
   - Auto-suggest names based on cell's first inference
   - Learn naming patterns from user
   - Detect duplicate names
"""
