Dump: C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL


--------------------------------------------------------------------------------
FILE: .gitignore
--------------------------------------------------------------------------------
# ============================================================
# _theCELL / _UsefulHelperSCRIPTS - Python + Tkinter
# ============================================================

# --- Python bytecode / caches ---
__pycache__/
*.py[cod]
*$py.class
.pytest_cache/
.mypy_cache/
.ruff_cache/
.pyre/
.pytype/
.coverage
.coverage.*
htmlcov/

# --- Virtual environments (keep crawlers out) ---
.venv/
venv/
ENV/
env/
.conda/
.condarc
pip-wheel-metadata/

# --- Packaging / build artifacts ---
build/
dist/
*.egg-info/
.eggs/
pip-log.txt

# --- IDE / editor ---
.vscode/
.idea/
*.code-workspace

# --- OS junk ---
.DS_Store
Thumbs.db
Desktop.ini

# --- Logs / temp ---
*.log
*.tmp
*.temp
*.swp
*~
.cache/
_logs

# --- App persistence / generated data ---
_db/
*.db
*.sqlite
*.sqlite3
*.db-journal
*.sqlite-journal
*.wal
*.shm

# --- JSONL / session artifacts (generated) ---
*.jsonl
memory_archive_*.jsonl
working_memory*.jsonl
session_*.jsonl

# --- Common local config/secrets (donâ€™t commit) ---
.env
.env.*
*.env
secrets.json
config.local.json
app_config.json
app_config.json.tmp

# --- Vector / RAG stores (often large + machine-local) ---
knowledge_base/
chroma/
chromadb/
vector_store/
vectors/
*.faiss
*.index

# --- Jupyter / notebooks (if any) ---
.ipynb_checkpoints/

# --- Optional: if you ever dump reports/maps locally ---
*_project_map.txt
*_filedump.txt
*_folder_tree.txt
reports/
output/

--------------------------------------------------------------------------------
FILE: LICENSE.md
--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Jacob Lambert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
requests>=2.28.0
pydantic>=1.10.0,<2.0.0
chromadb>=0.3.21
faiss-cpu>=1.7.4
numpy>=1.21.0


--------------------------------------------------------------------------------
FILE: setup_env.bat
--------------------------------------------------------------------------------
@echo off
setlocal

echo [STATUS] Searching for Python 3.10...
py -3.10 --version >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERROR] Python 3.10 was not found. Please install it from python.org.
    pause
    exit /b
)

echo [STATUS] Setting up _theCELL Environment with Python 3.10...
if not exist .venv (
    py -3.10 -m venv .venv
)

call .venv\Scripts\activate

echo [STATUS] Installing dependencies from requirements.txt...
python -m pip install --upgrade pip
python -m pip install -r requirements.txt

echo [STATUS] Setup Complete.
echo ----------------------------------------------------------------------
echo  Starting _theCELL Idea Ingestor...
echo ----------------------------------------------------------------------
python -m src.app
pause

--------------------------------------------------------------------------------
FILE: src\app.py
--------------------------------------------------------------------------------
import uuid
from .backend import Backend
from .ui import CELL_UI
from src.microservices._TkinterAppShellMS import TkinterAppShellMS

def main():
    # Initialize the logic hub
    backend = Backend()

    # Load persisted theme preference (default Dark)
    theme = (backend.get_setting('theme_preference') or 'Dark').strip().title()
    if theme not in ('Dark', 'Light'):
        theme = 'Dark'
    
    # Initialize the Mother Ship (Shell)
    shell = TkinterAppShellMS({
        "title": "_theCELL - Idea Ingestor",
        "geometry": "1000x800",
        "theme": theme
    })
    
    # Dock the UI into the shell
    app_ui = CELL_UI(shell, backend)

    # --- Spawning Logic ---
    def on_spawn_request(data):
        """Callback when a cell requests a child."""
        print(f"[System] Spawning child cell from source: {data.get('spawn_timestamp')}")
        
        # 1. Create new window via Shell
        child_win = shell.spawn_window(title="_theCELL [Child]", geometry="900x700")
        
        # 2. Initialize a fresh Backend with a UNIQUE memory path
        # This ensures the child's short-term memory doesn't overwrite the parent's.
        unique_session_id = f"session_{uuid.uuid4().hex[:8]}.jsonl"
        child_backend = Backend(memory_path=unique_session_id)
        
        # 3. Create a new UI instance docked into the new window
        # We modify CELL_UI to accept a Toplevel as a 'shell' proxy or just a container.
        # For this patch, we assume CELL_UI can take a container if we slightly tweak it, 
        # or we just pass the shell and let it pack into the child_win if we modify the UI class.
        # SIMPLIFICATION: We assume the shell proxy works.
        
        # To make this work cleanly without rewriting UI completely, we can create a 
        # 'ShellProxy' that mimics the shell but returns the child_win as the container.
        class ShellProxy:
            def __init__(self, root, colors):
                self.root = root
                self.colors = colors
            def get_main_container(self):
                return self.root
        
        child_proxy = ShellProxy(child_win, shell.colors)
        child_ui = CELL_UI(child_proxy, child_backend)
        
        # 4. Pre-load the Artifact (The 'DNA')
        source = data.get('source_artifact', {})
        payload = source.get('payload', '')
        # Ingest the payload into the child's input box
        child_ui.input_box.insert("1.0", payload)
        # Inherit system prompt
        child_ui.prompt_text.delete("1.0", "end")
        child_ui.prompt_text.insert("1.0", source.get('instructions', {}).get('system_prompt', ''))

    # Register the spawner
    backend.bus.subscribe("cell_spawn_requested", on_spawn_request)
    
    # Ignition
    shell.launch()

if __name__ == "__main__":
    main()




--------------------------------------------------------------------------------
FILE: src\backend.py
--------------------------------------------------------------------------------
import sqlite3
import os
import json
import logging
import threading
from datetime import datetime
from typing import List, Dict, Optional, Any, Tuple
from src.microservices._IngestEngineMS import IngestEngineMS
from src.microservices._FeedbackValidationMS import FeedbackValidationMS
from src.microservices._SignalBusMS import SignalBusMS
from src.microservices._CognitiveMemoryMS import CognitiveMemoryMS
from src.microservices._HydrationFactoryMS import HydrationFactoryMS
from src.microservices._ErrorNotifierMS import ErrorNotifierMS
from src.microservices._ConfigStoreMS import ConfigStoreMS
from src.microservices._CodeFormatterMS import CodeFormatterMS
from src.microservices._TreeMapperMS import TreeMapperMS
from src.microservices._VectorFactoryMS import VectorFactoryMS
from src.microservices.microservice_std_lib import service_metadata

class Backend:
    """
    ROLE: Orchestration / Logic Hub
    SERVICES: Ingest, Validation, SignalBus, Memory, Factory, Notifier, ConfigStore
    STATE: Persistent (SQLite / JSON)
    """
    def __init__(self, db_path: str = None, memory_path: str = None):
        # BOOTSTRAP: Define persistence paths
        project_root = os.path.abspath(os.getcwd())
        db_dir = os.path.join(project_root, "_db")
        os.makedirs(db_dir, exist_ok=True)

        if db_path is None:
            db_path = os.path.join(db_dir, "app_internal.db")

        self.db_path = db_path
        self.logger = logging.getLogger(self.__class__.__name__)
        self._init_db()

        self.engine = IngestEngineMS()
        self.validator = FeedbackValidationMS()
        self.bus = SignalBusMS()
        self.notifier = ErrorNotifierMS(self.bus)
        self.config_store = ConfigStoreMS()

        # BOOTSTRAP: Initialize Specialists (orchestration-owned)
        self.formatter = CodeFormatterMS()
        self.mapper = TreeMapperMS()
        self.vector_factory = VectorFactoryMS()

        # DI: Package and inject services into the Fabricator
        specialists = {
            'formatter': self.formatter,
            'mapper': self.mapper,
            'vector_factory': self.vector_factory,
            'ingest_engine': self.engine
        }
        self.factory = HydrationFactoryMS(services=specialists)
        
        # Configure memory with Long-Term flush capability (Phase 7)
        mem_config = {
             'persistence_path': memory_path,
            'summarizer_func': self._summarize_memory_stub, 
            'long_term_ingest_func': self._flush_to_vector_db
        } if memory_path else {
            'summarizer_func': self._summarize_memory_stub,
            'long_term_ingest_func': self._flush_to_vector_db
        }
        self.memory = CognitiveMemoryMS(config=mem_config)
        
        # Initialize state from persistent storage
        self.system_role: str = self.get_setting('last_system_role') or "You are a helpful AI assistant."

    def get_models(self):
        """Fetches available Ollama models."""
        models = self.engine.get_available_models()
        return models if models else ["No Models Found"]

    def set_system_role(self, role_text: str) -> None:
        self.system_role = role_text
        self.save_setting('last_system_role', role_text)

    def _init_db(self) -> None:
        # TASK: Schema Initialization
        # SCOPE: Personas, Roles, Prompts
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.executescript("""
                    -- SECTION: IDENTITY REPOSITORIES --
                    CREATE TABLE IF NOT EXISTS personas (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT UNIQUE,
                        role_text TEXT,
                        sys_prompt_text TEXT,
                        task_prompt_text TEXT,
                        is_default INTEGER DEFAULT 0,
                        last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                    CREATE TABLE IF NOT EXISTS saved_roles (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                    CREATE TABLE IF NOT EXISTS saved_sys_prompts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                    CREATE TABLE IF NOT EXISTS saved_task_prompts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, content TEXT, is_default INTEGER DEFAULT 0);
                """)

                # --- Lightweight migration for existing DBs ---
                # If the DB already existed, the personas table may be missing columns.
                try:
                    cols = {row[1] for row in conn.execute("PRAGMA table_info(personas)").fetchall()}
                    if 'task_prompt_text' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN task_prompt_text TEXT")
                    if 'last_modified' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
                    if 'is_default' not in cols:
                        conn.execute("ALTER TABLE personas ADD COLUMN is_default INTEGER DEFAULT 0")
                except sqlite3.Error as mig_e:
                    self.logger.error(f"Personas migration failed: {mig_e}")

        except sqlite3.Error as e:
            self.logger.error(f"Database initialization failed: {e}")

    def save_setting(self, key: str, value: Any) -> None:
        self.config_store.set(key, value)

    def get_setting(self, key: str) -> Optional[Any]:
        return self.config_store.get(key)

    def save_persona(self, name: str, role: str, sys_prompt: str, task_prompt: str = "", is_default: bool = False) -> bool:
        """Persist or update a bonded AI Persona template."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if is_default:
                    conn.execute("UPDATE personas SET is_default = 0")

                # Use UPSERT so we UPDATE in-place on name collisions instead of DELETE+INSERT (OR REPLACE)
                conn.execute(
                    """
                    INSERT INTO personas (name, role_text, sys_prompt_text, task_prompt_text, is_default, last_modified)
                    VALUES (?, ?, ?, ?, ?, ?)
                    ON CONFLICT(name) DO UPDATE SET
                        role_text=excluded.role_text,
                        sys_prompt_text=excluded.sys_prompt_text,
                        task_prompt_text=excluded.task_prompt_text,
                        is_default=excluded.is_default,
                        last_modified=excluded.last_modified
                    """,
                    (name, role, sys_prompt, task_prompt, 1 if is_default else 0, datetime.now().isoformat())
                )
            return True
        except sqlite3.Error as e:
            self.logger.error(f"Failed to save persona '{name}': {e}")
            return False

    def get_default_item(self, table_name: str) -> Optional[str]:
        """Retrieves the content of the item flagged as default for a given table."""
        with sqlite3.connect(self.db_path) as conn:
            col = "role_text" if table_name == 'personas' else "content"
            res = conn.execute(f"SELECT {col} FROM {table_name} WHERE is_default = 1").fetchone()
            return res[0] if res else None

    def get_repository_items(self, table_name: str) -> List[Tuple[int, str, str, int]]:
        """Generic fetch for any repository table including default flag."""
        valid_tables = ['saved_roles', 'saved_sys_prompts', 'saved_task_prompts', 'personas']
        if table_name not in valid_tables: return []
        
        with sqlite3.connect(self.db_path) as conn:
            # Personas uses role_text for the 'Preview' column
            if table_name == 'personas':
                return conn.execute("SELECT id, name, role_text, is_default FROM personas ORDER BY name ASC").fetchall()
            return conn.execute(f"SELECT id, name, content, is_default FROM {table_name} ORDER BY name ASC").fetchall()

    def save_repository_item(self, table_name: str, name: str, content: str, is_default: bool = False) -> bool:
        """Universal save for modular instruction fragments with default enforcement."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if is_default:
                    conn.execute(f"UPDATE {table_name} SET is_default = 0")
                conn.execute(f"INSERT OR REPLACE INTO {table_name} (name, content, is_default) VALUES (?, ?, ?)", 
                             (name, content, 1 if is_default else 0))
            return True
        except sqlite3.Error as e:
            self.logger.error(f"Repo save failed for {table_name}: {e}")
            return False

    def set_as_default(self, table_name: str, item_id: int) -> None:
        """Sets a specific item as the default for its repository."""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(f"UPDATE {table_name} SET is_default = 0")
            conn.execute(f"UPDATE {table_name} SET is_default = 1 WHERE id = ?", (item_id,))

    def delete_repository_item(self, table_name: str, item_id: int) -> bool:
        """Generic delete for any repository table."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(f"DELETE FROM {table_name} WHERE id = ?", (item_id,))
            return True
        except sqlite3.Error: return False

    def process_submission(self, content: str, model: str, role: str, prompt: str) -> Dict[str, Any]:
        # ACTION: Generate Artifact -> Start Threaded Inference
        # INPUTS: content (raw), model (ID), role (text), prompt (text)
        artifact = {
            "metadata": {
                "model": model,
                "timestamp": datetime.now().isoformat(),
                "source": "_theCELL_Idea_Ingestor",
                "version": "1.0.0"
            },
            "instructions": {
                "system_role": role,
                "system_prompt": prompt
            },
            "payload": content.strip()
        }

        # Add User Input to Working Memory
        self.memory.add_entry(role="user", content=content, metadata=artifact['metadata'])

        self.logger.info(f"Artifact generated for model: {model}")
        self.bus.emit(SignalBusMS.SIGNAL_PROCESS_START, artifact)

        # The Pulse: Start Threaded Inference
        thread = threading.Thread(target=self._run_inference_thread, args=(artifact,))
        thread.daemon = True
        thread.start()

        return artifact

    def _run_inference_thread(self, artifact: Dict[str, Any]):
        """
        Background worker that streams tokens from the Engine to the SignalBus.
        """
        try:
            model = artifact['metadata']['model']
            sys_role = artifact['instructions']['system_role']
            sys_prompt = artifact['instructions']['system_prompt']
            user_payload = artifact['payload']

            # Combine role/prompt context
            full_system = f"{sys_role}\n{sys_prompt}".strip()

            response_buffer = []
            
            # Connect to IngestEngine stream
            stream = self.engine.generate_stream(prompt=user_payload, model=model, system=full_system)
            
            for token in stream:
                # Emit token to UI
                self.bus.emit(SignalBusMS.SIGNAL_LOG_APPEND, token)
                response_buffer.append(token)

            final_response = "".join(response_buffer)
            
            # Hydrate artifact with result
            artifact['response'] = final_response
            
            # Add AI Response to Working Memory
            self.memory.add_entry(role="assistant", content=final_response, metadata=artifact['metadata'])

            # Signal Completion (UI triggers HITL buttons)
            self.bus.emit(SignalBusMS.SIGNAL_PROCESS_COMPLETE, artifact)

        except Exception as e:
            error_msg = f"Inference failed: {str(e)}"
            self.logger.error(error_msg)
            self.bus.emit(SignalBusMS.SIGNAL_LOG_APPEND, f"\n[SYSTEM ERROR]: {error_msg}")

    def spawn_child(self, parent_artifact: Dict[str, Any]) -> None:
        """
        Prepares a new Cell by combining the parent's product with the current memory context,
        then emits a signal requesting the UI to launch the new window.
        """
        # 1. Summarize Parent Context (The Hippocampus)
        context_summary = self.memory.get_context(limit=10)
        
        # 2. Create Child DNA
        child_payload = {
            "source_artifact": parent_artifact,
            "inherited_context": context_summary,
            "spawn_timestamp": datetime.now().isoformat()
        }

        self.logger.info("Spawning child cell requested...")
        
        # 3. Signal the System (AppShell) to launch the GUI
        self.bus.emit(SignalBusMS.SIGNAL_SPAWN_REQUESTED, child_payload)

    # --- INTEGRATION: Hydration & Export ---
    def export_artifact(self, artifact: Dict[str, Any], destination: str, path: str = None) -> Dict[str, Any]:
        # ROLE: Factory Router
        # MODES: scaffold, memory, blueprint
        try:
            mode_map = {"File": "scaffold", "Vector": "memory", "Project Capture": "blueprint"}
            mode = mode_map.get(destination, "scaffold")
            
            # If Vector, we assume a default collection if not specified
            target = path if path else ("cell_memory_bank" if destination == "Vector" else "export.txt")
            
            return self.factory.hydrate_artifact(artifact, mode=mode, destination=target)
        except Exception as e:
            self.bus.emit(SignalBusMS.SIGNAL_ERROR, {"message": f"Export failed: {str(e)}", "level": "ERROR"})
            return {"status": "error", "message": str(e)}

    # --- Phase 5: Feedback Loop ---
    def record_feedback(self, artifact: Dict[str, Any], is_accepted: bool) -> None:
        """Submits the turn to the FeedbackValidator for training."""
        self.validator.validate_artifact(artifact, is_accepted)

    # --- Phase 7: Long-Term Memory Helpers ---
    def _summarize_memory_stub(self, text: str) -> str:
        """Simple truncation summarizer. Ideally uses an LLM call."""
        return f"Session Summary [{datetime.now().isoformat()}]: {text[:200]}..."

    def _flush_to_vector_db(self, text: str, metadata: Dict[str, Any]) -> None:
        """Callback for CognitiveMemory to save flushed context to Vector Store."""
        artifact = {
            "payload": text,
            "metadata": metadata
        }
        # We use the factory to 'hydrate' this into the memory bank
        self.factory.hydrate_artifact(artifact, mode="memory", destination="long_term_history")



















--------------------------------------------------------------------------------
FILE: src\ui.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import sqlite3

class CellViewerModal(tk.Toplevel):
    """Reusable DB browser for instruction repositories."""
    def __init__(self, parent, colors, table_name, backend, on_select_callback):
        super().__init__(parent)
        self.title(f"Browse: {table_name.replace('_', ' ').title()}")
        self.geometry("600x400")
        self.configure(bg=colors.get('background'))
        self.backend = backend
        self.table_name = table_name
        self.callback = on_select_callback

        # Treeview for Tabular Data
        style = ttk.Style()
        style.configure(
            "Treeview",
            background=colors.get('entry_bg', colors.get('panel_bg')),
            foreground=colors.get('entry_fg', colors.get('foreground')),
            fieldbackground=colors.get('entry_bg', colors.get('panel_bg')),
            borderwidth=0
        )
        style.configure(
            "Treeview.Heading",
            background=colors.get('heading_bg', colors.get('panel_bg')),
            foreground=colors.get('heading_fg', colors.get('foreground'))
        )
        style.map(
            "Treeview",
            background=[('selected', colors.get('select_bg', colors.get('accent')))],
            foreground=[('selected', colors.get('select_fg', colors.get('entry_fg', colors.get('foreground'))))]
        )
        self.tree = ttk.Treeview(self, columns=("ID", "Name", "Preview", "Default"), show='headings')
        
        for col in ("ID", "Name", "Preview", "Default"): 
            self.tree.heading(col, text=col)
            self.tree.column(col, width=50 if col in ('ID', 'Default') else 150 if col == 'Name' else 250)
        
        self.tree.pack(fill='both', expand=True, padx=10, pady=10)
        self._refresh_data()

        # Subscribe to theme updates
        if hasattr(self.backend, 'bus'):
            self.backend.bus.subscribe("theme_updated", self.refresh_theme)

        self.btn_frame = tk.Frame(self, bg=colors.get('background'))
        self.btn_frame.pack(fill='x', padx=10, pady=5)
        
        btn_opts = {
            "bg": colors.get('panel_bg', colors.get('background')),
            "fg": colors.get('button_fg', colors.get('foreground')),
            "relief": "flat"
        }
        tk.Button(self.btn_frame, text="Load Selection", command=self._on_load, **btn_opts).pack(side='left', padx=5)
        tk.Button(self.btn_frame, text="Set as Default", command=self._on_default, **btn_opts).pack(side='left', padx=5)
        tk.Button(
            self.btn_frame,
            text="Delete",
            bg=colors.get('error', colors.get('accent')),
            fg=colors.get('button_fg', colors.get('foreground')),
            relief="flat",
            command=self._on_delete
        ).pack(side='right', padx=5)

    def _refresh_data(self):
        self.tree.delete(*self.tree.get_children())
        for item in self.backend.get_repository_items(self.table_name):
            # item = (id, name, content, is_default)
            self.tree.insert("", "end", values=(item[0], item[1], item[2][:100].replace('\n', ' '), "â˜…" if item[3] else ""))

    def _on_load(self):
        selected = self.tree.selection()
        if selected:
            item_values = self.tree.item(selected[0], 'values')
            with sqlite3.connect(self.backend.db_path) as conn:
                if self.table_name == 'personas':
                    # Bonded Template: Returns a tuple for the callback to handle
                    res = conn.execute("SELECT role_text, sys_prompt_text, task_prompt_text FROM personas WHERE id=?", (item_values[0],)).fetchone()
                    if res: self.callback(res) 
                else:
                    # Atomic Fragment
                    res = conn.execute(f"SELECT content FROM {self.table_name} WHERE id=?", (item_values[0],)).fetchone()
                    if res: self.callback(res[0])
            self.destroy()

    def _on_default(self):
        selected = self.tree.selection()
        if selected:
            item_id = self.tree.item(selected[0], 'values')[0]
            self.backend.set_as_default(self.table_name, item_id)
            self._refresh_data()

    def _on_delete(self):
        selected = self.tree.selection()
        if selected:
            item_id = self.tree.item(selected[0], 'values')[0]
            self.backend.delete_repository_item(self.table_name, item_id)
            self._refresh_data()

    def refresh_theme(self, new_colors):
        self.configure(bg=new_colors.get('background'))
        self.btn_frame.configure(bg=new_colors.get('background'))
        style = ttk.Style()
        style.configure(
            "Treeview",
            background=new_colors.get('entry_bg', new_colors.get('panel_bg')),
            foreground=new_colors.get('entry_fg', new_colors.get('foreground')),
            fieldbackground=new_colors.get('entry_bg', new_colors.get('panel_bg'))
        )
        style.configure(
            "Treeview.Heading",
            background=new_colors.get('heading_bg', new_colors.get('panel_bg')),
            foreground=new_colors.get('heading_fg', new_colors.get('foreground'))
        )

class CELL_UI:
    def __init__(self, shell, backend):
        self.shell = shell
        self.backend = backend
        self.container = shell.get_main_container()
        self.colors = shell.colors

        # Track singleton modals / key widgets
        self._settings_window = None
        self.model_lbl = None
        self.btn_save_template = None
        self.btn_load_template = None
        self.btn_submit = None

        # Panels (Step 2 stubs)
        self.panel_prompt = None
        self.panel_inference = None
        self.panel_result = None
        self.panel_export = None

        # Two-column layout containers (Step 1 layout)
        self.main_row = None
        self.left_col = None
        self.right_col = None

        # Action bar ref (so it can be themed)
        self.action_frame = None

        # Panel widgets (stubs)
        self.infer_log = None
        self.result_text = None
        self.btn_accept = None
        self.btn_reject = None
        self.btn_exit = None

        # Export Router (inline) widgets
        self.export_router_frame = None
        self.export_dest_var = None
        self.export_dest_cb = None
        self.export_options_frame = None
        self.export_execute_btn = None
        self._export_selected = None
        
        # Restore window state from DB
        saved_geo = self.backend.get_setting('window_geometry')
        if saved_geo: self.shell.root.geometry(saved_geo)
        
        self._setup_main_window()
        self._build_context_menu()
        self._restore_component_state()
        self._register_signals()

    def _register_signals(self):
        """Connects UI to the nervous system."""
        if hasattr(self.backend, 'bus'):
            self.backend.bus.subscribe("log_append", self._on_log_append)
            self.backend.bus.subscribe("process_complete", self._on_process_complete)
            # Pass the new palette through so ttk/tk widgets can rebind safely.
            self.backend.bus.subscribe("theme_updated", self.refresh_theme)

    def _on_log_append(self, content):
        """Marshals background thread signal to main UI thread."""
        self.shell.root.after(0, lambda: self.append_log(content))

    def _on_process_complete(self, artifact):
        """Marshals completion signal to main UI thread."""
        text = artifact.get('response', '')
        self.shell.root.after(0, lambda: self.display_result(text))

    def _setup_main_window(self):
        # PANEL 1 (Prompt Setup): left column
        # Panels 2-4 (Inference / HITL / Export): right column
        self.main_row = tk.Frame(self.container, bg=self.colors.get('background'))
        self.main_row.pack(fill='both', expand=True)

        self.left_col = tk.Frame(self.main_row, bg=self.colors.get('background'))
        self.left_col.pack(side='left', fill='both', expand=True)

        self.right_col = tk.Frame(self.main_row, bg=self.colors.get('background'))
        self.right_col.pack(side='right', fill='y', padx=(8, 0))

        # PANEL 1 (Prompt Setup)
        self.panel_prompt = tk.Frame(self.container, bg=self.colors.get('background'))
        self.panel_prompt.pack(in_=self.left_col, fill='both', expand=True)

        # --- Top Label ---
        self.top_label = tk.Label(self.panel_prompt, text="Type in your idea HERE.", 
                 fg=self.colors.get('foreground'), bg=self.colors.get('background'),
                 font=("Segoe UI", 12, "bold"))
        self.top_label.pack(pady=(10, 5))

        # --- Formatting Toolbar ---
        self.toolbar = tk.Frame(self.panel_prompt, bg=self.colors.get('panel_bg'))
        self.toolbar.pack(fill='x', padx=10)
        
        btn_opts = {"bg": self.colors.get('panel_bg'), "fg": self.colors.get('foreground', 'white'), "relief": "flat", "padx": 5}
        self.btn_bold = tk.Button(self.toolbar, text="B", font=("TkDefaultFont", 9, "bold"), **btn_opts, command=self._bold_text)
        self.btn_bold.pack(side='left')
        self.btn_italic = tk.Button(self.toolbar, text="I", font=("TkDefaultFont", 9, "italic"), **btn_opts, command=self._italic_text)
        self.btn_italic.pack(side='left')
        self.btn_list = tk.Button(self.toolbar, text="â€¢ List", **btn_opts, command=self._bullet_list)
        self.btn_list.pack(side='left')
        
        self.btn_settings = tk.Button(self.toolbar, text="âš™", **btn_opts, command=self._open_settings)
        self.btn_settings.pack(side='right')

        # --- Inference Config Section ---
        self.config_frame = tk.LabelFrame(self.panel_prompt, text=" Inference Parameters ", 
                                     fg=self.colors.get('foreground'), bg=self.colors.get('background'),
                                     relief='solid', bd=1, font=("Segoe UI", 9, "bold"))
        self.config_frame.pack(fill='x', padx=10, pady=10)

        # Model Selection
        self.model_lbl = tk.Label(self.config_frame, text="Model:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.model_lbl.grid(row=0, column=0, sticky='w', padx=5)
        self.model_var = tk.StringVar()
        self.model_dropdown = ttk.Combobox(self.config_frame, textvariable=self.model_var)
        self.model_dropdown['values'] = self.backend.get_models()
        self.model_dropdown.grid(row=0, column=1, sticky='ew', padx=5, pady=2)
        
        # Direct Role Input
        self.role_lbl = tk.Label(self.config_frame, text="System Role:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.role_lbl.grid(row=1, column=0, sticky='w', padx=5)
        self.role_inner = tk.Frame(self.config_frame, bg=self.colors.get('background'))
        self.role_inner.grid(row=1, column=1, sticky='ew')
        
        self.role_entry = tk.Entry(
            self.role_inner,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
        )
        self.role_entry.insert(0, self.backend.system_role)
        self.role_entry.pack(side='left', fill='x', expand=True, padx=(5, 2), pady=2)
        
        self.btn_role_save = tk.Button(self.role_inner, text="ðŸ’¾", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._save_repo_dialog('saved_roles', self.role_entry.get()))
        self.btn_role_save.pack(side='left', padx=2)
        self.btn_role_open = tk.Button(self.role_inner, text="ðŸ“‚", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._open_viewer('saved_roles', lambda c: self._update_widget(self.role_entry, c)))
        self.btn_role_open.pack(side='left', padx=2)

        # Direct Prompt Input
        self.prompt_lbl = tk.Label(self.config_frame, text="System Prompt:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        self.prompt_lbl.grid(row=2, column=0, sticky='nw', padx=5)
        self.prompt_inner = tk.Frame(self.config_frame, bg=self.colors.get('background'))
        self.prompt_inner.grid(row=2, column=1, sticky='ew')
        
        self.prompt_text = tk.Text(
            self.prompt_inner,
            height=3,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Segoe UI", 9)
        )
        self.prompt_text.pack(side='left', fill='x', expand=True, padx=(5, 2), pady=2)
        
        self.prompt_btns_frame = tk.Frame(self.prompt_inner, bg=self.colors.get('background'))
        self.prompt_btns_frame.pack(side='left', fill='y')
        self.btn_prompt_save = tk.Button(self.prompt_btns_frame, text="ðŸ’¾", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._save_repo_dialog('saved_sys_prompts', self.prompt_text.get('1.0', 'end-1c')))
        self.btn_prompt_save.pack(pady=2)
        self.btn_prompt_open = tk.Button(self.prompt_btns_frame, text="ðŸ“‚", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')), relief="flat", 
                  command=lambda: self._open_viewer('saved_sys_prompts', lambda c: self._update_widget(self.prompt_text, c)))
        self.btn_prompt_open.pack(pady=2)

        self.config_frame.columnconfigure(1, weight=1)

        # --- Main Input Box ---
        self.input_box = tk.Text(
            self.panel_prompt,
            undo=True,
            wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            selectbackground=self.colors.get('select_bg', self.colors.get('accent')),
            font=("Consolas", 11)
        )
        self.input_box.pack(fill='both', expand=True, padx=10, pady=5)
        self.input_box.focus_set()

        # --- Action Bar ---
        self.action_frame = tk.Frame(self.panel_prompt, bg=self.colors.get('background'))
        self.action_frame.pack(fill='x', padx=10, pady=(0, 10))

        self.btn_save_template = tk.Button(
            self.action_frame,
            text="SAVE AS TEMPLATE",
            bg=self.colors.get('panel_bg'),
            fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')),
            font=("Segoe UI", 9),
            command=self._save_full_template
        )
        self.btn_save_template.pack(side='left', fill='x', expand=True, padx=(0, 2))

        self.btn_load_template = tk.Button(
            self.action_frame,
            text="LOAD TEMPLATE",
            bg=self.colors.get('panel_bg'),
            fg=self.colors.get('button_fg', self.colors.get('foreground', 'white')),
            font=("Segoe UI", 9),
            command=lambda: self._open_viewer('personas', None)
        )
        self.btn_load_template.pack(side='left', fill='x', expand=True, padx=(2, 5))

        self.btn_submit = tk.Button(
            self.action_frame,
            text="RUN CELL",
            bg=self.colors.get('accent'),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            font=("Segoe UI", 10, "bold"),
            command=self._submit
        )
        self.btn_submit.pack(side='left', fill='x', expand=True)

        # ------------------------------------------------------------------
        # PANEL 2 â€” Inference Console
        # ------------------------------------------------------------------
        self.panel_inference = tk.LabelFrame(
            self.container,
            text=" Inference Console ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_inference.pack(in_=self.right_col, fill='x', padx=10, pady=(0, 10))

        self.infer_log = tk.Text(
            self.panel_inference,
            height=6,
            wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Consolas", 10)
        )
        self.infer_log.insert('1.0', "[Stub] Inference logs will stream here during the run.\n")
        self.infer_log.configure(state='disabled')
        self.infer_log.pack(fill='x', expand=False, padx=10, pady=8)

        # ------------------------------------------------------------------
        # PANEL 3 â€” Result + HITL
        # ------------------------------------------------------------------
        self.panel_result = tk.LabelFrame(
            self.container,
            text=" Result + HITL ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_result.pack(in_=self.right_col, fill='both', expand=True, padx=10, pady=(0, 10))

        self.result_text = tk.Text(
            self.panel_result,
            height=8,
            wrap="word",
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            font=("Consolas", 11)
        )
        self.result_text.insert('1.0', "[Stub] Model response will appear here.\n")
        self.result_text.configure(state='disabled')
        self.result_text.pack(fill='both', expand=True, padx=10, pady=(8, 6))

        hitl_bar = tk.Frame(self.panel_result, bg=self.colors.get('background'))
        hitl_bar.pack(fill='x', padx=10, pady=(0, 10))

        self.btn_accept = tk.Button(
            hitl_bar,
            text="ACCEPT",
            bg=self.colors.get('accent'),
            fg=self.colors.get('button_fg', 'white'),
            relief="flat",
            state='disabled',
            command=self._on_accept
        )
        self.btn_accept.pack(side='left', padx=(0, 6))

        self.btn_reject = tk.Button(
            hitl_bar,
            text="REJECT & EDIT",
            bg=self.colors.get('button_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            relief="flat",
            state='disabled',
            command=self._on_reject
        )
        self.btn_reject.pack(side='left', padx=(0, 6))

        self.btn_exit = tk.Button(
            hitl_bar,
            text="EXIT CELL",
            bg=self.colors.get('button_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('button_fg', self.colors.get('foreground')),
            relief="flat",
            command=self.shell.root.destroy
        )
        self.btn_exit.pack(side='right')

        # PANEL 4 â€” Export / Spawn (inline router)
        self.panel_export = tk.LabelFrame(
            self.container,
            text=" Export / Spawn ",
            fg=self.colors.get('foreground'),
            bg=self.colors.get('background'),
            relief='solid', bd=1, font=("Segoe UI", 9, "bold")
        )
        self.panel_export.pack(in_=self.right_col, fill='x', padx=10, pady=(0, 12))

        self.export_router_frame = tk.Frame(self.panel_export, bg=self.colors.get('background'))
        self.export_router_frame.pack(fill='x', padx=10, pady=10)

        top_row = tk.Frame(self.export_router_frame, bg=self.colors.get('background'))
        top_row.pack(fill='x')

        tk.Label(top_row, text="Destination:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white')).pack(side='left')

        self.export_dest_var = tk.StringVar(value="Spawn")
        self.export_dest_cb = ttk.Combobox(
            top_row, 
            textvariable=self.export_dest_var, 
            state='readonly', 
            values=["Spawn", "File", "Database", "Vector", "Code", "Patch", "Logs"]
        )
        self.export_dest_cb.pack(side='left', padx=8, fill='x', expand=True)

        self.export_execute_btn = tk.Button(
            top_row, text="EXECUTE", 
            bg=self.colors.get('accent'),
            fg=self.colors.get('button_fg', 'white'),
            relief="flat", state='disabled', command=self._handle_export
        )
        self.export_execute_btn.pack(side='right')

        self.export_options_frame = tk.Frame(self.export_router_frame, bg=self.colors.get('background'))
        self.export_options_frame.pack(fill='x', pady=(8, 0))

    def _build_export_options(dest: str):
        for w in self.export_options_frame.winfo_children(): w.destroy()
        if dest == "Spawn":
            tk.Button(self.export_options_frame, text="Spawn Child Cell", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground')), relief='flat', state='disabled').pack(fill='x', pady=2)
        elif dest == "File":
            for fmt in ("JSON", "Markdown", "Text"):
                tk.Button(self.export_options_frame, text=f"Save {fmt}", bg=self.colors.get('panel_bg'), fg=self.colors.get('button_fg', self.colors.get('foreground')), relief='flat', state='disabled').pack(fill='x', pady=2)

        self.export_dest_cb.bind('<<ComboboxSelected>>', lambda _e: _build_export_options(self.export_dest_var.get()))
        _build_export_options("Spawn")

    def _get_current_artifact(self):
        """Helper to package UI state into a standard artifact."""
        return {
            "payload": self.result_text.get("1.0", "end-1c"),
            "instructions": {
                "system_role": self.role_entry.get(),
                "system_prompt": self.prompt_text.get("1.0", "end-1c")
            },
            "metadata": {"model": self.model_var.get(), "source": "ui_action"}
        }

    def _handle_export(self):
        """Routes the execution command based on the selected destination."""
        dest = self.export_dest_var.get()
        artifact = self._get_current_artifact()

        if dest == "Spawn":
            self.backend.spawn_child(artifact)
        elif dest == "File":
            path = filedialog.asksaveasfilename(defaultextension=".txt", parent=self.shell.root)
            if path:
                self.backend.export_artifact(artifact, "File", path)
        elif dest == "Vector":
            # Save to default long-term memory bank
            self.backend.export_artifact(artifact, "Vector")
            messagebox.showinfo("Memory", "Artifact embedded into Vector Store.", parent=self.shell.root)
        else:
            messagebox.showinfo("Not Implemented", f"Export to {dest} is coming soon!", parent=self.shell.root)

    def _on_accept(self):
        """HITL: User approves the result."""
        artifact = self._get_current_artifact()
        self.backend.record_feedback(artifact, is_accepted=True)
        self.btn_accept.configure(state='disabled', text="ACCEPTED")
        self.btn_reject.configure(state='disabled')

    def _on_reject(self):
        """HITL: User rejects. Unlock input for editing."""
        artifact = self._get_current_artifact()
        self.backend.record_feedback(artifact, is_accepted=False)
        
        # Move result back to input box for refinement
        rejected_content = self.result_text.get("1.0", "end-1c")
        self.input_box.delete("1.0", "end")
        self.input_box.insert("1.0", rejected_content)
        
        # Reset UI state
        self.result_text.configure(state='normal')
        self.result_text.delete("1.0", "end")
        self.result_text.insert("1.0", "[Drafting refinement...]")
        self.result_text.configure(state='disabled')
        
        self.btn_accept.configure(state='disabled')
        self.btn_reject.configure(state='disabled')
        self.input_box.focus_set()

    def _apply_markdown_style(self, prefix, suffix=""):
        """Wraps selected text in Markdown markers for AI readability."""
        try:
            start = self.input_box.index("sel.first")
            end = self.input_box.index("sel.second")
            selected_text = self.input_box.get(start, end)
            self.input_box.delete(start, end)
            self.input_box.insert(start, f"{prefix}{selected_text}{suffix or prefix}")
        except tk.TclError:
            pass

    def _bold_text(self):
        self._apply_markdown_style("**")

    def _italic_text(self):
        self._apply_markdown_style("_")

    def _bullet_list(self):
        """Converts selected lines into a Markdown bulleted list."""
        try:
            start = self.input_box.index("sel.first linestart")
            end = self.input_box.index("sel.second lineend")
            lines = self.input_box.get(start, end).splitlines()
            bulleted_lines = [f"* {line.lstrip('* ')}" for line in lines]
            self.input_box.delete(start, end)
            self.input_box.insert(start, "\n".join(bulleted_lines))
        except tk.TclError:
            self.input_box.insert("insert", "* ")

    def _update_widget(self, widget, content):
        if isinstance(widget, tk.Entry):
            widget.delete(0, 'end')
            widget.insert(0, content)
        elif isinstance(widget, tk.Text):
            # Ensure widget is editable before update
            original_state = widget.cget('state')
            widget.configure(state='normal')
            widget.delete('1.0', 'end')
            widget.insert('1.0', content)
            # Only lock it back if it was originally disabled (e.g. logs), otherwise leave editable
            if original_state == 'disabled':
                widget.configure(state='disabled')

    def append_log(self, message: str):
        """Appends text to the inference console (Thread-Safe via _on_log_append)."""
        if self.infer_log is None: return
        self.infer_log.configure(state='normal')
        self.infer_log.insert('end', message) # Streamed tokens don't force newlines
        self.infer_log.see('end')
        self.infer_log.configure(state='disabled')

    def display_result(self, text: str):
        """Displays the final artifact and enables HITL buttons."""
        self.result_text.configure(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', text)
        self.result_text.configure(state='disabled')
        
        if self.btn_accept:
            self.btn_accept.configure(state='normal')
        if self.btn_reject:
            self.btn_reject.configure(state='normal')
        if self.export_execute_btn:
            self.export_execute_btn.configure(state='normal')

    def _save_repo_dialog(self, table, content):
        """Modular save dialog for individual repositories."""
        dialog = tk.Toplevel(self.shell.root)
        dialog.title(f"Save to {table.split('_')[-1].title()}")
        dialog.geometry("300x150")
        dialog.configure(bg=self.colors.get('background'))

        dialog.transient(self.shell.root)
        dialog.grab_set()

        tk.Label(dialog, text="Name Selection:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white')).pack(pady=5)
        name_entry = tk.Entry(dialog)
        name_entry.pack(padx=10, fill='x')
        name_entry.focus_set()

        default_var = tk.BooleanVar()
        tk.Checkbutton(
            dialog,
            text="Set as Default",
            variable=default_var,
            bg=self.colors.get('background'),
            fg=self.colors.get('foreground', 'white'),
            selectcolor=self.colors.get('panel_bg', '#444')
        ).pack()

        def confirm():
            name = name_entry.get().strip()
            if not name:
                messagebox.showwarning("Missing name", "Please enter a name.", parent=dialog)
                return

            try:
                if table == 'personas':
                    success = self.backend.save_persona(name, content[0], content[1], content[2], default_var.get())
                else:
                    success = self.backend.save_repository_item(table, name, content, default_var.get())
            except Exception as e:
                messagebox.showerror("Save failed", f"Unexpected error: {e}", parent=dialog)
                return

            if success:
                messagebox.showinfo("Success", "Saved successfully!", parent=dialog)
                dialog.destroy()
            else:
                messagebox.showerror("Save failed", "Could not save. Check the app log for the SQLite error.", parent=dialog)

        btn_frame = tk.Frame(dialog, bg=self.colors.get('background'))
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="Save", width=10, command=confirm).pack(side='left', padx=5)
        tk.Button(btn_frame, text="Cancel", width=10, command=dialog.destroy).pack(side='left', padx=5)

        dialog.bind("<Return>", lambda _e: confirm())
        dialog.bind("<Escape>", lambda _e: dialog.destroy())

    def _open_viewer(self, table, callback):
        """Opens the Universal Cell Viewer Modal with context-aware callbacks."""
        if table == 'personas':
            def persona_callback(data):
                self._update_widget(self.role_entry, data[0])
                self._update_widget(self.prompt_text, data[1])
                self._update_widget(self.input_box, data[2])
            callback = persona_callback
            
        CellViewerModal(self.shell.root, self.colors, table, self.backend, callback)

    def _open_settings(self):
        # Enforce singleton Settings modal
        if self._settings_window is not None:
            try:
                if self._settings_window.winfo_exists():
                    self._settings_window.deiconify()
                    self._settings_window.lift()
                    self._settings_window.focus_force()
                    return
            except Exception:
                self._settings_window = None

        settings = tk.Toplevel(self.shell.root)
        self._settings_window = settings
        settings.title("Settings")
        settings.geometry("350x250")
        settings.configure(bg=self.colors.get('background'))

        def _close_settings():
            self._settings_window = None
            try:
                settings.destroy()
            except Exception:
                pass

        settings.protocol("WM_DELETE_WINDOW", _close_settings)

        # Load persisted theme (default Dark)
        current_theme = (self.backend.get_setting('theme_preference') or 'Dark').strip().title()
        if current_theme not in ('Dark', 'Light'):
            current_theme = 'Dark'

        # Theme Section
        lbl_theme = tk.Label(settings, text="Theme:", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        lbl_theme.pack(pady=(15, 2))
        
        theme_var = tk.StringVar(value=current_theme)
        theme_cb = ttk.Combobox(settings, textvariable=theme_var, values=["Dark", "Light"], state='readonly')
        theme_cb.pack(pady=2)

        # Geometry Section
        lbl_size = tk.Label(settings, text="Window Size (WxH):", bg=self.colors.get('background'), fg=self.colors.get('foreground', 'white'))
        lbl_size.pack(pady=(15, 2))
        
        size_entry = tk.Entry(
            settings,
            bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
            fg=self.colors.get('entry_fg', self.colors.get('foreground')),
            insertbackground=self.colors.get('entry_fg', self.colors.get('foreground')),
            relief="flat"
        )
        current_geo = self.shell.root.geometry().split('+')[0]
        size_entry.insert(0, current_geo)
        size_entry.pack(pady=2)

        btn_frame = tk.Frame(settings, bg=self.colors.get('background'))
        btn_frame.pack(side='bottom', fill='x', pady=20)

        def apply_changes():
            # 1. Apply Geometry
            new_geo = size_entry.get().strip()
            if new_geo:
                try:
                    self.shell.root.geometry(new_geo)
                    self.backend.save_setting('window_geometry', new_geo)
                except Exception:
                    pass # Ignore invalid geometry strings

            # 2. Apply Theme
            selected_theme = (theme_var.get() or 'Dark').strip().title()
            if selected_theme not in ('Dark', 'Light'):
                selected_theme = 'Dark'

            self.backend.save_setting('theme_preference', selected_theme)
            if hasattr(self.shell, 'set_theme'):
                self.shell.set_theme(selected_theme)
                self.colors = self.shell.colors
                self.refresh_theme()
                
                # Refresh settings window colors immediately (including entry/button surfaces)
                settings.configure(bg=self.colors.get('background'))
                lbl_theme.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                lbl_size.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                btn_frame.configure(bg=self.colors.get('background'))

                try:
                    size_entry.configure(
                        bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                        fg=self.colors.get('entry_fg', self.colors.get('foreground')),
                        insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
                    )
                except Exception:
                    pass

                # Theme all buttons we created in this window
                try:
                    for w in container.winfo_children():
                        if isinstance(w, tk.Button):
                            w.configure(
                                bg=self.colors.get('panel_bg'),
                                fg=self.colors.get('button_fg', self.colors.get('foreground')),
                                activebackground=self.colors.get('panel_bg'),
                                activeforeground=self.colors.get('button_fg', self.colors.get('foreground'))
                            )
                except Exception:
                    pass

                # Recursive cleanup pass: remove any lingering OS-default surfaces
                try:
                    def _walk(w):
                        for child in w.winfo_children():
                            try:
                                if isinstance(child, (tk.Frame, tk.LabelFrame, tk.Toplevel)):
                                    child.configure(bg=self.colors.get('background'))
                                elif isinstance(child, tk.Label):
                                    child.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                                elif isinstance(child, tk.Entry):
                                    child.configure(
                                        bg=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                                        fg=self.colors.get('entry_fg', self.colors.get('foreground')),
                                        insertbackground=self.colors.get('entry_fg', self.colors.get('foreground'))
                                    )
                                elif isinstance(child, tk.Button):
                                    child.configure(
                                        bg=self.colors.get('panel_bg'),
                                        fg=self.colors.get('button_fg', self.colors.get('foreground')),
                                        activebackground=self.colors.get('panel_bg'),
                                        activeforeground=self.colors.get('button_fg', self.colors.get('foreground'))
                                    )
                            except Exception:
                                pass
                            _walk(child)
                    _walk(settings)
                except Exception:
                    pass

        def on_ok():
            apply_changes()
            _close_settings()

        # Buttons: Apply | OK | Cancel
        # We use pack with side to center them or space them out
        container = tk.Frame(btn_frame, bg=self.colors.get('background'))
        container.pack(anchor='center')

        btn_opts = {
            "bg": self.colors.get('panel_bg'), 
            "fg": self.colors.get('button_fg', self.colors.get('foreground')),
            "relief": "flat",
            "width": 8
        }

        tk.Button(container, text="Apply", command=apply_changes, **btn_opts).pack(side='left', padx=5)
        tk.Button(container, text="OK", command=on_ok, **btn_opts).pack(side='left', padx=5)
        tk.Button(container, text="Cancel", command=_close_settings, **btn_opts).pack(side='left', padx=5)

    def _build_context_menu(self):
        self.menu = tk.Menu(self.input_box, tearoff=0)
        self.menu.add_command(label="Cut", command=lambda: self.input_box.event_generate("<<Cut>>"))
        self.menu.add_command(label="Copy", command=lambda: self.input_box.event_generate("<<Copy>>"))
        self.menu.add_command(label="Paste", command=lambda: self.input_box.event_generate("<<Paste>>"))
        self.input_box.bind("<Button-3>", lambda e: self.menu.post(e.x_root, e.y_root))

    def _save_full_template(self):
        """Captures the entire state of the config bar as a bonded Persona."""
        role = self.role_entry.get()
        sys_p = self.prompt_text.get("1.0", "end-1c")
        task_p = self.input_box.get("1.0", "end-1c")
        self._save_repo_dialog('personas', (role, sys_p, task_p))

    def _restore_component_state(self):
        """Restores components using Defaults first, then Session state."""
        default_role = self.backend.get_default_item('saved_roles')
        last_role = self.backend.get_setting('last_system_role')
        self._update_widget(self.role_entry, default_role or last_role or "")

        default_sys = self.backend.get_default_item('saved_sys_prompts')
        last_sys = self.backend.get_setting('last_system_prompt')
        self._update_widget(self.prompt_text, default_sys or last_sys or "")

        last_model = self.backend.get_setting('last_model')
        if last_model in self.model_dropdown['values']:
            self.model_var.set(last_model)

    def _submit(self):
        """Process submission, persist parameters, and update UI consoles."""
        content = self.input_box.get("1.0", "end-1c")
        model = self.model_var.get()
        role = self.role_entry.get()
        prompt = self.prompt_text.get("1.0", "end-1c")
        
        # Persist settings via backend
        self.backend.save_setting('last_model', model)
        self.backend.save_setting('last_system_role', role)
        self.backend.save_setting('last_system_prompt', prompt)

        # Prepare Inference Log
        self.infer_log.configure(state='normal')
        self.infer_log.delete('1.0', 'end')
        self.infer_log.insert('1.0', f"[System] Initiating run with {model}...\n")
        self.infer_log.configure(state='disabled')

        # Prepare Result Box
        self.result_text.configure(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', "Waiting for model response...\n")
        self.result_text.configure(state='disabled')
        
        # Trigger backend processing
        self.backend.process_submission(content, model, role, prompt)

    def refresh_theme(self, new_colors=None):
        """Re-applies the current theme to all primary UI widgets."""
        # Pull the newest palette. (If the shell swaps dict objects, this keeps us aligned.)
        self.colors = new_colors or self.shell.colors

        # Update Containers
        self.container.configure(bg=self.colors.get('background'))

        if self.main_row is not None:
            self.main_row.configure(bg=self.colors.get('background'))
        if self.left_col is not None:
            self.left_col.configure(bg=self.colors.get('background'))
        if self.right_col is not None:
            self.right_col.configure(bg=self.colors.get('background'))

        if self.panel_prompt is not None:
            self.panel_prompt.configure(bg=self.colors.get('background'))

        if self.action_frame is not None:
            self.action_frame.configure(bg=self.colors.get('background'))
        self.toolbar.configure(bg=self.colors.get('panel_bg'))
        self.config_frame.configure(fg=self.colors.get('foreground'), bg=self.colors.get('background'))
        self.role_inner.configure(bg=self.colors.get('background'))
        self.prompt_inner.configure(bg=self.colors.get('background'))
        self.prompt_btns_frame.configure(bg=self.colors.get('background'))

        if self.action_frame is not None:
            self.action_frame.configure(bg=self.colors.get('background'))

        # Right-column panels
        panel_list = [self.panel_inference, self.panel_result, self.panel_export]
        for panel in panel_list:
            if panel is not None:
                try:
                    panel.configure(
                        bg=self.colors.get('background'),
                        fg=self.colors.get('foreground'),
                        highlightbackground=self.colors.get('border')
                    )
                except Exception:
                    # Some Tk/ttk widgets may not accept fg/highlightbackground
                    try:
                        panel.configure(bg=self.colors.get('background'))
                    except Exception:
                        pass

        if self.export_router_frame is not None:
            self.export_router_frame.configure(bg=self.colors.get('background'))
            for child in self.export_router_frame.winfo_children():
                try:
                    child.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
                except Exception:
                    try:
                        child.configure(bg=self.colors.get('background'))
                    except Exception:
                        pass

        if self.export_options_frame is not None:
            self.export_options_frame.configure(bg=self.colors.get('background'))

        # Update Labels
        self.top_label.configure(fg=self.colors.get('foreground'), bg=self.colors.get('background'))
        if self.model_lbl is not None:
            self.model_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
        self.role_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))
        self.prompt_lbl.configure(bg=self.colors.get('background'), fg=self.colors.get('foreground'))

        # Update Entries and Text widgets
        self.role_entry.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.prompt_text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.input_box.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'), selectbackground=self.colors.get('select_bg'))

        # TTK STYLES: ttk widgets (Combobox/Treeview/etc.) won't pick up tk bg/fg changes.
        # If we don't restyle them, they can keep OS-default (often white) surfaces after a swap.
        try:
            style = ttk.Style()
            style.configure(
                "TCombobox",
                fieldbackground=self.colors.get('entry_bg', self.colors.get('panel_bg')),
                background=self.colors.get('panel_bg', self.colors.get('background')),
                foreground=self.colors.get('entry_fg', self.colors.get('foreground')),
                arrowcolor=self.colors.get('foreground')
            )
            style.map(
                "TCombobox",
                fieldbackground=[('readonly', self.colors.get('entry_bg', self.colors.get('panel_bg')))],
                foreground=[('readonly', self.colors.get('entry_fg', self.colors.get('foreground')))]
            )
        except Exception:
            pass

        # Panel 2/3 stubs
        if self.infer_log is not None:
            self.infer_log.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        if self.result_text is not None:
            self.result_text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'), selectbackground=self.colors.get('select_bg'))

        # Update Buttons (toolbar + small repo buttons)
        btn_list = [self.btn_bold, self.btn_italic, self.btn_list, self.btn_settings, self.btn_role_save, self.btn_role_open, self.btn_prompt_save, self.btn_prompt_open]
        for btn in btn_list:
            btn.configure(bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'))

        # Update Action Bar buttons
        if self.btn_save_template is not None:
            self.btn_save_template.configure(
                bg=self.colors.get('panel_bg'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )
        if self.btn_load_template is not None:
            self.btn_load_template.configure(
                bg=self.colors.get('panel_bg'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )
        if self.btn_submit is not None:
            self.btn_submit.configure(
                bg=self.colors.get('accent'),
                fg=self.colors.get('button_fg', self.colors.get('foreground'))
            )

        # HITL buttons
        if self.btn_accept is not None:
            self.btn_accept.configure(bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'))
        if self.btn_reject is not None:
            self.btn_reject.configure(bg=self.colors.get('button_bg', self.colors.get('panel_bg')), fg=self.colors.get('button_fg', self.colors.get('foreground')))
        if self.btn_exit is not None:
            self.btn_exit.configure(bg=self.colors.get('button_bg', self.colors.get('panel_bg')), fg=self.colors.get('button_fg', self.colors.get('foreground')))

        # Export buttons
        if self.export_execute_btn is not None:
            self.export_execute_btn.configure(bg=self.colors.get('accent'), fg=self.colors.get('button_fg', 'white'))





















--------------------------------------------------------------------------------
FILE: src\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\base_service.py
--------------------------------------------------------------------------------
import logging
from typing import Dict, Any

class BaseService:
    """
    Standard parent class for all microservices. 
    Provides consistent logging and identity management.
    """
    def __init__(self, name: str):
        self._service_info = {
            "name": name, 
            "id": name.lower().replace(" ", "_")
        }
        
        # Setup standard logging
        logging.basicConfig(
            level=logging.INFO, 
            format='%(asctime)s [%(levelname)s] %(message)s',
            datefmt='%H:%M:%S'
        )
        self.logger = logging.getLogger(name)

    def log_info(self, message: str):
        self.logger.info(message)

    def log_error(self, message: str):
        self.logger.error(message)

    def log_warning(self, message: str):
        self.logger.warning(message)

--------------------------------------------------------------------------------
FILE: src\microservices\document_utils.py
--------------------------------------------------------------------------------
from ._ContentExtractorMS import ContentExtractorMS

# Singleton instance to reuse the extractor logic
_extractor = ContentExtractorMS()

def extract_text_from_pdf(blob: bytes) -> str:
    """Proxy to ContentExtractorMS PDF logic."""
    return _extractor._extract_pdf(blob)

def extract_text_from_html(html_text: str) -> str:
    """Proxy to ContentExtractorMS HTML logic."""
    return _extractor._extract_html(html_text)

--------------------------------------------------------------------------------
FILE: src\microservices\fix.py
--------------------------------------------------------------------------------
import os
import re

def repair_microservices():
    # Targets for relative import conversion
    targets = ["base_service", "microservice_std_lib"]
    
    # Pattern: Matches 'from X import' or 'import X' where X is a target
    # but specifically avoids lines that already start with a dot.
    patterns = {
        target: (
            re.compile(rf"^(?!\s*from\s+\.)(\s*from\s+{target}\s+import)"),
            rf"from .{target} import"
        ) for target in targets
    }

    # Identify current directory (intended to be src/microservices/)
    current_dir = os.path.dirname(os.path.abspath(__file__))
    files_processed = 0
    files_repaired = 0

    print(f"--- Starting Import Repair in: {current_dir} ---")

    for filename in os.listdir(current_dir):
        if filename.endswith(".py") and filename not in ["repair_imports.py", "base_service.py", "microservice_std_lib.py"]:
            file_path = os.path.join(current_dir, filename)
            files_processed += 1
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            new_content = content
            modified = False

            for target, (pattern, replacement) in patterns.items():
                if pattern.search(new_content):
                    new_content = pattern.sub(replacement, new_content)
                    modified = True

            if modified:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                print(f"âœ… Repaired: {filename}")
                files_repaired += 1
            else:
                # No change needed
                pass

    print(f"\n--- Scan Complete ---")
    print(f"Files Checked: {files_processed}")
    print(f"Files Repaired: {files_repaired}")

if __name__ == "__main__":
    repair_microservices()
--------------------------------------------------------------------------------
FILE: src\microservices\microservice_std_lib.py
--------------------------------------------------------------------------------
"""
LIBRARY: Microservice Standard Lib
VERSION: 2.1.0
ROLE: Provides decorators for tagging Python classes as AI-discoverable services.

Change (2.1.0):
- Split dependencies into:
    internal_dependencies: local modules / microservices to vendor with the app
    external_dependencies: pip-installable packages (requirements.txt)
- Keep legacy "dependencies" as an alias for external_dependencies for backward compatibility.
- Accept unknown keyword args in @service_metadata(...) to prevent older/newer services from crashing
  (e.g. when a runner passes additional fields).
"""

import functools
import inspect
from typing import Dict, List, Any, Optional, Type

# ==============================================================================
# DECORATORS (The "Writer" Tools)
# ==============================================================================

def service_metadata(
    name: str,
    version: str,
    description: str,
    tags: List[str],
    capabilities: Optional[List[str]] = None,

    # Legacy field (kept for backward compatibility):
    # Historically this mixed stdlib + pip deps. Going forward, treat this as *external* deps.
    dependencies: Optional[List[str]] = None,

    # New fields (preferred):
    internal_dependencies: Optional[List[str]] = None,
    external_dependencies: Optional[List[str]] = None,

    # Side effects / operational hints
    side_effects: Optional[List[str]] = None,

    # Forward-compat: ignore unknown keyword args instead of crashing older/newer services
    **_ignored_kwargs: Any,
):
    """
    Class Decorator.
    Labels a Microservice class with high-level metadata for the Catalog.

    Dependency semantics:
      - internal_dependencies: local modules and/or other microservice modules that must be shipped with an app
      - external_dependencies: third-party pip packages (requirements.txt)
      - dependencies (legacy): treated as external_dependencies when external_dependencies is not provided
    """
    # Prefer explicit new key, otherwise fall back to legacy dependencies
    ext = external_dependencies if external_dependencies is not None else (dependencies or [])
    intl = internal_dependencies or []

    def decorator(cls):
        cls._is_microservice = True
        cls._service_info = {
            "name": name,
            "version": version,
            "description": description,
            "tags": tags,
            "capabilities": capabilities or [],

            # New keys
            "internal_dependencies": intl,
            "external_dependencies": ext,

            # Legacy alias (keep existing tooling working)
            "dependencies": ext,

            "side_effects": side_effects or []
        }
        return cls
    return decorator


def service_endpoint(
    inputs: Dict[str, str],
    outputs: Dict[str, str],
    description: str,
    tags: Optional[List[str]] = None,
    side_effects: Optional[List[str]] = None,
    mode: str = "sync",
):
    """
    Method Decorator.
    Defines the 'Socket' that the AI Architect can plug into.

    :param inputs: Dict of {arg_name: type_string} (e.g. {"query": "str"})
    :param outputs: Dict of {return_name: type_string}
    :param description: What the endpoint does
    :param tags: List of categories (e.g. ["read", "write"])
    :param side_effects: List of side effects (e.g. ["filesystem:write", "db:write"])
    :param mode: "sync" or "async" (informational unless your runtime uses it)
    """

    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        # Attach metadata to the function object itself
        wrapper._is_endpoint = True
        wrapper._endpoint_info = {
            "name": func.__name__,
            "inputs": inputs,
            "outputs": outputs,
            "description": description,
            "tags": tags or [],
            "side_effects": side_effects or [],
            "mode": mode
        }
        return wrapper
    return decorator


# ==============================================================================
# INTROSPECTION (The "Reader" Tools)
# ==============================================================================

def extract_service_schema(service_cls: Type) -> Dict[str, Any]:
    """
    Scans a decorated Service Class and returns a JSON-serializable schema
    of its metadata and all its exposed endpoints.

    This is what the AI Agent uses to 'read' the manual.
    """
    if not getattr(service_cls, "_is_microservice", False):
        raise ValueError(f"Class {service_cls.__name__} is not decorated with @service_metadata")

    schema = {
        "meta": getattr(service_cls, "_service_info", {}),
        "endpoints": []
    }

    # Inspect all methods of the class
    for _, method in inspect.getmembers(service_cls, predicate=inspect.isfunction):
        endpoint_info = getattr(method, "_endpoint_info", None)
        if endpoint_info:
            schema["endpoints"].append(endpoint_info)

    return schema

--------------------------------------------------------------------------------
FILE: src\microservices\_CodeFormatterMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _CodeFormatterMS
ENTRY_POINT: _CodeFormatterMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import re
import json
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
logger = logging.getLogger('CodeFormatter')

class WhitespaceEngine:
    """
    Parses code into a granular map of (Indent + Content + Trailing).
    Can Normalize structure and generate 'Hunk' patches.
    """

    def __init__(self):
        self.raw_lines = []
        self.nodes = []
        self.normalized_text = ''
        self.patch_data = {'hunks': []}

    def load_source(self, text):
        self.raw_lines = text.splitlines()
        self.nodes = []
        indent_stack = [0]
        last_line_was_block_starter = False
        for i, line in enumerate(self.raw_lines):
            match = re.match('^([ \\t]*)(.*?)([ \\t]*)$', line)
            if not match:
                self.nodes.append({'id': i, 'indent': '', 'content': line, 'depth': 0, 'is_empty': True})
                continue
            indent, content, trailing = match.groups()
            is_empty = len(content) == 0
            current_width = 0
            for char in indent:
                current_width += 4 if char == '\t' else 1
            if is_empty:
                depth = len(indent_stack) - 1
            else:
                if current_width > indent_stack[-1]:
                    if last_line_was_block_starter:
                        indent_stack.append(current_width)
                    else:
                        pass
                while len(indent_stack) > 1 and current_width < indent_stack[-1]:
                    indent_stack.pop()
                depth = len(indent_stack) - 1
                clean_content = content.split('#')[0].strip()
                last_line_was_block_starter = clean_content.endswith(':')
            self.nodes.append({'id': i, 'raw_indent': indent, 'depth': depth, 'content': content, 'trailing': trailing, 'is_empty': is_empty})

    def normalize(self, use_tabs=False, space_count=4):
        """Reconstructs the code with strict indentation rules."""
        char = '\t' if use_tabs else ' ' * space_count
        clean_lines = []
        for node in self.nodes:
            if node['is_empty']:
                clean_lines.append('')
            else:
                new_indent = char * node['depth']
                clean_lines.append(f"{new_indent}{node['content']}")
        self.normalized_text = '\n'.join(clean_lines)
        return self.normalized_text

    def generate_patch(self):
        """Compares Raw vs Normalized and generates JSON Schema Hunks."""
        clean_lines = self.normalized_text.splitlines()
        if not clean_lines:
            return {'hunks': []}
        hunks = []
        current_hunk = None
        for i, (raw, clean) in enumerate(zip(self.raw_lines, clean_lines)):
            if raw != clean:
                if current_hunk is None:
                    current_hunk = {'start_line': i, 'raw_block': [raw], 'clean_block': [clean]}
                elif i == current_hunk['start_line'] + len(current_hunk['raw_block']):
                    current_hunk['raw_block'].append(raw)
                    current_hunk['clean_block'].append(clean)
                else:
                    self._finalize_hunk(hunks, current_hunk)
                    current_hunk = {'start_line': i, 'raw_block': [raw], 'clean_block': [clean]}
            elif current_hunk:
                self._finalize_hunk(hunks, current_hunk)
                current_hunk = None
        if current_hunk:
            self._finalize_hunk(hunks, current_hunk)
        self.patch_data = {'hunks': hunks}
        return self.patch_data

    def _finalize_hunk(self, hunks_list, hunk_data):
        search_txt = '\n'.join(hunk_data['raw_block'])
        replace_txt = '\n'.join(hunk_data['clean_block'])
        schema_hunk = {'description': f"Normalize indentation (Lines {hunk_data['start_line']}-{hunk_data['start_line'] + len(hunk_data['raw_block'])})", 'search_block': search_txt, 'replace_block': replace_txt}
        hunks_list.append(schema_hunk)

@service_metadata(name='CodeFormatter', version='1.0.0', description='The Architect: Intelligent whitespace normalization and structural repair engine.', tags=['formatting', 'code', 'utility'], capabilities=['compute', 'filesystem:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class CodeFormatterMS(BaseService):
    """
    The Architect.
    Uses the WhitespaceEngine to enforce strict indentation rules, 
    fixing 'staircase' formatting and mixed tabs/spaces.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('CodeFormatter')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'use_tabs': 'bool', 'spaces': 'int'}, outputs={'normalized': 'str', 'patch': 'Dict'}, description='Takes raw code and returns the normalized version plus a JSON patch of changes.', tags=['formatting', 'compute'], side_effects=[])
    # ROLE: Takes raw code and returns the normalized version plus a JSON patch of changes.
    # INPUTS: {"content": "str", "spaces": "int", "use_tabs": "bool"}
    # OUTPUTS: {"normalized": "str", "patch": "Dict"}
    def normalize_code(self, content: str, use_tabs: bool=False, spaces: int=4) -> Dict[str, Any]:
        """
        Pure logic endpoint: Takes string, returns string + patch.
        Does not touch the filesystem.
        """
        engine = WhitespaceEngine()
        engine.load_source(content)
        normalized = engine.normalize(use_tabs=use_tabs, space_count=spaces)
        patch = engine.generate_patch()
        return {'normalized': normalized, 'patch': patch}

    @service_endpoint(inputs={'file_path': 'str', 'use_tabs': 'bool', 'spaces': 'int'}, outputs={'status': 'str', 'changes': 'int'}, description='Reads a file, normalizes it, and overwrites it if changes are needed.', tags=['formatting', 'filesystem'], side_effects=['filesystem:read', 'filesystem:write'])
    # ROLE: Reads a file, normalizes it, and overwrites it if changes are needed.
    # INPUTS: {"file_path": "str", "spaces": "int", "use_tabs": "bool"}
    # OUTPUTS: {"changes": "int", "status": "str"}
    def format_file(self, file_path: str, use_tabs: bool=False, spaces: int=4) -> Dict[str, Any]:
        """
        Filesystem endpoint: In-place repair of a file.
        """
        path = Path(file_path).resolve()
        if not path.exists():
            return {'status': 'error', 'message': 'File not found'}
        try:
            content = path.read_text(encoding='utf-8')
            engine = WhitespaceEngine()
            engine.load_source(content)
            normalized = engine.normalize(use_tabs=use_tabs, space_count=spaces)
            patch = engine.generate_patch()
            changes = len(patch['hunks'])
            if changes > 0:
                path.write_text(normalized, encoding='utf-8')
                logger.info(f'Formatted {path.name}: {changes} hunks applied.')
                return {'status': 'modified', 'changes': changes}
            else:
                return {'status': 'clean', 'changes': 0}
        except Exception as e:
            logger.error(f'Formatting failed for {path}: {e}')
            return {'status': 'error', 'message': str(e)}
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    svc = CodeFormatterMS()
    print('Service ready:', svc)
    broken_code = '\ndef hello():\n  print("Indented with 2 spaces")\n      print("Suddenly 6 spaces!")\n    '
    print('\n--- Processing Broken Code ---')
    result = svc.normalize_code(broken_code, spaces=4)
    print(f"Hunks Detected: {len(result['patch']['hunks'])}")
    print('\n--- Normalized Output ---')
    print(result['normalized'])


--------------------------------------------------------------------------------
FILE: src\microservices\_CognitiveMemoryMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _CognitiveMemoryMS
ENTRY_POINT: _CognitiveMemoryMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: pydantic
"""
import importlib.util
import sys
REQUIRED = ['pydantic']
MISSING = []
for lib in REQUIRED:
    if importlib.util.find_spec(lib) is None:
        MISSING.append(lib)
if MISSING:
    print(f"MISSING DEPENDENCIES: {' '.join(MISSING)}")
    print('Please run: pip install pydantic')
import datetime
import json
import logging
import uuid
import os
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional
from pydantic import BaseModel, Field
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
DEFAULT_MEMORY_FILE = Path('working_memory.jsonl')
FLUSH_THRESHOLD = 5
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger('CognitiveMem')

class MemoryEntry(BaseModel):
    """Atomic unit of memory."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime.datetime = Field(default_factory=datetime.datetime.utcnow)
    role: str
    content: str
    metadata: Dict[str, Any] = Field(default_factory=dict)

@service_metadata(name='CognitiveMemory', version='1.0.0', description='Manages Short-Term (Working) Memory and orchestrates flushing to Long-Term Memory.', tags=['memory', 'history', 'context'], capabilities=['filesystem:read', 'filesystem:write'], side_effects=['filesystem:write'], internal_dependencies=['base_service', 'microservice_std_lib'], external_dependencies=['pydantic'])
class CognitiveMemoryMS(BaseService):
    """
    The Hippocampus: Manages Short-Term (Working) Memory and orchestrates 
    flushing to Long-Term Memory (Vector Store).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('CognitiveMemory')
        self.config = config or {}
        self.file_path = Path(self.config.get('persistence_path', DEFAULT_MEMORY_FILE))
        self.summarizer = self.config.get('summarizer_func')
        self.ingestor = self.config.get('long_term_ingest_func')
        self.working_memory: List[MemoryEntry] = []
        self._load_working_memory()

    @service_endpoint(inputs={'role': 'str', 'content': 'str', 'metadata': 'Dict'}, outputs={'entry': 'MemoryEntry'}, description='Adds an item to working memory and persists it.', tags=['memory', 'write'], side_effects=['filesystem:write'])
    # ROLE: Adds an item to working memory and persists it.
    # INPUTS: {"content": "str", "metadata": "Dict", "role": "str"}
    # OUTPUTS: {"entry": "MemoryEntry"}
    def add_entry(self, role: str, content: str, metadata: Dict=None) -> MemoryEntry:
        """Adds an item to working memory and persists it."""
        entry = MemoryEntry(role=role, content=content, metadata=metadata or {})
        self.working_memory.append(entry)
        self._append_to_file(entry)
        log.info(f'Added memory: [{role}] {content[:30]}...')
        return entry

    @service_endpoint(inputs={'limit': 'int'}, outputs={'context': 'str'}, description='Returns the most recent conversation history formatted for an LLM.', tags=['memory', 'read', 'llm'], side_effects=['filesystem:read'])
    # ROLE: Returns the most recent conversation history formatted for an LLM.
    # INPUTS: {"limit": "int"}
    # OUTPUTS: {"context": "str"}
    def get_context(self, limit: int=10) -> str:
        """
        Returns the most recent conversation history formatted for an LLM.
        """
        recent = self.working_memory[-limit:]
        return '\n'.join([f'{e.role.upper()}: {e.content}' for e in recent])

    def get_full_history(self) -> List[Dict]:
        """Returns the raw list of memory objects."""
        return [e.dict() for e in self.working_memory]

    @service_endpoint(inputs={}, outputs={}, description='Signals that a turn is complete; checks if memory flush is needed.', tags=['memory', 'maintenance'], side_effects=['filesystem:write'])
    # ROLE: Signals that a turn is complete; checks if memory flush is needed.
    # INPUTS: {}
    # OUTPUTS: {}
    def commit_turn(self):
        """
        Signal that a "Turn" (User + AI response) is complete.
        Checks if memory is full and triggers a flush if needed.
        """
        if len(self.working_memory) >= FLUSH_THRESHOLD:
            self._flush_to_long_term()

    def _flush_to_long_term(self):
        """
        Compresses working memory into a summary and moves it to Long-Term storage.
        """
        if not self.summarizer or not self.ingestor:
            log.warning('Flush triggered but Summarizer/Ingestor not configured. Skipping.')
            return
        log.info('ðŸŒ€ Flushing Working Memory to Long-Term Storage...')
        full_text = '\n'.join([f'{e.role}: {e.content}' for e in self.working_memory])
        try:
            summary = self.summarizer(full_text)
            log.info(f'Summary generated: {summary[:50]}...')
        except Exception as e:
            log.error(f'Summarization failed: {e}')
            return
        try:
            meta = {'source': 'cognitive_memory_flush', 'date': datetime.datetime.utcnow().isoformat(), 'original_entry_count': len(self.working_memory)}
            self.ingestor(summary, meta)
            log.info('âœ… Saved to Long-Term Memory.')
        except Exception as e:
            log.error(f'Ingestion failed: {e}')
            return
        self.working_memory.clear()
        self._rotate_log_file()

    def _load_working_memory(self):
        """Rehydrates memory from the JSONL file."""
        if not self.file_path.exists():
            return
        try:
            with open(self.file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.strip():
                        self.working_memory.append(MemoryEntry.parse_raw(line))
            log.info(f'Loaded {len(self.working_memory)} items from {self.file_path}')
        except Exception as e:
            log.error(f'Corrupt memory file: {e}')

    def _append_to_file(self, entry: MemoryEntry):
        """Appends a single entry to the JSONL log."""
        with open(self.file_path, 'a', encoding='utf-8') as f:
            f.write(entry.json() + '\n')

    def _rotate_log_file(self):
        """Renames the current log to an archive timestamp."""
        if self.file_path.exists():
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            archive_name = self.file_path.with_name(f'memory_archive_{timestamp}.jsonl')
            self.file_path.rename(archive_name)
            log.info(f'Rotated memory log to {archive_name}')
if __name__ == '__main__':

    def mock_summarizer(text):
        return f'SUMMARY OF {len(text)} CHARS: The user and AI discussed AI architecture.'

    def mock_ingest(text, metadata):
        print(f"\n[VectorDB] Indexing: '{text}'\n[VectorDB] Meta: {metadata}")
    print('--- Initializing Cognitive Memory ---')
    mem = CognitiveMemoryMS({'summarizer_func': mock_summarizer, 'long_term_ingest_func': mock_ingest})
    print(f'Service ready: {mem}')
    print('\n--- Simulating Conversation ---')
    mem.add_entry('user', 'Hello, who are you?')
    mem.add_entry('assistant', 'I am a Cognitive Agent.')
    mem.add_entry('user', 'What is your memory capacity?')
    mem.add_entry('assistant', 'I have a tiered memory system.')
    mem.add_entry('user', 'That sounds complex.')
    print(f'\nCurrent Context:\n{mem.get_context()}')
    print('\n--- Triggering Memory Flush ---')
    mem.commit_turn()
    print(f'\nWorking Memory after flush: {len(mem.working_memory)} items')
    if Path('working_memory.jsonl').exists():
        os.remove('working_memory.jsonl')
    for p in Path('.').glob('memory_archive_*.jsonl'):
        os.remove(p)

--------------------------------------------------------------------------------
FILE: src\microservices\_ConfigStoreMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _ConfigStoreMS
ROLE: App Settings Persistence (Task 4.2)
"""
import json
import os
import logging
from typing import Dict, Any, Optional

class ConfigStoreMS:
    def __init__(self, filename="app_config.json"):
        self.filename = filename
        self.logger = logging.getLogger("ConfigStore")
        self.data = self._load_from_disk()

    def _load_from_disk(self) -> Dict[str, Any]:
        """Loads the JSON config or returns defaults if missing/corrupt."""
        if not os.path.exists(self.filename):
            return {}
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load config: {e}")
            return {}

    def get(self, key: str, default: Any = None) -> Any:
        return self.data.get(key, default)

    def set(self, key: str, value: Any):
        """Updates internal data and triggers an atomic save."""
        self.data[key] = value
        self.save()

    def save(self):
        """Atomic write: Save to temp, then rename to original."""
        temp_file = f"{self.filename}.tmp"
        try:
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4)
            os.replace(temp_file, self.filename)
        except Exception as e:
            self.logger.error(f"Atomic save failed: {e}")
            if os.path.exists(temp_file):
                os.remove(temp_file)

--------------------------------------------------------------------------------
FILE: src\microservices\_DiffEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _DiffEngineMS
ENTRY_POINT: _DiffEngineMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import sqlite3
import difflib
import datetime
import uuid
import logging
from pathlib import Path
from typing import Optional, Dict, List, Tuple, Any
from microservice_std_lib import service_metadata, service_endpoint
DB_PATH = Path(__file__).parent / 'diff_engine.db'
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger('DiffEngine')

@service_metadata(name='DiffEngineMS', version='1.0.0', description='Implements hybrid versioning (Head + Diff History) for file content.', tags=['version-control', 'diff', 'db'], capabilities=['db:sqlite', 'filesystem:write'], side_effects=['db:read', 'db:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class DiffEngineMS:
    """
    The Timekeeper: Implements a 'Hybrid' versioning architecture.
    1. HEAD: Stores full current content for fast read access (UI/RAG).
    2. HISTORY: Stores diff deltas using difflib for audit trails.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        self.config = config or {}
        self.db_path = Path(self.config.get('db_path', DB_PATH))
        self._init_db()

    def _get_conn(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn

    def _init_db(self):
        with self._get_conn() as conn:
            conn.execute('\n                CREATE TABLE IF NOT EXISTS files (\n                    id TEXT PRIMARY KEY,\n                    path TEXT UNIQUE NOT NULL,\n                    content TEXT,\n                    last_updated TIMESTAMP\n                )\n            ')
            conn.execute("\n                CREATE TABLE IF NOT EXISTS diff_log (\n                    id TEXT PRIMARY KEY,\n                    file_id TEXT NOT NULL,\n                    timestamp TIMESTAMP,\n                    change_type TEXT,  -- 'CREATE', 'EDIT', 'DELETE'\n                    diff_blob TEXT,    -- The text output of difflib\n                    author TEXT,\n                    FOREIGN KEY(file_id) REFERENCES files(id)\n                )\n            ")

    @service_endpoint(inputs={'path': 'str', 'new_content': 'str', 'author': 'str'}, outputs={'status': 'str', 'file_id': 'str'}, description='Updates a file, creating a diff history entry and updating the head state.', tags=['version-control', 'write'], side_effects=['db:write'])
    # ROLE: Updates a file, creating a diff history entry and updating the head state.
    # INPUTS: {"author": "str", "new_content": "str", "path": "str"}
    # OUTPUTS: {"file_id": "str", "status": "str"}
    def update_file(self, path: str, new_content: str, author: str='agent') -> Dict[str, Any]:
        """
        The Atomic Update Operation:
        1. Checks current state.
        2. Calculates Diff.
        3. Writes Diff to History.
        4. Updates Head to New Content.
        """
        path = str(Path(path).as_posix())
        now = datetime.datetime.utcnow()
        with self._get_conn() as conn:
            row = conn.execute('SELECT id, content FROM files WHERE path = ?', (path,)).fetchone()
            if not row:
                file_id = str(uuid.uuid4())
                conn.execute('INSERT INTO files (id, path, content, last_updated) VALUES (?, ?, ?, ?)', (file_id, path, new_content, now))
                self._log_diff(conn, file_id, 'CREATE', '[New File Created]', author, now)
                log.info(f'Created new file: {path}')
                return {'status': 'created', 'file_id': file_id}
            file_id = row['id']
            old_content = row['content'] or ''
            old_lines = old_content.splitlines(keepends=True)
            new_lines = new_content.splitlines(keepends=True)
            diff_gen = difflib.unified_diff(old_lines, new_lines, fromfile=f'a/{path}', tofile=f'b/{path}', lineterm='')
            diff_text = ''.join(diff_gen)
            if not diff_text:
                return {'status': 'unchanged', 'file_id': file_id}
            self._log_diff(conn, file_id, 'EDIT', diff_text, author, now)
            conn.execute('UPDATE files SET content = ?, last_updated = ? WHERE id = ?', (new_content, now, file_id))
            log.info(f'Updated file: {path}')
            return {'status': 'updated', 'file_id': file_id, 'diff_size': len(diff_text)}

    def _log_diff(self, conn, file_id, change_type, diff_text, author, timestamp):
        diff_id = str(uuid.uuid4())
        conn.execute('INSERT INTO diff_log (id, file_id, timestamp, change_type, diff_blob, author) VALUES (?, ?, ?, ?, ?, ?)', (diff_id, file_id, timestamp, change_type, diff_text, author))

    @service_endpoint(inputs={'path': 'str'}, outputs={'content': 'Optional[str]'}, description='Fast retrieval of current content.', tags=['version-control', 'read'], side_effects=['db:read'])
    # ROLE: Fast retrieval of current content.
    # INPUTS: {"path": "str"}
    # OUTPUTS: {"content": "Optional[str]"}
    def get_head(self, path: str) -> Optional[str]:
        """Fast retrieval of current content."""
        with self._get_conn() as conn:
            row = conn.execute('SELECT content FROM files WHERE path = ?', (path,)).fetchone()
            return row['content'] if row else None

    @service_endpoint(inputs={'path': 'str'}, outputs={'history': 'List[Dict]'}, description='Retrieves the full evolution history of a file.', tags=['version-control', 'read'], side_effects=['db:read'])
    # ROLE: Retrieves the full evolution history of a file.
    # INPUTS: {"path": "str"}
    # OUTPUTS: {"history": "List[Dict]"}
    def get_history(self, path: str) -> List[Dict]:
        """Retrieves the full evolution history of a file."""
        with self._get_conn() as conn:
            row = conn.execute('SELECT id FROM files WHERE path = ?', (path,)).fetchone()
            if not row:
                return []
            rows = conn.execute('SELECT timestamp, change_type, diff_blob, author FROM diff_log WHERE file_id = ? ORDER BY timestamp DESC', (row['id'],)).fetchall()
            return [dict(r) for r in rows]
if __name__ == '__main__':
    import os
    if DB_PATH.exists():
        os.remove(DB_PATH)
    engine = DiffEngineMS()
    print('Service ready:', engine)
    print('--- 1. Creating File ---')
    engine.update_file('notes.txt', 'Todo List:\n1. Buy Milk\n')
    print('\n--- 2. Updating File (The Rising Edge) ---')
    new_text = 'Todo List:\n1. Buy Eggs\n2. Code Python\n'
    res = engine.update_file('notes.txt', new_text, author='Jacob')
    print(f"Update Result: {res['status']}")
    print('\n--- 3. Inspecting History ---')
    history = engine.get_history('notes.txt')
    for event in history:
        print(f"\n[{event['timestamp']}] {event['change_type']} by {event['author']}")
        print(f"Diff Preview:\n{event['diff_blob'].strip()}")
    print('\n--- 4. Inspecting Head (Cache) ---')
    print(engine.get_head('notes.txt'))
    if DB_PATH.exists():
        os.remove(DB_PATH)

--------------------------------------------------------------------------------
FILE: src\microservices\_ErrorNotifierMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _ErrorNotifierMS
ROLE: Reactive Error Dispatcher (Task 3)
"""
import logging
from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='ErrorNotifier', 
    version='1.0.0', 
    description='Reactive service that normalizes and dispatches engine errors to UI/Logs.', 
    tags=['utility', 'error-handling'], 
    capabilities=['ui-notification'], 
    internal_dependencies=['microservice_std_lib']
)
class ErrorNotifierMS:
    def __init__(self, bus):
        self.bus = bus
        self.logger = logging.getLogger("ErrorNotifier")

    def on_engine_error(self, payload: Dict[str, Any]):
        """
        Subscribed handler for engine failures.
        Safely extracts error details and emits normalized UI/Logging events.
        """
        # 1. Safely extract message with fallback
        msg = payload.get('message') or payload.get('msg') or "Unknown Engine Error"
        file_ctx = f" in {payload['file']}" if 'file' in payload else ""
        hunk_ctx = f" (Hunk: {payload['hunk_name']})" if 'hunk_name' in payload else ""
        
        full_report = f"âŒ ENGINE ERROR: {msg}{file_ctx}{hunk_ctx}"

        # 2. Dispatch to the UI via the Signal Bus
        # This keeps the notifier decoupled from the UI implementation details
        self.bus.emit("notify_error", {"message": full_report, "level": "ERROR"})
        
        # 3. Log internally for standard output
        self.logger.error(full_report)

    def on_commit_failed(self, payload: Dict[str, Any]):
        """Handles failures during file write operations."""
        file_path = payload.get('file', 'unknown file')
        error = payload.get('error', 'unknown write error')
        
        report = f"ðŸ’¾ COMMIT FAILED: Could not update {file_path}. Error: {error}"
        self.bus.emit("notify_error", {"message": report, "level": "CRITICAL"})


--------------------------------------------------------------------------------
FILE: src\microservices\_FeedbackValidationMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _FeedbackValidationMS
ENTRY_POINT: _FeedbackValidationMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: sqlite3, json
"""
import sqlite3
import json
import datetime
from typing import Dict, Any, List, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(
    name='FeedbackValidation', 
    version='1.0.0', 
    description='System-level memory layer for recording HITL feedback and transaction validation.',
    tags=['hitl', 'training', 'validation', 'context'],
    capabilities=['db:sqlite', 'training-data:export'],
    side_effects=['db:write'],
    internal_dependencies=['base_service', 'microservice_std_lib']
)
class FeedbackValidationMS(BaseService):
    """
    The Validator: Records accepted/rejected transactions into a dedicated
    training table within the knowledge graph for future prompt context.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('FeedbackValidation')
        self.config = config or {}
        self.db_path = self.config.get('db_path', 'knowledge.db')
        self._init_training_table()

    def _init_training_table(self):
        """Ensures the knowledge graph can store validated transactions."""
        conn = sqlite3.connect(self.db_path)
        # Create a specific table for training pairs
        conn.execute('''
            CREATE TABLE IF NOT EXISTS training_data (
                id INTEGER PRIMARY KEY,
                timestamp TEXT,
                prompt TEXT,
                response TEXT,
                is_accepted INTEGER,
                metadata_json TEXT
            )
        ''')
        conn.close()

    @service_endpoint(
        inputs={'prompt': 'str', 'response': 'str', 'is_accepted': 'bool', 'meta': 'Dict'},
        outputs={'success': 'bool'},
        description='Records a validated or rejected transaction as training context.',
        tags=['write', 'hitl'],
        side_effects=['db:write']
    )
    # ROLE: Records a validated or rejected transaction as training context.
    # INPUTS: {"is_accepted": "bool", "meta": "Dict", "prompt": "str", "response": "str"}
    # OUTPUTS: {"success": "bool"}
    def submit_feedback(self, prompt: str, response: str, is_accepted: bool, meta: Dict = None) -> bool:
        """
        Main entry point for the HITL UI to deposit the result of an inference turn.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            timestamp = datetime.datetime.utcnow().isoformat()
            
            # 1. Insert into raw training table
            cursor.execute(
                'INSERT INTO training_data (timestamp, prompt, response, is_accepted, metadata_json) VALUES (?, ?, ?, ?, ?)',
                (timestamp, prompt, response, 1 if is_accepted else 0, json.dumps(meta or {}))
            )
            
            # 2. Also register as a Graph Node for high-level mapping
            node_id = f"tx_{cursor.lastrowid}"
            cursor.execute(
                'INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json) VALUES (?, ?, ?, ?)',
                (node_id, 'validated_transaction', f"Feedback: {'Accepted' if is_accepted else 'Rejected'}", json.dumps({'is_accepted': is_accepted}))
            )
            
            conn.commit()
            conn.close()
            self.log_info(f"Transaction recorded: {'ACCEPTED' if is_accepted else 'REJECTED'}")
            return True
        except Exception as e:
            self.log_error(f"Failed to record feedback: {e}")
            return False

    @service_endpoint(
        inputs={'limit': 'int', 'only_accepted': 'bool'},
        outputs={'history': 'List[Dict]'},
        description='Retrieves past validated transactions to build few-shot prompts.',
        tags=['read', 'prompt-builder'],
        side_effects=['db:read']
    )
    # ROLE: Retrieves past validated transactions to build few-shot prompts.
    # INPUTS: {"limit": "int", "only_accepted": "bool"}
    # OUTPUTS: {"history": "List[Dict]"}
    def get_validated_context(self, limit: int = 5, only_accepted: bool = True) -> List[Dict]:
        """
        Called by the system building the prompt to find 'Gold Standard' examples.
        """
        conn = sqlite3.connect(self.db_path)
        query = "SELECT prompt, response FROM training_data WHERE 1=1"
        if only_accepted:
            query += " AND is_accepted = 1"
        query += " ORDER BY id DESC LIMIT ?"
        
        results = conn.execute(query, (limit,)).fetchall()
        conn.close()
        
        return [{"prompt": r[0], "response": r[1]} for r in results]

    @service_endpoint(
        inputs={'artifact': 'Dict', 'is_accepted': 'bool'},
        outputs={'success': 'bool'},
        description='Unwraps a standard Cell Artifact and submits it for validation.',
        tags=['write', 'hitl', 'helper']
    )
    # ROLE: Unwraps a standard Cell Artifact and submits it for validation.
    # INPUTS: {"artifact": "Dict", "is_accepted": "bool"}
    # OUTPUTS: {"success": "bool"}
    def validate_artifact(self, artifact: Dict[str, Any], is_accepted: bool) -> bool:
        """
        Convenience wrapper for Standard Artifacts.
        """
        try:
            meta = artifact.get('metadata', {})
            instructions = artifact.get('instructions', {})
            
            # Reconstruct the full prompt context
            sys_role = instructions.get('system_role', '')
            sys_prompt = instructions.get('system_prompt', '')
            user_payload = artifact.get('payload', '')
            
            full_prompt = f"Role: {sys_role}\nContext: {sys_prompt}\nTask: {user_payload}"
            response = artifact.get('response', '') # Assuming response is injected into artifact before validation
            
            return self.submit_feedback(full_prompt, response, is_accepted, meta)
        except Exception as e:
            self.log_error(f"Artifact validation failed: {e}")
            return False


--------------------------------------------------------------------------------
FILE: src\microservices\_HydrationFactoryMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _HydrationFactoryMS
ENTRY_POINT: _HydrationFactoryMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib, _CodeFormatterMS, _TreeMapperMS, _VectorFactoryMS
EXTERNAL_DEPENDENCIES: None
"""
import os
import json
import logging
from typing import Dict, Any, Optional, List, Union
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(
    name='HydrationFactory',
    version='1.0.0',
    description='The Fabricator: Converts raw Cell Artifacts into hydrated, usable products (Files, Maps, Memories).',
    tags=['utility', 'converter', 'factory', 'output'],
    capabilities=['filesystem:write', 'compute', 'db:vector'],
    side_effects=['filesystem:write', 'db:write'],
    internal_dependencies=['base_service', 'microservice_std_lib', '_CodeFormatterMS', '_TreeMapperMS', '_VectorFactoryMS']
)
class HydrationFactoryMS(BaseService):
    """
    The Fabricator.
    Takes a raw JSON Artifact from a Cell and "Hydrates" it into a final product
    based on the requested mode.
    
    Modes:
    1. SCAFFOLD (Code): Formats and writes source code to disk.
    2. BLUEPRINT (Doc): Generates a project tree map.
    3. MEMORY (Vector): Embeds the artifact into a Vector Store (Long-term memory).
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None, services: Optional[Dict[str, Any]] = None):
        super().__init__('HydrationFactory')
        self.config = config or {}
        self.services = services or {}

        # Specialists are injected by the orchestration layer.
        # Expected keys: formatter, mapper, vector_factory, ingest_engine
        self.formatter = self.services.get('formatter')
        self.mapper = self.services.get('mapper')
        self.vector_factory = self.services.get('vector_factory')
        self.ingest_engine = self.services.get('ingest_engine')

    @service_endpoint(
        inputs={'artifact': 'Dict', 'mode': 'str', 'destination': 'str'},
        outputs={'status': 'str', 'details': 'Dict'},
        description='Main entry point to hydrate an artifact into a concrete product.',
        tags=['factory', 'execute']
    )
    # ROLE: Main entry point to hydrate an artifact into a concrete product.
    # INPUTS: {"artifact": "Dict", "destination": "str", "mode": "str"}
    # OUTPUTS: {"details": "Dict", "status": "str"}
    def hydrate_artifact(self, artifact: Dict[str, Any], mode: str, destination: str) -> Dict[str, Any]:
        """
        :param artifact: The standardized JSON output from a Cell.
        :param mode: 'scaffold', 'blueprint', or 'memory'.
        :param destination: File path (for scaffold/blueprint) or Collection name (for memory).
        """
        self.log_info(f"Hydrating artifact via mode: {mode.upper()} -> {destination}")
        
        try:
            if mode.lower() == 'scaffold':
                return self._hydrate_scaffold(artifact, destination)
            elif mode.lower() == 'blueprint':
                return self._hydrate_blueprint(destination)
            elif mode.lower() == 'memory':
                return self._hydrate_memory(artifact, destination)
            else:
                raise ValueError(f"Unknown hydration mode: {mode}")
        except Exception as e:
            self.log_error(f"Hydration failed: {e}")
            return {"status": "error", "message": str(e)}

    def _hydrate_scaffold(self, artifact: Dict[str, Any], file_path: str) -> Dict[str, Any]:
        """Writes the payload to a file after passing it through the CodeFormatter."""
        content = artifact.get('payload', '')
        if not content:
            return {"status": "skipped", "reason": "Empty payload"}

        # 1. Format the code (The Architect)
        # We assume Python for now, but this could be dynamic based on extension
        formatted_result = self.formatter.normalize_code(content, spaces=4)
        final_code = formatted_result.get('normalized', content)
        hunks_applied = len(formatted_result.get('patch', {}).get('hunks', []))

        # 2. Write to disk
        os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(final_code)

        return {
            "status": "success",
            "type": "file_write",
            "path": file_path,
            "formatting_hunks_applied": hunks_applied
        }

    def _hydrate_blueprint(self, root_path: str) -> Dict[str, Any]:
        """Generates a project tree map and saves it to a file."""
        # 1. Generate Map (The Cartographer)
        tree_map = self.mapper.generate_tree(root_path)
        
        # 2. Save to _project_map.txt in the root
        output_path = os.path.join(root_path, '_project_map.txt')
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(tree_map)

        return {
            "status": "success",
            "type": "map_generation",
            "path": output_path,
            "size": len(tree_map)
        }

    def _hydrate_memory(self, artifact: Dict[str, Any], collection_name: str) -> Dict[str, Any]:
        """Embeds the artifact payload into the Vector Store."""
        # 1. Create Vector Store Connection (The Switchboard)
        # Defaulting to Chroma for persistence, could be config-driven
        store = self.vector_factory.create('chroma', {'path': './knowledge_base', 'collection': collection_name})
        
        # 2. Prepare Data
        # We embed the payload (content) and attach the metadata
        payload = artifact.get('payload', '')
        if not payload:
             return {"status": "skipped", "reason": "Empty payload"}
             
        # Generate a simple embedding (Mocked here, normally uses IngestEngine or internal embedder)
        # In a real flow, we'd call an embedding service. 
        # For the factory, we assume the artifact might already have a vector, 
        # or we generate a placeholder/call a service if we want to be fully self-contained.
        # SIMPLIFICATION: We will require the embedding to be passed or we skip it for this stub.
        # Ideally, we call self.ingest_engine.get_embedding(payload)
        
        # For now, we just store the text without vector search if no embedding provided (Chroma handles raw text too usually)
        # But our VectorStore protocol expects embeddings.
        # ENGINE: injected by orchestration layer
        if not getattr(self, 'ingest_engine', None):
            return {"status": "error", "message": "IngestEngine not injected"}

        engine = self.ingest_engine
        # We use a standard small model for embeddings (e.g., all-minilm)
        vector = engine._get_embedding(model="nomic-embed-text", text=payload)
        
        if not vector:
            self.log_warning("Could not generate embedding, falling back to mock.")
            vector = [0.0] * 384

        store.add(
            embeddings=[vector],
            metadatas=[artifact.get('metadata', {})]
        )

        return {
            "status": "success",
            "type": "memory_storage",
            "collection": collection_name,
            "item_count": store.count()
        }

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    
    # Test Harness
    factory = HydrationFactoryMS()
    print(f"Service Ready: {factory}")
    
    # Mock Artifact
    test_artifact = {
        "metadata": {"author": "TheCell", "version": "1.0"},
        "payload": "def hello_world():\n  print('Hello from the Factory!')",
        "instructions": {"system_prompt": "Write python code"}
    }
    
    print("\n--- Testing Code Hydration ---")
    res = factory.hydrate_artifact(test_artifact, mode='scaffold', destination='./_test_output.py')
    print(json.dumps(res, indent=2))
    
    print("\n--- Testing Clean Up ---")
    if os.path.exists('./_test_output.py'):
        os.remove('./_test_output.py')
        print("Cleaned up test file.")



--------------------------------------------------------------------------------
FILE: src\microservices\_IngestEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _IngestEngineMS
ENTRY_POINT: _IngestEngineMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: requests
"""
import importlib.util
import sys
REQUIRED = ['requests']
MISSING = []
for lib in REQUIRED:
    if importlib.util.find_spec(lib) is None:
        MISSING.append(lib)
if MISSING:
    print(f"MISSING DEPENDENCIES: {' '.join(MISSING)}")
    print('Please run: pip install requests')
import json
import os
import re
import sqlite3
import time
from dataclasses import dataclass
from typing import Any, Dict, Generator, List, Optional
import requests
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
from ._TextChunkerMS import TextChunkerMS
OLLAMA_API_URL = 'http://localhost:11434/api'

@dataclass
class IngestStatus:
    current_file: str
    progress_percent: float
    processed_files: int
    total_files: int
    log_message: str
    thought_frame: Optional[Dict] = None

class SynapseWeaver:
    """
    Parses source code to extract import dependencies.
    Used to generate the 'DEPENDS_ON' edges in the Knowledge Graph.
    """

    def __init__(self):
        self.py_pattern = re.compile('^\\s*(?:from|import)\\s+([\\w\\.]+)')
        self.js_pattern = re.compile('(?:import\\s+.*?from\\s+[\\\'"]|require\\([\\\'"])([\\.\\/\\w\\-_]+)[\\\'"]')

    def extract_dependencies(self, content: str, file_path: str) -> List[str]:
        dependencies = []
        ext = os.path.splitext(file_path)[1].lower()
        lines = content.split('\n')
        for line in lines:
            match = None
            if ext == '.py':
                match = self.py_pattern.match(line)
            elif ext in ['.js', '.ts', '.tsx', '.jsx']:
                match = self.js_pattern.search(line)
            if match:
                raw_dep = match.group(1)
                clean_dep = raw_dep.split('.')[-1].split('/')[-1]
                if clean_dep not in dependencies:
                    dependencies.append(clean_dep)
        return dependencies

@service_metadata(name='IngestEngine', version='1.0.0', description='Reads files, chunks text, fetches embeddings, and weaves graph edges.', tags=['ingest', 'rag', 'parsing', 'embedding'], capabilities=['filesystem:read', 'network:outbound', 'db:sqlite'], side_effects=['db:write', 'network:outbound'], internal_dependencies=['base_service', 'microservice_std_lib'], external_dependencies=['requests'])
class IngestEngineMS(BaseService):
    """
    The Heavy Lifter: Reads files, chunks text, fetches embeddings,
    populates the Graph Nodes, and weaves Graph Edges.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('IngestEngine')
        self.config = config or {}
        self.db_path = self.config.get('db_path', 'knowledge.db')
        self.stop_signal = False
        self.weaver = SynapseWeaver()
        self.chunker = TextChunkerMS()
        self._init_db()

    def _init_db(self):
        """Ensures the target database has the required schema."""
        conn = sqlite3.connect(self.db_path)
        conn.execute('CREATE TABLE IF NOT EXISTS files (id INTEGER PRIMARY KEY, path TEXT, last_updated REAL)')
        conn.execute('CREATE TABLE IF NOT EXISTS chunks (id INTEGER PRIMARY KEY, file_id INT, chunk_index INT, content TEXT, embedding BLOB)')
        conn.execute('CREATE TABLE IF NOT EXISTS graph_nodes (id TEXT PRIMARY KEY, type TEXT, label TEXT, data_json TEXT)')
        conn.execute('CREATE TABLE IF NOT EXISTS graph_edges (source TEXT, target TEXT, weight REAL)')
        conn.close()

    def abort(self):
        self.stop_signal = True

    def check_ollama_connection(self) -> bool:
        try:
            requests.get(f'{OLLAMA_API_URL}/tags', timeout=2)
            return True
        except:
            return False

    def get_available_models(self) -> List[str]:
        try:
            res = requests.get(f'{OLLAMA_API_URL}/tags')
            if res.status_code == 200:
                data = res.json()
                return [m['name'] for m in data.get('models', [])]
        except:
            pass
        return []

    @service_endpoint(
        inputs={'prompt': 'str', 'model': 'str', 'system': 'str'}, 
        outputs={'chunk': 'str'}, 
        description='Streams inference tokens from Ollama.', 
        tags=['inference', 'stream'], 
        mode='generator', 
        side_effects=['network:outbound']
    )
    # ROLE: Streams inference tokens from Ollama.
    # INPUTS: {"model": "str", "prompt": "str", "system": "str"}
    # OUTPUTS: {"chunk": "str"}
    def generate_stream(self, prompt: str, model: str, system: str = '') -> Generator[str, None, None]:
        """Yields tokens from the LLM for real-time UI updates."""
        url = f"{OLLAMA_API_URL}/generate"
        payload = {
            "model": model,
            "prompt": prompt,
            "system": system,
            "stream": True
        }
        
        try:
            with requests.post(url, json=payload, stream=True, timeout=120) as r:
                if r.status_code != 200:
                    yield f"[Error: Ollama returned status {r.status_code}]"
                    return
                
                for line in r.iter_lines():
                    if self.stop_signal:
                        break
                    if line:
                        try:
                            body = json.loads(line)
                            token = body.get('response', '')
                            if token:
                                yield token
                            if body.get('done', False):
                                break
                        except json.JSONDecodeError:
                            continue
        except Exception as e:
            yield f"[Connection Error: {str(e)}]"

    @service_endpoint(inputs={'file_paths': 'List[str]', 'model_name': 'str'}, outputs={'status': 'IngestStatus'}, description='Processes a list of files, ingesting them into the knowledge graph.', tags=['ingest', 'processing'], mode='generator', side_effects=['db:write', 'network:outbound'])
    # ROLE: Processes a list of files, ingesting them into the knowledge graph.
    # INPUTS: {"file_paths": "List[str]", "model_name": "str"}
    # OUTPUTS: {"status": "IngestStatus"}
    def process_files(self, file_paths: List[str], model_name: str='none') -> Generator[IngestStatus, None, None]:
        total = len(file_paths)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('PRAGMA synchronous = OFF')
        cursor.execute('PRAGMA journal_mode = MEMORY')
        node_registry = {}
        file_contents = {}
        for idx, file_path in enumerate(file_paths):
            if self.stop_signal:
                yield IngestStatus(file_path, 0, idx, total, 'Ingestion Aborted.')
                break
            filename = os.path.basename(file_path)
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                file_contents[filename] = content
            except Exception as e:
                yield IngestStatus(file_path, idx / total * 100, idx, total, f'Error: {e}')
                continue
            try:
                cursor.execute('INSERT OR REPLACE INTO files (path, last_updated) VALUES (?, ?)', (file_path, time.time()))
                file_id = cursor.lastrowid
            except sqlite3.Error:
                continue
            cursor.execute('\n                INSERT OR REPLACE INTO graph_nodes (id, type, label, data_json)\n                VALUES (?, ?, ?, ?)\n            ', (filename, 'file', filename, json.dumps({'path': file_path})))
            node_registry[filename] = filename
            chunks = self._chunk_text(content)
            for i, chunk_text in enumerate(chunks):
                if self.stop_signal:
                    break
                embedding = None
                if model_name != 'none':
                    embedding = self._get_embedding(model_name, chunk_text)
                emb_blob = json.dumps(embedding).encode('utf-8') if embedding else None
                cursor.execute('\n                    INSERT INTO chunks (file_id, chunk_index, content, embedding)\n                    VALUES (?, ?, ?, ?)\n                ', (file_id, i, chunk_text, emb_blob))
                thought_frame = {'id': f'{file_id}_{i}', 'file': filename, 'chunk_index': i, 'content': chunk_text, 'vector_preview': embedding[:20] if embedding else [], 'concept_color': '#007ACC'}
                yield IngestStatus(current_file=filename, progress_percent=(idx + i / len(chunks)) / total * 100, processed_files=idx, total_files=total, log_message=f'Processing {filename}...', thought_frame=thought_frame)
            conn.commit()
        yield IngestStatus('Graph', 100, total, total, 'Weaving Knowledge Graph...')
        edge_count = 0
        for filename, content in file_contents.items():
            if self.stop_signal:
                break
            deps = self.weaver.extract_dependencies(content, filename)
            for dep in deps:
                target_id = None
                for potential_match in node_registry.keys():
                    if potential_match.startswith(dep + '.') or potential_match == dep:
                        target_id = potential_match
                        break
                if target_id and target_id != filename:
                    try:
                        cursor.execute('\n                            INSERT OR IGNORE INTO graph_edges (source, target, weight)\n                            VALUES (?, ?, 1.0)\n                        ', (filename, target_id))
                        edge_count += 1
                    except:
                        pass
        conn.commit()
        conn.close()
        yield IngestStatus(current_file='Complete', progress_percent=100, processed_files=total, total_files=total, log_message=f'Ingestion Complete. Created {edge_count} dependency edges.')

    def _chunk_text(self, text: str, chunk_size: int=1000, overlap: int=100) -> List[str]:
        # Delegate to the specialized service
        return self.chunker.chunk_by_chars(text, chunk_size, overlap)

    def _get_embedding(self, model: str, text: str) -> Optional[List[float]]:
        try:
            res = requests.post(f'{OLLAMA_API_URL}/embeddings', json={'model': model, 'prompt': text}, timeout=30)
            if res.status_code == 200:
                return res.json().get('embedding')
        except:
            return None
if __name__ == '__main__':
    TEST_DB = 'test_ingest_v2.db'
    engine = IngestEngineMS({'db_path': TEST_DB})
    print(f'Service Ready: {engine}')
    target_file = '__IngestEngineMS.py'
    if not os.path.exists(target_file):
        with open(target_file, 'w') as f:
            f.write("import os\nimport json\nprint('Hello World')")
    print(f'Running Ingest on {target_file}...')
    files = [target_file]
    for status in engine.process_files(files, 'none'):
        print(f'[{status.progress_percent:.0f}%] {status.log_message}')
    conn = sqlite3.connect(TEST_DB)
    edges = conn.execute('SELECT * FROM graph_edges').fetchall()
    nodes = conn.execute('SELECT * FROM graph_nodes').fetchall()
    print(f'\nResult: {len(nodes)} Nodes, {len(edges)} Edges.')
    conn.close()
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)
    if os.path.exists(target_file) and 'Hello World' in open(target_file).read():
        os.remove(target_file)


--------------------------------------------------------------------------------
FILE: src\microservices\_LogViewMS.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import scrolledtext, filedialog
import queue
import logging
import datetime
from typing import Any, Dict, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

class QueueHandler(logging.Handler):
    """
    Sends log records to a thread-safe queue.
    Used to bridge the gap between Python's logging system and the Tkinter UI.
    """

    def __init__(self, log_queue: queue.Queue):
        super().__init__()
        self.log_queue = log_queue

    def emit(self, record):
        self.log_queue.put(record)

@service_metadata(name='LogView', version='1.0.0', description='A thread-safe log viewer widget for Tkinter.', tags=['ui', 'logs', 'widget'], capabilities=['ui:gui', 'filesystem:write'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class LogViewMS(tk.Frame, BaseService):
    """
    The Console: A professional log viewer widget.
    Features:
    - Thread-safe (consumes from a Queue).
    - Message Consolidation ("Error occurred (x5)").
    - Level Filtering (Toggle INFO/DEBUG/ERROR).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None, theme: Optional[Dict[str, Any]]=None, bus: Optional[Any]=None):
        self.config = config or {}
        parent = self.config.get('parent')
        self.colors = theme or {}
        self.bus = bus
        
        tk.Frame.__init__(self, parent, bg=self.colors.get('background', '#1e1e1e'))
        BaseService.__init__(self, 'LogView')
        
        self.log_queue: queue.Queue = self.config.get('log_queue')
        if self.log_queue is None:
            self.log_queue = queue.Queue()
        
        self.last_msg = None
        self.last_count = 0
        self.last_line_index = None
        
        self._build_ui()
        self._poll_queue()

        if self.bus:
            self.bus.subscribe("theme_updated", self.refresh_theme)

    def _build_ui(self):
        self.toolbar = tk.Frame(self, bg=self.colors.get('panel_bg', '#2d2d2d'), height=30)
        self.toolbar.pack(fill='x', side='top')
        
        self.filters = {'INFO': tk.BooleanVar(value=True), 'DEBUG': tk.BooleanVar(value=True), 'WARNING': tk.BooleanVar(value=True), 'ERROR': tk.BooleanVar(value=True)}
        self.filter_btns = []
        
        for level, var in self.filters.items():
            cb = tk.Checkbutton(self.toolbar, text=level, variable=var, 
                                bg=self.colors.get('panel_bg', '#2d2d2d'), 
                                fg=self.colors.get('foreground', 'white'), 
                                selectcolor=self.colors.get('border', '#444'), 
                                activebackground=self.colors.get('panel_bg'))
            cb.pack(side='left', padx=5)
            self.filter_btns.append(cb)
            
        self.btn_clear = tk.Button(self.toolbar, text='Clear', command=self.clear, bg=self.colors.get('border', '#444'), fg=self.colors.get('foreground', 'white'), relief='flat')
        self.btn_clear.pack(side='right', padx=5)
        
        self.btn_save = tk.Button(self.toolbar, text='Save', command=self.save, bg=self.colors.get('border', '#444'), fg=self.colors.get('foreground', 'white'), relief='flat')
        self.btn_save.pack(side='right')
        
        self.text = scrolledtext.ScrolledText(self, state='disabled', bg=self.colors.get('entry_bg', '#1e1e1e'), fg=self.colors.get('entry_fg', '#d4d4d4'), font=('Consolas', 10), insertbackground=self.colors.get('entry_fg', 'white'))
        self.text.pack(fill='both', expand=True)
        
        self.text.tag_config('INFO', foreground=self.colors.get('entry_fg', '#d4d4d4'))
        self.text.tag_config('DEBUG', foreground=self.colors.get('accent', '#569cd6'))
        self.text.tag_config('WARNING', foreground='#ce9178')
        self.text.tag_config('ERROR', foreground=self.colors.get('error', '#f44747'))
        self.text.tag_config('timestamp', foreground='#608b4e')

    def _poll_queue(self):
        """Pulls logs from the queue and updates UI."""
        try:
            while True:
                record = self.log_queue.get_nowait()
                self._display(record)
        except queue.Empty:
            pass
        finally:
            self.after(100, self._poll_queue)

    def _display(self, record):
        level = record.levelname
        if not self.filters.get(level, tk.BooleanVar(value=True)).get():
            return
        msg = record.getMessage()
        ts = datetime.datetime.fromtimestamp(record.created).strftime('%H:%M:%S')
        self.text.config(state='normal')
        if msg == self.last_msg:
            self.last_count += 1
        else:
            self.last_msg = msg
            self.last_count = 1
        self.text.insert('end', f'[{ts}] ', 'timestamp')
        self.text.insert('end', f'{msg}\n', level)
        self.text.see('end')
        self.text.config(state='disabled')

    def refresh_theme(self, new_colors):
        """Re-applies new theme colors to the widget."""
        self.colors = new_colors
        self.configure(bg=self.colors.get('background'))
        self.toolbar.configure(bg=self.colors.get('panel_bg'))
        
        for btn in self.filter_btns:
            btn.configure(bg=self.colors.get('panel_bg'), fg=self.colors.get('foreground'), selectcolor=self.colors.get('border'))
            
        self.btn_clear.configure(bg=self.colors.get('border'), fg=self.colors.get('foreground'))
        self.btn_save.configure(bg=self.colors.get('border'), fg=self.colors.get('foreground'))
        
        self.text.configure(bg=self.colors.get('entry_bg'), fg=self.colors.get('entry_fg'), insertbackground=self.colors.get('entry_fg'))
        self.text.tag_config('INFO', foreground=self.colors.get('entry_fg'))
        self.text.tag_config('DEBUG', foreground=self.colors.get('accent'))
        self.text.tag_config('ERROR', foreground=self.colors.get('error'))

    @service_endpoint(inputs={}, outputs={}, description='Clears the log console.', tags=['ui', 'logs'], side_effects=['ui:update'])
    def clear(self):
        self.text.config(state='normal')
        self.text.delete('1.0', 'end')
        self.text.config(state='disabled')

    @service_endpoint(inputs={}, outputs={}, description='Opens a dialog to save logs to a file.', tags=['ui', 'filesystem'], side_effects=['filesystem:write', 'ui:dialog'])
    def save(self):
        path = filedialog.asksaveasfilename(defaultextension='.log', filetypes=[('Log Files', '*.log')])
        if path:
            try:
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(self.text.get('1.0', 'end'))
            except Exception as e:
                print(f'Save failed: {e}')
if __name__ == '__main__':
    root = tk.Tk()
    root.title('Log View Test')
    root.geometry('600x400')
    q = queue.Queue()
    logger = logging.getLogger('TestApp')
    logger.setLevel(logging.DEBUG)
    logger.addHandler(QueueHandler(q))
    log_view = LogViewMS({'parent': root, 'log_queue': q})
    print('Service ready:', log_view)
    log_view.pack(fill='both', expand=True)

    def generate_noise():
        logger.info('System initializing...')
        logger.debug('Checking sensors...')
        logger.warning('Sensor 4 response slow.')
        logger.error('Connection failed!')
        root.after(2000, generate_noise)
    generate_noise()
    root.mainloop()



--------------------------------------------------------------------------------
FILE: src\microservices\_MicroSpinnerMS.py
--------------------------------------------------------------------------------
import tkinter as tk
import math
import threading

class MicroSpinner:
    """
    A standalone ASCII spinner for Tkinter Text widgets.
    """
    def __init__(self, text_widget, center_row=5, center_col=20, radius=3, speed=0.2):
        self.txt = text_widget
        self.center_row = center_row
        self.center_col = center_col
        self.radius = radius
        self.speed = speed
        
        self.angle = 0.0
        self.is_running = False
        self.trail = []  # Stores (index, symbol)
        self.symbols = ["@", "#", "*", "+", ".", " "] # Fade sequence
        
        # Initialize a small blank area in the text box if empty
        if self.txt.get("1.0", tk.END).strip() == "":
            blank_block = (" " * 80 + "\n") * 20
            self.txt.insert("1.0", blank_block)

    def _get_pos(self, angle_offset=0):
        """Calculates a specific coordinate based on angle."""
        # 2.2 factor compensates for rectangular font pixels
        x = int(self.center_col + (self.radius * 2.2) * math.cos(self.angle - angle_offset))
        y = int(self.center_row + self.radius * math.sin(self.angle - angle_offset))
        return f"{y}.{x}"

    def update(self):
        if not self.is_running:
            # Clean up the trail when stopping
            for pos in self.trail:
                self._write_at(pos, " ")
            self.trail = []
            return

        # 1. Calculate current head position
        head_pos = self._get_pos(0)
        
        # 2. Add new head to trail, remove oldest if too long
        self.trail.insert(0, head_pos)
        if len(self.trail) > len(self.symbols):
            old_pos = self.trail.pop()
            self._write_at(old_pos, " ")

        # 3. Draw the trail with fading symbols
        for i, pos in enumerate(self.trail):
            symbol = self.symbols[i] if i < len(self.symbols) else " "
            self._write_at(pos, symbol)

        self.angle += self.speed
        self.txt.after(50, self.update)

    def _write_at(self, index, char):
        """Surgically replaces a single character at a Tkinter index."""
        try:
            self.txt.delete(index)
            self.txt.insert(index, char)
        except tk.TclError:
            pass # Handle case where text widget might be cleared externally

    def start(self):
        if not self.is_running:
            self.is_running = True
            self.update()

    def stop(self):
        self.is_running = False
--------------------------------------------------------------------------------
FILE: src\microservices\_OllamaModelSelectorMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _OllamaModelSelectorMS
ENTRY_POINT: _OllamaModelSelectorMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: requests
"""
import tkinter as tk
from tkinter import ttk
import requests
import threading
import logging
from typing import Dict, Any, Optional, List, Callable
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

OLLAMA_TAGS_URL = "http://localhost:11434/api/tags"

@service_metadata(
    name='OllamaModelSelector', 
    version='1.0.0', 
    description='The Lens: A UI widget that fetches and displays available local Ollama models.', 
    tags=['ui', 'ai', 'ollama', 'widget'], 
    capabilities=['ui:gui', 'network:outbound'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=['requests']
)
class OllamaModelSelectorMS(tk.Frame, BaseService):
    """
    The Lens.
    A dropdown widget that automatically polls the local Ollama API for models.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None, theme: Optional[Dict[str, Any]] = None, bus: Optional[Any] = None):
        # Initialize BaseService first for logging
        BaseService.__init__(self, 'OllamaModelSelector')
        
        self.config_data = config or {}
        self.colors = theme or {}
        self.bus = bus
        
        parent = self.config_data.get('parent')
        self.on_change_callback = self.config_data.get('on_change')
        
        # Initialize the Tkinter Frame
        tk.Frame.__init__(self, parent, bg=self.colors.get('panel_bg', '#252526'))

        if self.bus:
            self.bus.subscribe("theme_updated", self.refresh_theme)
        
        self.models: List[str] = ["Scanning..."]
        self._build_ui()
        
        # Start background scan so the UI doesn't hang
        threading.Thread(target=self.refresh_models, daemon=True).start()

    def _build_ui(self):
        """Creates the label and combobox."""
        self.label = tk.Label(
            self, text="AI MODEL:", 
            bg=self.colors.get('panel_bg', self.cget('bg')), 
            fg=self.colors.get('foreground', 'white'), 
            font=('Segoe UI', 9, 'bold')
        )
        self.label.pack(side='left', padx=(5, 10))

        self.combo = ttk.Combobox(self, values=self.models, state="readonly", width=25)
        self.combo.set(self.models[0])
        self.combo.pack(side='left', padx=5)
        self.combo.bind("<<ComboboxSelected>>", self._on_selection)

    @service_endpoint(
        inputs={}, 
        outputs={'models': 'List[str]'}, 
        description='Queries local Ollama API to refresh the list of available models.', 
        tags=['network', 'refresh']
    )
    # ROLE: Queries local Ollama API to refresh the list of available models.
    # INPUTS: {}
    # OUTPUTS: {"models": "List[str]"}
    def refresh_models(self) -> List[str]:
        """Fetches models from Ollama tags endpoint."""
        try:
            response = requests.get(OLLAMA_TAGS_URL, timeout=3)
            if response.status_code == 200:
                data = response.json()
                self.models = [m['name'] for m in data.get('models', [])]
                self.log_info(f"Discovered {len(self.models)} local models.")
            else:
                self.models = ["Ollama Offline"]
        except Exception as e:
            self.log_error(f"Failed to reach Ollama: {e}")
            self.models = ["Connection Error"]

        # Update the UI from the main thread
        self.after(0, lambda: self.combo.config(values=self.models))
        if self.models and self.models[0] not in ["Connection Error", "Ollama Offline"]:
            self.after(0, lambda: self.combo.current(0))
        
        return self.models

    def _on_selection(self, event):
        """Triggered when the user picks a new model."""
        selected = self.combo.get()
        self.log_info(f"Model selected: {selected}")
        if self.on_change_callback:
            self.on_change_callback(selected)

    @service_endpoint(
        inputs={}, 
        outputs={'selected_model': 'str'}, 
        description='Returns the currently selected model string.', 
        tags=['ui', 'read']
    )
    # ROLE: Returns the currently selected model string.
    # INPUTS: {}
    # OUTPUTS: {"selected_model": "str"}
    def get_selected_model(self) -> str:
        """Retrieves current selection from the combobox."""
        return self.combo.get()

    def refresh_theme(self, new_colors):
        """Re-applies new theme colors to the widget."""
        self.colors = new_colors
        self.configure(bg=self.colors.get('panel_bg'))
        self.label.configure(
            bg=self.colors.get('panel_bg'), 
            fg=self.colors.get('foreground')
        )

if __name__ == '__main__':
    root = tk.Tk()
    root.title("Ollama Selector Test")
    root.geometry("400x100")
    
    # Simple callback test
    def log_change(m): print(f"Signal emitted for model: {m}")
    
    selector = OllamaModelSelectorMS({'parent': root, 'on_change': log_change})
    selector.pack(pady=20)
    
    root.mainloop()


--------------------------------------------------------------------------------
FILE: src\microservices\_RegexWeaverMS.py
--------------------------------------------------------------------------------
import re
import logging
from typing import Any, Dict, List, Optional, Set
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
PY_IMPORT = re.compile('^\\s*(?:from|import)\\s+([\\w\\.]+)')
JS_IMPORT = re.compile('(?:import\\s+.*?from\\s+[\\\'"]|require\\([\\\'"])([\\.\\/\\w\\-_]+)[\\\'"]')
logger = logging.getLogger('RegexWeaver')

@service_metadata(name='RegexWeaver', version='1.0.0', description='Fault-tolerant dependency extractor using Regex.', tags=['parsing', 'dependencies', 'regex'], capabilities=['compute'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class RegexWeaverMS(BaseService):
    """
    The Weaver: A fault-tolerant dependency extractor.
    Uses Regex to find imports, making it faster and more permissive
    than AST parsers (works on broken code).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('RegexWeaver')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'language': 'str'}, outputs={'dependencies': 'List[str]'}, description='Scans code content for import statements.', tags=['parsing', 'dependencies'], side_effects=[])
    # ROLE: Scans code content for import statements.
    # INPUTS: {"content": "str", "language": "str"}
    # OUTPUTS: {"dependencies": "List[str]"}
    def extract_dependencies(self, content: str, language: str) -> List[str]:
        """
        Scans code content for import statements.
        :param language: 'python' or 'javascript' (includes ts/jsx).
        """
        dependencies: Set[str] = set()
        lines = content.splitlines()
        pattern = PY_IMPORT if language == 'python' else JS_IMPORT
        for line in lines:
            if line.strip().startswith(('#', '//')):
                continue
            if language == 'python':
                match = pattern.match(line)
            else:
                match = pattern.search(line)
            if match:
                raw_dep = match.group(1)
                clean_dep = raw_dep.split('.')[-1].split('/')[-1]
                dependencies.add(clean_dep)
        return sorted(list(dependencies))
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    weaver = RegexWeaverMS()
    print('Service ready:', weaver)
    py_code = '\n    import os\n    from backend.utils import helper\n    # from commented.out import ignore_me\n    import pandas as pd\n    '
    print(f"Python Deps: {weaver.extract_dependencies(py_code, 'python')}")
    js_code = "\n    import React from 'react';\n    const utils = require('./lib/utils');\n    // import hidden from 'hidden';\n    "
    print(f"JS Deps:     {weaver.extract_dependencies(js_code, 'javascript')}")


--------------------------------------------------------------------------------
FILE: src\microservices\_RulesEngineMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _RulesEngineMS
ROLE: Operator Governance (Task 4.3)
"""
import logging
from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
def get_default_rules() -> Dict[str, Any]:
    """
    Returns the default safety contracts.
    Hardcoded here to remove dependency on external contract files.
    """
    return {
        "max_hunk_size": 10000,
        "protected_files": [
            "LICENSE.md", 
            "setup_env.bat", 
            ".gitignore",
            "requirements.txt"
        ],
        "forbidden_patterns": [
            "sk-proj-",  # OpenAI keys
            "ghp_",      # GitHub tokens
            "password ="
        ]
    }

@service_metadata(
    name='RulesEngine', 
    version='1.0.0', 
    description='Governance engine for safety and file protection.',
    tags=['governance', 'safety'],
    internal_dependencies=['base_service', 'microservice_std_lib']
)
class RulesEngineMS(BaseService):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('RulesEngine')
        self.rules = get_default_rules()

    @service_endpoint(
        inputs={}, 
        outputs={'rules': 'Dict'},
        description='Returns current active ruleset.'
    )
    # ROLE: Returns current active ruleset.
    # INPUTS: {}
    # OUTPUTS: {"rules": "Dict"}
    def get_rules(self) -> Dict[str, Any]:
        return self.rules.copy()

    def get_rules(self) -> Dict[str, Any]:
        return self.rules.copy()

    def set_rules(self, new_rules: Dict[str, Any]):
        self.rules.update(new_rules)
        self.logger.info("Ruleset updated.")

    def evaluate_file(self, file_path: str) -> tuple:
        """Checks if a file is protected."""
        for p in self.rules.get("protected_files", []):
            if p in file_path:
                return False, f"File is protected by rule: {p}"
        return True, ""

    def evaluate_hunk(self, hunk: dict) -> tuple:
        """Checks hunk constraints like size or forbidden patterns."""
        content = hunk.get('content', '')
        if len(content) > self.rules.get("max_hunk_size", 99999):
            return False, "Hunk exceeds max_hunk_size"
            
        for pattern in self.rules.get("forbidden_patterns", []):
            if pattern in content:
                return False, f"Hunk contains forbidden pattern: {pattern}"
                
        return True, ""





--------------------------------------------------------------------------------
FILE: src\microservices\_SemanticChunkerMS.py
--------------------------------------------------------------------------------
import ast
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@dataclass
class CodeChunk:
    name: str
    type: str
    content: str
    start_line: int
    end_line: int
    docstring: str = ''

@service_metadata(name='SemanticChunker', version='1.0.0', description='The Surgeon: Intelligent Code Splitter that parses source code into logical semantic units (Classes, Functions) using AST.', tags=['utility', 'nlp', 'parser'], capabilities=['python-ast', 'semantic-chunking'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class SemanticChunkerMS(BaseService):
    """
    Intelligent Code Splitter.
    Parses source code into logical units (Classes, Functions) 
    rather than arbitrary text windows.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('SemanticChunker')
        self.config = config or {}

    @service_endpoint(inputs={'content': 'str', 'filename': 'str'}, outputs={'chunks': 'List[Dict]'}, description='Main entry point to split a file into semantic chunks based on its extension and content.', tags=['processing', 'chunking'], side_effects=[])
    # ROLE: Main entry point to split a file into semantic chunks based on its extension and content.
    # INPUTS: {"content": "str", "filename": "str"}
    # OUTPUTS: {"chunks": "List[Dict]"}
    def chunk_file(self, content: str, filename: str) -> List[Dict[str, Any]]:
        """
        Splits file content into chunks.
        Returns a list of dictionaries suitable for JSON response.
        """
        chunks: List[CodeChunk] = []
        if filename.endswith('.py'):
            chunks = self._chunk_python(content)
        elif filename.lower().endswith(('.md', '.txt', '.pdf', '.html', '.htm', '.rst')):
            chunks = self._chunk_generic(content, window_size=800)
        else:
            chunks = self._chunk_generic(content, window_size=1500)
        return [asdict(c) for c in chunks]

    def _chunk_python(self, source: str) -> List[CodeChunk]:
        chunks = []
        try:
            tree = ast.parse(source)
            lines = source.splitlines(keepends=True)

            def get_segment(node):
                start = node.lineno - 1
                end = node.end_lineno if hasattr(node, 'end_lineno') and node.end_lineno else start + 1
                return (''.join(lines[start:end]), start + 1, end)
            for node in tree.body:
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ''
                    chunks.append(CodeChunk(name=f'def {node.name}', type='function', content=text, start_line=s, end_line=e, docstring=doc))
                elif isinstance(node, ast.ClassDef):
                    text, s, e = get_segment(node)
                    doc = ast.get_docstring(node) or ''
                    chunks.append(CodeChunk(name=f'class {node.name}', type='class', content=text, start_line=s, end_line=e, docstring=doc))
            if not chunks:
                return self._chunk_generic(source)
        except SyntaxError:
            return self._chunk_generic(source)
        return chunks

    def _chunk_generic(self, text: str, window_size: int=1500) -> List[CodeChunk]:
        """Sliding window for non-code files."""
        chunks = []
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        lines = text.splitlines(keepends=True)
        current_chunk = []
        current_size = 0
        chunk_idx = 1
        start_line = 1
        for i, line in enumerate(lines):
            current_chunk.append(line)
            current_size += len(line)
            if current_size >= window_size:
                chunks.append(CodeChunk(name=f'Chunk {chunk_idx}', type='text_block', content=''.join(current_chunk), start_line=start_line, end_line=i + 1))
                current_chunk = []
                current_size = 0
                chunk_idx += 1
                start_line = i + 2
        if current_chunk:
            chunks.append(CodeChunk(name=f'Chunk {chunk_idx}', type='text_block', content=''.join(current_chunk), start_line=start_line, end_line=len(lines)))
        return chunks
if __name__ == '__main__':
    svc = SemanticChunkerMS()
    print('Service ready:', svc)
    test_code = "def hello():\n    print('world')\n\nclass Test:\n    pass"
    results = svc.chunk_file(test_code, 'test.py')
    print(f'Extracted {len(results)} semantic chunks.')
    for c in results:
        print(f" - [{c['type']}] {c['name']} ({c['start_line']}-{c['end_line']})")
        print(f" - [{c['type']}] {c['name']} ({c['start_line']}-{c['end_line']})")


--------------------------------------------------------------------------------
FILE: src\microservices\_SessionRecorderMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _SessionRecorderMS
ENTRY_POINT: _SessionRecorderMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import os
import datetime
import json
from typing import Dict, Any, Optional
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='SessionRecorder', 
    version='1.0.0', 
    description='The Black Box: Records all project tidying events to a persistent audit log.', 
    tags=['utility', 'logging', 'audit'], 
    capabilities=['filesystem:write'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=[]
)
class SessionRecorderMS(BaseService):
    """
    The Black Box.
    Listens to the SignalBus and writes a chronological record of all actions to disk.
    """

    def __init__(self, state, config: Optional[Dict[str, Any]] = None):
        super().__init__('SessionRecorder')
        self.state = state
        self.config = config or {}
        
        # Set up the log directory
        self.logs_dir = self.config.get('logs_dir', 'tidy_logs')
        os.makedirs(self.logs_dir, exist_ok=True)
        
        # Create a unique filename for this session
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = os.path.join(self.logs_dir, f"tidy_session_{timestamp}.log")
        
        self.log_info(f"Session Recorder initialized. Logging to: {self.log_file}")
        self._write_entry("SESSION_START", {"msg": "Project Tidier session initiated."})

    def _write_entry(self, event_type: str, data: Any):
        """Writes a structured, timestamped entry to the log file."""
        timestamp = datetime.datetime.now().isoformat()
        entry = {
            "timestamp": timestamp,
            "event": event_type,
            "data": data
        }
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            self.log_error(f"Failed to write to audit log: {e}")

    # --- Signal Handlers ---

    def on_scan_started(self, data: Dict[str, Any]):
        self._write_entry("SCAN_INITIATED", data)

    def on_hunk_detected(self, data: Dict[str, Any]):
        # Log that clutter was found, including the filename and hunk name
        log_payload = {
            "file": data.get("file"),
            "hunk": data.get("hunk_name"),
            "chars_before": len(data.get("before", "")),
            "chars_after": len(data.get("after", ""))
        }
        self._write_entry("CLUTTER_DETECTED", log_payload)

    def on_user_decision(self, approved: bool):
        status = "APPROVED" if approved else "SKIPPED"
        # Record decision alongside the current authoritative state phase
        log_payload = {
            "status": status,
            "phase_at_decision": self.state.phase.name,
            "file_affected": self.state.pending_review.get('file') if self.state.pending_review else None
        }
        self._write_entry("USER_DECISION", log_payload)

    def on_commit_success(self, file_path: str):
        self._write_entry("FILE_COMMITTED", {"path": file_path})

if __name__ == '__main__':
    # Test Harness
    recorder = SessionRecorderMS({'logs_dir': '_test_logs'})
    recorder.on_scan_started({"paths": ["C:/test/project"]})
    recorder.on_hunk_detected({"file": "test.py", "hunk_name": "def test()", "before": "...", "after": ".."})
    print(f"Test entries written to: {recorder.log_file}")


--------------------------------------------------------------------------------
FILE: src\microservices\_SignalBusMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _SignalBusMS
ENTRY_POINT: _SignalBusMS.py
INTERNAL_DEPENDENCIES: base_service, microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import logging
import threading
from typing import Dict, List, Any, Optional, Callable
from .base_service import BaseService
from .microservice_std_lib import service_metadata, service_endpoint

@service_metadata(
    name='SignalBus', 
    version='1.0.0', 
    description='The Spine: A central pub/sub event hub for decoupled communication between services.', 
    tags=['utility', 'events', 'communication'], 
    capabilities=['pub-sub', 'event-routing'], 
    internal_dependencies=['base_service', 'microservice_std_lib'], 
    external_dependencies=[]
)
class SignalBusMS(BaseService):
    """
    The Spine.
    Provides a thread-safe mechanism for services to subscribe to and emit named signals.
    """
    
    # --- Standard Event Contracts ---
    SIGNAL_PROCESS_START = "process_start"
    SIGNAL_PROCESS_COMPLETE = "process_complete"
    SIGNAL_SPAWN_REQUESTED = "cell_spawn_requested"
    SIGNAL_LOG_APPEND = "log_append"
    SIGNAL_ERROR = "notify_error"

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('SignalBus')
        self.config = config or {}
        self._subscribers: Dict[str, List[Callable]] = {}
        self._lock = threading.RLock()

    @service_endpoint(
        inputs={'signal_name': 'str', 'callback': 'Callable'}, 
        outputs={}, 
        description='Registers a callback function to trigger when a specific signal is emitted.', 
        tags=['events', 'subscribe']
    )
    # ROLE: Registers a callback function to trigger when a specific signal is emitted.
    # INPUTS: {"callback": "Callable", "signal_name": "str"}
    # OUTPUTS: {}
    def subscribe(self, signal_name: str, callback: Callable):
        """Adds a listener for a specific signal."""
        with self._lock:
            if signal_name not in self._subscribers:
                self._subscribers[signal_name] = []
            if callback not in self._subscribers[signal_name]:
                self._subscribers[signal_name].append(callback)
                self.log_info(f"New subscriber for signal: {signal_name}")

    @service_endpoint(
        inputs={'signal_name': 'str', 'data': 'Any'}, 
        outputs={'delivered_to': 'int'}, 
        description='Broadcasts data to all subscribers of a specific signal.', 
        tags=['events', 'emit']
    )
    # ROLE: Broadcasts data to all subscribers of a specific signal.
    # INPUTS: {"data": "Any", "signal_name": "str"}
    # OUTPUTS: {"delivered_to": "int"}
    def emit(self, signal_name: str, data: Any = None) -> int:
        """Broadcasts a signal to all registered listeners."""
        count = 0
        with self._lock:
            listeners = self._subscribers.get(signal_name, []).copy()
        
        if listeners:
            self.log_info(f"Emitting signal: {signal_name}")
            for callback in listeners:
                try:
                    # Trigger the callback with the data payload
                    callback(data)
                    count += 1
                except Exception as e:
                    self.log_error(f"Error in signal '{signal_name}' callback: {e}")
        
        return count

    @service_endpoint(
        inputs={'signal_name': 'str', 'callback': 'Callable'}, 
        outputs={}, 
        description='Removes a previously registered callback.', 
        tags=['events', 'unsubscribe']
    )
    # ROLE: Removes a previously registered callback.
    # INPUTS: {"callback": "Callable", "signal_name": "str"}
    # OUTPUTS: {}
    def unsubscribe(self, signal_name: str, callback: Callable):
        """Removes a listener from a signal."""
        with self._lock:
            if signal_name in self._subscribers:
                try:
                    self._subscribers[signal_name].remove(callback)
                    self.log_info(f"Unsubscribed from signal: {signal_name}")
                except ValueError:
                    pass

if __name__ == '__main__':
    # Test Harness
    bus = SignalBusMS()
    
    def on_hunk_ready(data):
        print(f"UI received hunk: {data}")

    print("--- Testing SignalBusMS ---")
    bus.subscribe("hunk_processed", on_hunk_ready)
    
    # Simulate a backend event
    delivered = bus.emit("hunk_processed", {"file": "app.py", "lines": 50})
    print(f"Signal delivered to {delivered} listeners.")


--------------------------------------------------------------------------------
FILE: src\microservices\_TelemetryServiceMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TelemetryServiceMS
ROLE: Authoritative Session Journal (Task 3)
"""
import logging
import queue
import time
import datetime
from typing import Dict, Any, Optional, List
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

try:
    from .event_contract import summarize_event, normalize_error
except ImportError:
    # Fallback if contract file is missing
    def summarize_event(e, p): return f"Event: {e}"
    def normalize_error(e): return str(e)

logger = logging.getLogger('TelemetryService')

@service_metadata(
    name='TelemetryService', 
    version='2.0.0', 
    description='Authoritative Session Journal: Maintains a structured event buffer and state snapshot.', 
    tags=['utility', 'logging', 'telemetry'], 
    capabilities=['event-journaling', 'state-snapshotting']
)
class TelemetryServiceMS(BaseService):
    def __init__(self, state, config: Optional[Dict[str, Any]]=None):
        super().__init__('TelemetryService')
        self.state_authority = state # The AppRuntimeState object
        self.config = config or {}
        
        # 1. Authoritative Journal Storage
        self.event_buffer: List[Dict[str, Any]] = []
        self.buffer_limit = self.config.get('buffer_limit', 1000)
        
        # 2. Local State Snapshot (Enriched for UI consumption)
        self.snapshot = {
            "phase": "IDLE",
            "active_file": None,
            "waiting_for_review": False,
            "current_model": "unknown",
            "last_error": None,
            "counters": {"errors": 0, "commits": 0, "hunks": 0}
        }

    def track(self, event_name: str, payload: Any = None, source: str = "system"):
        """Records a structured event into the ring buffer."""
        try:
            timestamp = datetime.datetime.now().strftime("%H:%M:%S")

            # Normalize payload if it's an error
            safe_payload = payload
            if "error" in event_name:
                normalized = normalize_error(payload)
                safe_payload = normalized
                if isinstance(normalized, dict):
                    self.snapshot["last_error"] = normalized.get("message")
                else:
                    self.snapshot["last_error"] = str(normalized)

            if event_name == "model_swapped":
                self.snapshot["current_model"] = str(payload)

            entry = {
                "ts": timestamp,
                "event": event_name,
                "source": source,
                "payload": self._sanitize_payload(safe_payload),
                "summary": self._generate_summary(event_name, safe_payload),
            }

            self.event_buffer.append(entry)
            if len(self.event_buffer) > self.buffer_limit:
                # Keep only the most recent N entries
                self.event_buffer = self.event_buffer[-self.buffer_limit:]

        except Exception as e:
            # Fallback if logging fails to prevent recursion loops
            print(f"Telemetry Error: {e}")

        # Update local counters based on event type
        self._update_counters(event_name)

        # Emit signal that telemetry has updated (for future UI refresh)
        # Note: We use a try/except in case the bus isn't available during tests
        try:
            if hasattr(self, 'bus'):
                self.bus.emit("telemetry_updated", self.get_snapshot())
        except Exception:
            pass
    def _sanitize_payload(self, payload: Any) -> Any:
        """Ensures payload is safe for storage and serialization."""
        if isinstance(payload, (str, int, float, bool, type(None))):
            return payload
        if isinstance(payload, dict):
            return {k: str(v)[:100] for k, v in payload.items()} # Limit string size
        return str(payload)[:200]

    def _generate_summary(self, event: str, payload: Any) -> str:
        """Uses the central event contract to generate a summary."""
        try:
            return summarize_event(event, payload)
        except Exception as e:
            return f"Event: {event} (Summary Error: {e})"

    def _update_counters(self, event: str):
        if "error" in event: self.snapshot["counters"]["errors"] += 1
        if "commit_success" == event: self.snapshot["counters"]["commits"] += 1
        if "hunk_ready_for_review" == event: self.snapshot["counters"]["hunks"] += 1

    def get_snapshot(self) -> Dict[str, Any]:
        """Returns a combined view of the authority state and local counters."""
        return {
            "phase": self.state_authority.phase.name,
            "engine_blocked": self.state_authority.engine_blocked,
            "active_file": self.state_authority.pending_review.get('file') if self.state_authority.pending_review else None,
            "current_model": self.snapshot["current_model"],
            "last_error": self.snapshot["last_error"],
            "counters": self.snapshot["counters"]
        }

    def get_recent_events(self, limit: int = 50) -> List[Dict[str, Any]]:
        return self.event_buffer[-limit:]




--------------------------------------------------------------------------------
FILE: src\microservices\_TextChunkerMS.py
--------------------------------------------------------------------------------
import logging
from typing import Any, Dict, List, Optional, Tuple
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
logger = logging.getLogger('TextChunker')

@service_metadata(name='TextChunker', version='1.0.0', description='Splits text into chunks using various strategies (chars, lines).', tags=['chunking', 'nlp', 'rag'], capabilities=['compute'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TextChunkerMS(BaseService):
    """
    The Butcher: A unified service for splitting text into digestible chunks
    for RAG (Retrieval Augmented Generation).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('TextChunker')
        self.config = config or {}

    @service_endpoint(inputs={'text': 'str', 'chunk_size': 'int', 'chunk_overlap': 'int'}, outputs={'chunks': 'List[str]'}, description='Standard sliding window split by character count.', tags=['chunking', 'chars'], side_effects=[])
    # ROLE: Standard sliding window split by character count.
    # INPUTS: {"chunk_overlap": "int", "chunk_size": "int", "text": "str"}
    # OUTPUTS: {"chunks": "List[str]"}
    def chunk_by_chars(self, text: str, chunk_size: int=500, chunk_overlap: int=50) -> List[str]:
        """
        Standard Sliding Window. Best for prose/documentation.
        Splits purely by character count.
        """
        if chunk_size <= 0:
            raise ValueError('chunk_size must be positive')
        chunks = []
        start = 0
        text_length = len(text)
        while start < text_length:
            end = start + chunk_size
            chunk = text[start:end]
            chunks.append(chunk)
            if end >= text_length:
                break
            start += chunk_size - chunk_overlap
        return chunks

    @service_endpoint(inputs={'text': 'str', 'max_lines': 'int', 'max_chars': 'int'}, outputs={'chunks': 'List[Dict]'}, description='Line-preserving chunker, best for code.', tags=['chunking', 'lines', 'code'], side_effects=[])
    # ROLE: Line-preserving chunker, best for code.
    # INPUTS: {"max_chars": "int", "max_lines": "int", "text": "str"}
    # OUTPUTS: {"chunks": "List[Dict]"}
    def chunk_by_lines(self, text: str, max_lines: int=200, max_chars: int=4000) -> List[Dict[str, Any]]:
        """
        Line-Preserving Chunker. Best for Code.
        Respects line boundaries and returns metadata about line numbers.
        """
        lines = text.splitlines()
        chunks = []
        start = 0
        while start < len(lines):
            end = min(start + max_lines, len(lines))
            chunk_str = '\n'.join(lines[start:end])
            while len(chunk_str) > max_chars and end > start + 1:
                end -= 1
                chunk_str = '\n'.join(lines[start:end])
            chunks.append({'text': chunk_str, 'start_line': start + 1, 'end_line': end})
            start = end
        return chunks
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    chunker = TextChunkerMS()
    print('Service ready:', chunker)
    print('--- Prose Chunking ---')
    lorem = 'A' * 100
    result = chunker.chunk_by_chars(lorem, chunk_size=40, chunk_overlap=10)
    for i, c in enumerate(result):
        print(f'Chunk {i}: len={len(c)}')
    print('\n--- Code Chunking ---')
    code = '\n'.join([f"print('Line {i}')" for i in range(1, 10)])
    result_code = chunker.chunk_by_lines(code, max_lines=3, max_chars=100)
    for i, c in enumerate(result_code):
        print(f"Chunk {i}: Lines {c['start_line']}-{c['end_line']}")


--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterAppShellMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterAppShellMS
ENTRY_POINT: _TkinterAppShellMS.py
INTERNAL_DEPENDENCIES: _TkinterThemeManagerMS, microservice_std_lib, base_service
EXTERNAL_DEPENDENCIES: None

This module provides the root Tkinter application shell. It owns the
Tkinter root window, manages global theme propagation and hosts
embedded UI components.
"""

import tkinter as tk
from tkinter import ttk
import logging
from typing import Dict, Any, Optional

from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

# Attempt to import our theme manager.
try:
    from ._TkinterThemeManagerMS import TkinterThemeManagerMS  # type: ignore
except Exception as ex:
    TkinterThemeManagerMS = None
    logging.getLogger("AppShell").warning(
        "Theme manager could not be imported: %s. Falling back to defaults.", ex
    )

logger = logging.getLogger("AppShell")


@service_metadata(
    name="TkinterAppShell",
    version="2.1.1",
    description="The Mother Ship: Root UI container that manages the lifecycle of recursive Cell windows.",
    tags=["ui", "shell", "container"],
    capabilities=["ui:gui", "window-management"],
    internal_dependencies=["_TkinterThemeManagerMS", "microservice_std_lib", "base_service"],
)
class TkinterAppShellMS(BaseService):
    """
    The Mother Ship.
    Owns the Tk root window and provides a stable lifecycle contract for the app.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("TkinterAppShell")
        self.config = config or {}

        # 1) Root Window
        self.root = tk.Tk()
        self.root.title(self.config.get("title", "_theCELL - Idea Ingestor"))
        self.root.geometry(self.config.get("geometry", "1000x800"))

        # 2) Theme Management
        self.theme_manager = None
        self.colors = {
            "background": "#1e1e1e",
            "foreground": "#cccccc",
            "panel_bg": "#252526",
            "accent": "#007acc",
            # optional UI keys some screens may ask for:
            "entry_bg": "#1e1e1e",
            "entry_fg": "#cccccc",
            "select_bg": "#264f78",
            "button_fg": "#cccccc",
        }

        if TkinterThemeManagerMS:
            theme_pref = (self.config.get("theme") or "Dark").strip().title()
            self.theme_manager = TkinterThemeManagerMS({"theme": theme_pref})
            try:
                self.colors = self.theme_manager.get_theme()
            except Exception:
                # fallback to defaults if theme manager is partially implemented
                pass
            self.log_info(f"Theme Manager initialized with '{theme_pref}' theme.")

        self.root.configure(bg=self.colors.get("background"))

        # 3) Main Container (the docking zone)
        self.main_container = tk.Frame(self.root, bg=self.colors.get("background"))
        self.main_container.pack(fill="both", expand=True)

        # If any build withdraws to avoid a flash, we still safely deiconify in launch()
        # (no-op if not withdrawn).
        # self.root.withdraw()

    # -------------------------------------------------------------------------
    # LIFECYCLE (IMPORTANT: app.py expects shell.launch())
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={},
        outputs={},
        description="Starts the GUI main loop.",
        tags=["lifecycle", "start"],
        side_effects=["ui:block"],
    )
    # ROLE: Starts the GUI main loop.
    # INPUTS: {}
    # OUTPUTS: {}
    def launch(self) -> None:
        """Ignition sequence start."""
        try:
            self.root.deiconify()
        except Exception:
            pass

        try:
            self.log_info("AppShell Launched.")
        except Exception:
            logger.info("AppShell Launched.")

        self.root.mainloop()

    @service_endpoint(
        inputs={},
        outputs={},
        description="Gracefully shuts down the application.",
        tags=["lifecycle", "stop"],
        side_effects=["ui:close"],
    )
    # ROLE: Gracefully shuts down the application.
    # INPUTS: {}
    # OUTPUTS: {}
    def shutdown(self) -> None:
        """Closes the Tkinter event loop and destroys the root window."""
        self.log_info("Shutting down Application Shell.")
        try:
            # quit() exits mainloop; destroy() removes windows
            self.root.quit()
            self.root.destroy()
        except Exception:
            pass

    # -------------------------------------------------------------------------
    # THEME
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={"theme_name": "str"},
        outputs={"success": "bool"},
        description="Switches the global application theme (e.g., Dark, Light).",
        tags=["ui", "theme"],
        side_effects=["ui:refresh"],
    )
    # ROLE: Switches the global application theme (e.g., Dark, Light).
    # INPUTS: {"theme_name": "str"}
    # OUTPUTS: {"success": "bool"}
    def set_theme(self, theme_name: str) -> bool:
        """Updates the theme and propagates colors to the shell."""
        if not self.theme_manager:
            return False

        theme_name = (theme_name or "Dark").strip().title()
        success = False
        try:
            success = bool(self.theme_manager.set_theme(theme_name))
        except Exception:
            success = False

        if success:
            try:
                self.colors = self.theme_manager.get_theme()
            except Exception:
                pass
            self.root.configure(bg=self.colors.get("background"))
            self.main_container.configure(bg=self.colors.get("background"))
            self.log_info(f"Theme switched to {theme_name}")

        return success

    # -------------------------------------------------------------------------
    # LAYOUT + WINDOWS
    # -------------------------------------------------------------------------

    @service_endpoint(
        inputs={},
        outputs={"container": "tk.Frame"},
        description="Returns the main content area for other services to dock into.",
        tags=["ui", "layout"],
    )
    # ROLE: Returns the main content area for other services to dock into.
    # INPUTS: {}
    # OUTPUTS: {"container": "tk.Frame"}
    def get_main_container(self) -> tk.Frame:
        """Other services call this to know where to pack() themselves."""
        return self.main_container

    @service_endpoint(
        inputs={"title": "str", "geometry": "str"},
        outputs={"window": "tk.Toplevel"},
        description="Spawns a new top-level window for a child cell.",
        tags=["ui", "lifecycle"],
    )
    # ROLE: Spawns a new top-level window for a child cell.
    # INPUTS: {"geometry": "str", "title": "str"}
    # OUTPUTS: {"window": "tk.Toplevel"}
    def spawn_window(self, title: str = "Child Cell", geometry: str = "1000x800") -> tk.Toplevel:
        """Creates a new Toplevel window that inherits the shell's theme."""
        new_window = tk.Toplevel(self.root)
        new_window.title(title)
        new_window.geometry(geometry)
        bg = self.colors.get("background", "#1e1e1e")
        new_window.configure(bg=bg)
        self.log_info(f"Spawned new window: {title}")
        return new_window


if __name__ == "__main__":
    # Test Harness
    logging.basicConfig(level=logging.INFO)
    shell = TkinterAppShellMS({"title": "Shell Test Window"})
    print(f"Shell Ready: {shell._service_info['id']}")
    shell.launch()

--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterSmartExplorerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterSmartExplorerMS
ENTRY_POINT: _TkinterSmartExplorerMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None
"""
import tkinter as tk
from tkinter import ttk
from typing import Dict, Any, Optional, List
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

@service_metadata(name='TkinterSmartExplorer', version='1.0.0', description='A hierarchical tree viewer capable of displaying file systems or JSON data structures.', tags=['ui', 'widget', 'explorer'], capabilities=['ui:gui'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TkinterSmartExplorerMS(tk.Frame, BaseService):
    """
    The Navigator.
    A TreeView widget that expects standard 'Node' dictionaries (name, type, children).
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        self.config = config or {}
        parent = self.config.get('parent')
        
        # Multi-inheritance initialization
        BaseService.__init__(self, 'TkinterSmartExplorer')
        theme = self.config.get('theme', {})
        tk.Frame.__init__(self, parent, bg=theme.get('panel_bg', '#252526'))
        self.tree = ttk.Treeview(self, show='tree headings', selectmode='browse')
        self.tree.heading('#0', text='Explorer', anchor='w')
        vsb = ttk.Scrollbar(self, orient='vertical', command=self.tree.yview)
        hsb = ttk.Scrollbar(self, orient='horizontal', command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        self.tree.pack(side='left', fill='both', expand=True)
        vsb.pack(side='right', fill='y')
        self.icons = {'folder': 'ðŸ“', 'file': 'ðŸ“„', 'web': 'ðŸŒ', 'unknown': 'â“'}

    @service_endpoint(inputs={'data': 'Dict'}, outputs={}, description="Populates the tree view with a nested dictionary structure (Standard 'Node' format).", tags=['ui', 'update'], side_effects=['ui:update'])
    # ROLE: Populates the tree view with a nested dictionary structure (Standard 'Node' format).
    # INPUTS: {"data": "Dict"}
    # OUTPUTS: {}
    def load_data(self, data: Dict[str, Any]):
        """
        Ingests a dictionary tree (like from _ScoutMS or _TreeMapperMS).
        """
        for item in self.tree.get_children():
            self.tree.delete(item)
        self._build_node('', data)

    def _build_node(self, parent_id, node_data):
        ntype = node_data.get('type', 'unknown')
        icon = self.icons.get(ntype, self.icons['unknown'])
        text = f"{icon} {node_data.get('name', '???')}"
        item_id = self.tree.insert(parent_id, 'end', text=text, open=True)
        for child in node_data.get('children', []):
            self._build_node(item_id, child)
if __name__ == '__main__':
    root = tk.Tk()
    explorer = TkinterSmartExplorerMS({'parent': root})
    explorer.pack(fill='both', expand=True)
    dummy_data = {'name': 'Project Root', 'type': 'folder', 'children': [{'name': 'src', 'type': 'folder', 'children': []}, {'name': 'README.md', 'type': 'file'}]}
    explorer.load_data(dummy_data)
    root.mainloop()


--------------------------------------------------------------------------------
FILE: src\microservices\_TkinterThemeManagerMS.py
--------------------------------------------------------------------------------
"""
SERVICE_NAME: _TkinterThemeManagerMS
ENTRY_POINT: _TkinterThemeManagerMS.py
INTERNAL_DEPENDENCIES: microservice_std_lib
EXTERNAL_DEPENDENCIES: None

This module defines and manages the colour palette used throughout the
application.  A `TkinterThemeManagerMS` class encapsulates two
predefined themesâ€”`Dark` and `Light`â€”inspired by the Visual Studio
Code default themes.  Themes can be swapped at runtime and are
returned as mutable dictionaries so that UI components can reference
their values directly and respond to changes.

To add a new theme, extend the `THEMES` dictionary with the
appropriate keys.  See the definitions of `DARK_THEME` and
`LIGHT_THEME` for guidance on required keys.
"""

from typing import Dict, Any, Optional
from .microservice_std_lib import service_metadata, service_endpoint


"""
Defines colour palettes for supported themes.

These palettes draw inspiration from the Visual Studio Code default
dark and light themes to provide a comfortable and familiar
development environment.  Colours are carefully chosen to avoid
highâ€‘contrast combinations that can lead to eye strain while still
maintaining adequate contrast for accessibility.  Should additional
themes be added in the future, follow the same structure and include
keys for all UI elements consumed throughout the UI.
"""

# VisualÂ StudioÂ Code inspired dark theme.  The underlying palette
# uses neutral greys and blue accents similar to VSÂ Codeâ€™s default
# dark theme.  Colours have been adjusted to be less harsh while
# maintaining sufficient contrast.
DARK_THEME: Dict[str, Any] = {
    'name': 'Dark',
    # Primary backgrounds and foregrounds
    'background': '#1e1e1e',        # main window background
    'foreground': '#d4d4d4',        # primary text colour
    'panel_bg': '#252526',          # toolbar, config panels
    'border': '#3c3c3c',            # borders and separators
    'accent': '#007acc',            # accent colour for buttons and highlights
    'error': '#f44747',             # error messages / destructive actions
    'success': '#89d185',           # success messages

    # Fonts (kept here for completeness but rarely overridden)
    'font_main': ('Segoe UI', 10),
    'font_mono': ('Consolas', 11),

    # Button styling
    'button_bg': '#0e639c',         # primary button background
    'button_fg': '#ffffff',         # primary button text colour

    # Input/entry styling
    'entry_bg': '#1e1e1e',          # entry and text box background
    'entry_fg': '#d4d4d4',          # entry text colour

    # Selection colours
    'select_bg': '#264f78',         # selection background (lists/text)
    'select_fg': '#ffffff',         # selection text colour

    # Table/heading styling
    'heading_bg': '#3c3c3c',        # table headings background
    'heading_fg': '#ffffff',        # table headings text colour
    'heading_font': ('Segoe UI', 12, 'bold'),
}

# VisualÂ StudioÂ Code inspired light theme.  The palette uses soft
# greys with a blue accent, mirroring VSÂ Codeâ€™s light theme while
# avoiding stark white backgrounds.  Text colours are dark greys
# to maintain readability without excessive contrast.
LIGHT_THEME: Dict[str, Any] = {
    'name': 'Light',
    # Primary backgrounds and foregrounds
    'background': '#ffffff',        # main window background (pure white)
    'foreground': '#333333',        # primary text colour (dark grey)
    'panel_bg': '#f3f3f3',          # toolbar, config panels
    'border': '#dcdcdc',            # borders and separators
    'accent': '#0066b8',            # accent colour for buttons and highlights
    'error': '#d13438',             # error messages / destructive actions
    'success': '#107c10',           # success messages

    # Fonts
    'font_main': ('Segoe UI', 10),
    'font_mono': ('Consolas', 11),

    # Button styling
    'button_bg': '#e7e7e7',         # primary button background
    'button_fg': '#333333',         # primary button text colour

    # Input/entry styling
    'entry_bg': '#ffffff',          # entry and text box background
    'entry_fg': '#333333',          # entry text colour

    # Selection colours
    'select_bg': '#add6ff',         # selection background (lists/text)
    'select_fg': '#000000',         # selection text colour

    # Table/heading styling
    'heading_bg': '#e2e2e2',        # table headings background
    'heading_fg': '#333333',        # table headings text colour
    'heading_font': ('Segoe UI', 12, 'bold'),
}

# Registry of all supported themes.  Keys should be titleâ€‘cased to
# simplify lookups when user preferences are normalised by
# `TkinterThemeManagerMS.set_theme()`.
THEMES: Dict[str, Dict[str, Any]] = {
    'Dark': DARK_THEME,
    'Light': LIGHT_THEME,
}


@service_metadata(
    name='TkinterThemeManager',
    version='1.2.0',
    description='Centralised configuration for UI colours and fonts.',
    tags=['ui', 'config', 'theme'],
    capabilities=['ui:style'],
    internal_dependencies=['microservice_std_lib'],
    external_dependencies=[],
)
class TkinterThemeManagerMS:
    """
    The Stylist: Holds the colour palette and font settings.

    All UI components query this service to decide how to draw themselves.
    The palette is returned as a mutable dictionary so that callers can
    hold a reference and receive updates in place when switching themes.

    Configuration options:
      - ``theme``: one of the keys defined in ``THEMES`` (default ``'Dark'``)
      - ``overrides``: a dictionary of key/value pairs used to override
        default theme values.  Overrides persist across theme changes.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        self.config = config or {}

        # Determine the requested base theme, falling back to Dark if unknown.
        requested = self.config.get('theme', 'Dark')
        requested = (requested or 'Dark').strip().title()
        if requested not in THEMES:
            requested = 'Dark'

        # Active theme name and palette.  ``self.theme`` is mutable and
        # updated in place on theme changes to preserve object identity.
        self.theme_name: str = requested
        # copy() to ensure modifications on ``self.theme`` do not affect
        # the global template stored in ``THEMES``.
        self.theme: Dict[str, Any] = THEMES[self.theme_name].copy()

        # Persist any user overrides.  If overrides are supplied they
        # should override defaults on initialisation and on subsequent
        # theme changes.  A shallow copy is sufficient because values
        # should be primitives or tuples.
        self._overrides = dict(self.config.get('overrides', {}))
        if self._overrides:
            self.theme.update(self._overrides)

    @service_endpoint(
        inputs={},
        outputs={'theme': 'Dict'},
        description='Returns the current active theme dictionary.',
        tags=['ui', 'read'],
    )
    # ROLE: Returns the current active theme dictionary.
    # INPUTS: {}
    # OUTPUTS: {"theme": "Dict"}
    def get_theme(self) -> Dict[str, Any]:
        """Return the current theme palette."""
        return self.theme

    @service_endpoint(
        inputs={},
        outputs={'theme_name': 'str'},
        description='Returns the current active theme name.',
        tags=['ui', 'read'],
    )
    # ROLE: Returns the current active theme name.
    # INPUTS: {}
    # OUTPUTS: {"theme_name": "str"}
    def get_theme_name(self) -> str:
        """Return the name of the current theme (e.g. ``'Dark'``)."""
        return self.theme_name

    @service_endpoint(
        inputs={'theme_name': 'str'},
        outputs={'applied': 'bool'},
        description='Switches the active theme (Dark/Light).',
        tags=['ui', 'write'],
        side_effects=['ui:refresh'],
    )
    # ROLE: Switches the active theme (Dark/Light).
    # INPUTS: {"theme_name": "str"}
    # OUTPUTS: {"applied": "bool"}
    def set_theme(self, theme_name: str) -> bool:
        """
        Switch the current theme to ``theme_name``.

        Unknown theme names fall back to ``'Dark'``.  Overrides stored
        during initialisation are reâ€‘applied after the base palette is
        swapped so that user customisations persist across theme changes.
        The method always returns ``True``.
        """
        name = (theme_name or 'Dark').strip().title()
        if name not in THEMES:
            name = 'Dark'
        self.theme_name = name

        # Build a fresh palette from the base and reapply overrides.  The
        # resulting palette is merged into the existing ``self.theme``
        # dictionary to preserve its identity for any UI components holding
        # references.  This ensures calls like ``refresh_theme()`` only need
        # to reconfigure widget properties rather than replace entire dicts.
        new_theme: Dict[str, Any] = THEMES[self.theme_name].copy()
        if self._overrides:
            new_theme.update(self._overrides)

        # Update the existing dict in place rather than reassigning.
        self.theme.clear()
        self.theme.update(new_theme)
        return True

    @service_endpoint(
        inputs={'key': 'str', 'value': 'Any'},
        outputs={},
        description='Updates a specific theme attribute (e.g., changing accent colour).',
        tags=['ui', 'write'],
        side_effects=['ui:refresh'],
    )
    # ROLE: Updates a specific theme attribute (e.g., changing accent colour).
    # INPUTS: {"key": "str", "value": "Any"}
    # OUTPUTS: {}
    def update_key(self, key: str, value: Any) -> None:
        """
        Update an individual key in the current theme.

        Overrides are persisted so that subsequent calls to
        ``set_theme()`` do not wipe out the change.  A missing key will
        simply be added to the palette.
        """
        # Update the current palette
        self.theme[key] = value
        # Persist override for future theme switches
        self._overrides[key] = value


if __name__ == '__main__':  # pragma: no cover
    # Simple manual test: print palette names and accents
    svc = TkinterThemeManagerMS({'theme': 'Dark'})
    print('Initial:', svc.get_theme_name(), svc.get_theme()['accent'])
    svc.set_theme('Light')
    print('After switch:', svc.get_theme_name(), svc.get_theme()['accent'])
--------------------------------------------------------------------------------
FILE: src\microservices\_TreeMapperMS.py
--------------------------------------------------------------------------------
import os
import datetime
import logging
from pathlib import Path
from typing import Any, Dict, List, Set, Optional
from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService
DEFAULT_EXCLUDES = {'.git', '__pycache__', '.idea', '.vscode', 'node_modules', '.venv', 'env', 'venv', 'dist', 'build', '.DS_Store'}
logger = logging.getLogger('TreeMapper')

@service_metadata(name='TreeMapper', version='1.0.0', description='Generates ASCII-art style directory maps of the file system.', tags=['filesystem', 'map', 'visualization'], capabilities=['filesystem:read'], internal_dependencies=['microservice_std_lib'], external_dependencies=[])
class TreeMapperMS(BaseService):
    """
    The Cartographer: Generates ASCII-art style directory maps.
    Useful for creating context snapshots for LLMs.
    """

    def __init__(self, config: Optional[Dict[str, Any]]=None):
        super().__init__('TreeMapper')
        self.config = config or {}

    @service_endpoint(inputs={'root_path': 'str', 'additional_exclusions': 'Set[str]', 'use_default_exclusions': 'bool'}, outputs={'tree_map': 'str'}, description='Generates an ASCII tree map of the directory.', tags=['filesystem', 'visualization'], side_effects=['filesystem:read'])
    # ROLE: Generates an ASCII tree map of the directory.
    # INPUTS: {"additional_exclusions": "Set[str]", "root_path": "str", "use_default_exclusions": "bool"}
    # OUTPUTS: {"tree_map": "str"}
    def generate_tree(self, root_path: str, additional_exclusions: Optional[Set[str]]=None, use_default_exclusions: bool=True) -> str:
        start_path = Path(root_path).resolve()
        if not start_path.exists():
            return f"Error: Path '{root_path}' does not exist."
        exclusions = set()
        if use_default_exclusions:
            exclusions.update(DEFAULT_EXCLUDES)
        if additional_exclusions:
            exclusions.update(additional_exclusions)
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        lines = [f'Project Map: {start_path.name}', f'Generated: {timestamp}', '-' * 40, f'ðŸ“ {start_path.name}/']
        logger.info(f'Mapping directory: {start_path}')
        self._walk(start_path, '', lines, exclusions)
        return '\n'.join(lines)

    def _walk(self, directory: Path, prefix: str, lines: List[str], exclusions: Set[str]):
        try:
            children = sorted([p for p in directory.iterdir() if p.name not in exclusions], key=lambda x: (not x.is_dir(), x.name.lower()))
        except PermissionError:
            lines.append(f'{prefix}â””â”€â”€ ðŸš« [Permission Denied]')
            return
        count = len(children)
        for index, path in enumerate(children):
            is_last = index == count - 1
            connector = 'â””â”€â”€ ' if is_last else 'â”œâ”€â”€ '
            if path.is_dir():
                lines.append(f'{prefix}{connector}ðŸ“ {path.name}/')
                extension = '    ' if is_last else 'â”‚   '
                self._walk(path, prefix + extension, lines, exclusions)
            else:
                lines.append(f'{prefix}{connector}ðŸ“„ {path.name}')
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
    svc = TreeMapperMS()
    print('Service ready:', svc)
    print('\n--- Map of Current Dir ---')
    tree = svc.generate_tree('.', additional_exclusions={'__pycache__'})
    print(tree)


--------------------------------------------------------------------------------
FILE: src\microservices\_VectorFactoryMS.py
--------------------------------------------------------------------------------
import importlib.util
import sys
import os
import uuid
import logging
import shutil
from typing import List, Dict, Any, Optional, Protocol, Union
from pathlib import Path

# Dependency Check
REQUIRED = ['chromadb', 'faiss-cpu', 'numpy']
MISSING = []
for lib in REQUIRED:
    clean_lib = lib.split('>=')[0].replace('-', '_')
    if clean_lib == 'faiss_cpu':
        clean_lib = 'faiss'
    if importlib.util.find_spec(clean_lib) is None:
        MISSING.append(lib)

if MISSING:
    print('\n' + '!' * 60)
    print(f'MISSING DEPENDENCIES for _VectorFactoryMS:')
    print(f"Run:  pip install {' '.join(MISSING)}")
    print('!' * 60 + '\\n')

from .microservice_std_lib import service_metadata, service_endpoint
from .base_service import BaseService

logger = logging.getLogger('VectorFactory')

class VectorStore(Protocol):
    """The contract that all vector backends must fulfill."""
    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]) -> None: ...
    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]: ...
    def count(self) -> int: ...
    def clear(self) -> None: ...

class FaissStore(VectorStore):
    """Local-first vector store using FAISS and flat-file metadata."""
    def __init__(self, path: str, dim: int):
        import faiss
        import numpy as np
        self.path = Path(path)
        self.meta_path = self.path.with_suffix(self.path.suffix + '.meta.json')
        self.dim = dim
        self.index = faiss.IndexFlatL2(dim)
        self.metadata = []
        self._load()

    def _load(self):
        import faiss
        if self.path.exists():
            self.index = faiss.read_index(str(self.path))
            if self.meta_path.exists():
                with open(self.meta_path, 'r') as f:
                    self.metadata = json.load(f)

    def _save(self):
        import faiss
        faiss.write_index(self.index, str(self.path))
        with open(self.meta_path, 'w') as f:
            json.dump(self.metadata, f)

    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]):
        import numpy as np
        vecs = np.array(embeddings).astype('float32')
        self.index.add(vecs)
        self.metadata.extend(metadatas)
        self._save()

    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]:
        import numpy as np
        vec = np.array([query_vector]).astype('float32')
        distances, indices = self.index.search(vec, k)
        results = []
        for idx in indices[0]:
            if idx != -1 and idx < len(self.metadata):
                results.append(self.metadata[idx])
        return results

    def count(self) -> int:
        return self.index.ntotal

    def clear(self) -> None:
        import faiss
        self.index = faiss.IndexFlatL2(self.dim)
        self.metadata = []
        if self.path.exists(): os.remove(self.path)
        if self.meta_path.exists(): os.remove(self.meta_path)

class ChromaStore(VectorStore):
    """Persistent vector store using ChromaDB."""
    def __init__(self, path: str, collection_name: str):
        import chromadb
        self.client = chromadb.PersistentClient(path=path)
        self.collection = self.client.get_or_create_collection(name=collection_name)

    def add(self, embeddings: List[List[float]], metadatas: List[Dict[str, Any]]):
        ids = [str(uuid.uuid4()) for _ in range(len(embeddings))]
        self.collection.add(embeddings=embeddings, metadatas=metadatas, ids=ids)

    def search(self, query_vector: List[float], k: int) -> List[Dict[str, Any]]:
        results = self.collection.query(query_embeddings=[query_vector], n_results=k)
        return results.get('metadatas', [[]])[0]

    def count(self) -> int:
        return self.collection.count()

    def clear(self) -> None:
        self.client.delete_collection(self.collection.name)

@service_metadata(
    name='VectorFactory',
    version='1.0.0',
    description='The Switchboard: Factory for creating and managing vector stores.',
    tags=['ai', 'vector', 'storage', 'factory'],
    capabilities=['db:vector'],
    internal_dependencies=['base_service', 'microservice_std_lib'],
    external_dependencies=['chromadb', 'faiss-cpu', 'numpy']
)
class VectorFactoryMS(BaseService):
    """
    The Switchboard: Standardized factory for vector store generation.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__('VectorFactory')
        self.config = config or {}

    @service_endpoint(
        inputs={'backend': 'str', 'params': 'Dict'},
        outputs={'store': 'VectorStore'},
        description='Creates a vector store instance (faiss or chroma).',
        tags=['factory', 'create']
    )
    # ROLE: Creates a vector store instance (faiss or chroma).
    # INPUTS: {"backend": "str", "params": "Dict"}
    # OUTPUTS: {"store": "VectorStore"}
    def create(self, backend: str, params: Dict[str, Any]) -> VectorStore:
        """
        Instantiates a vector store backend.
        """
        backend = backend.lower()
        if backend == 'faiss':
            return FaissStore(params.get('path', 'vector.index'), params.get('dim', 384))
        elif backend == 'chroma':
            return ChromaStore(params.get('path', './chroma_db'), params.get('collection', 'default'))
        else:
            raise ValueError(f"Unsupported vector backend: {backend}")

if __name__ == '__main__':
    import json
    # Basic Test Harness
    logging.basicConfig(level=logging.INFO)
    factory = VectorFactoryMS()
    print(f"Service Ready: {factory}")
--------------------------------------------------------------------------------
FILE: src\microservices\__init__.py
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: src\microservices\_MicroServiceTOOLS\_MicroserviceDecoratorMSTOOL.py
--------------------------------------------------------------------------------
import ast
import json
import os
import queue
import threading
import time
from dataclasses import dataclass
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# ----------------------------
# Data model
# ----------------------------

@dataclass
class PlannedEdit:
    file_path: Path
    func_name: str
    insert_at_line_0based: int  # where we insert header (0-based index into lines)
    old_header_span: tuple | None  # (start_line_0based, end_line_0based_exclusive) if replacing
    new_header_lines: list[str]

# ----------------------------
# Logging (thread-safe UI)
# ----------------------------

class TkLog:
    def __init__(self, text_widget: tk.Text):
        self.text = text_widget
        self.q = queue.Queue()
        self._closed = False

    def write(self, msg: str):
        if self._closed:
            return
        ts = time.strftime("%H:%M:%S")
        self.q.put(f"[{ts}] {msg}\n")

    def pump(self):
        """Call periodically from Tk main thread."""
        try:
            while True:
                line = self.q.get_nowait()
                self.text.configure(state="normal")
                self.text.insert("end", line)
                self.text.see("end")
                self.text.configure(state="disabled")
        except queue.Empty:
            return

    def close(self):
        self._closed = True

# ----------------------------
# AST helpers
# ----------------------------

def _is_service_endpoint_decorator(dec: ast.expr) -> bool:
    """
    Matches:
      @service_endpoint(...)
      @microservice_std_lib.service_endpoint(...)
      @something.service_endpoint(...)
    """
    if isinstance(dec, ast.Call):
        f = dec.func
        if isinstance(f, ast.Name) and f.id == "service_endpoint":
            return True
        if isinstance(f, ast.Attribute) and f.attr == "service_endpoint":
            return True
    return False

def _literal_eval_safe(node: ast.AST):
    try:
        return ast.literal_eval(node)
    except Exception:
        return None

def _extract_endpoint_kwargs(dec_call: ast.Call) -> dict:
    """
    Extracts literal keyword args from @service_endpoint(inputs=..., outputs=..., description=...).
    In your library, these become wrapper._endpoint_info fields (inputs/outputs/description/etc.). 
    :contentReference[oaicite:4]{index=4}
    """
    out = {}
    for kw in dec_call.keywords or []:
        if kw.arg is None:
            # **kwargs unpack; ignore safely
            continue
        out[kw.arg] = _literal_eval_safe(kw.value)
    return out

# ----------------------------
# Text edit helpers (comment insertion/replacement)
# ----------------------------

ROLE_PREFIX = "# ROLE:"
INPUTS_PREFIX = "# INPUTS:"
OUTPUTS_PREFIX = "# OUTPUTS:"

def _format_inline(obj) -> str:
    """
    Formats dict-ish inputs/outputs compactly.
    """
    if obj is None:
        return "{}"
    if isinstance(obj, dict):
        # stable order for diffs
        return json.dumps(obj, sort_keys=True)
    return str(obj)

def _build_header(description: str | None, inputs_obj, outputs_obj, indent: str) -> list[str]:
    role = (description or "").strip() or "N/A"
    return [
        f"{indent}{ROLE_PREFIX} {role}\n",
        f"{indent}{INPUTS_PREFIX} {_format_inline(inputs_obj)}\n",
        f"{indent}{OUTPUTS_PREFIX} {_format_inline(outputs_obj)}\n",
    ]

def _leading_ws(line: str) -> str:
    i = 0
    while i < len(line) and line[i] in (" ", "\t"):
        i += 1
    return line[:i]

def _find_existing_header_block(lines: list[str], def_line_0: int) -> tuple | None:
    """
    If the lines immediately above the def contain ROLE/INPUTS/OUTPUTS comment block,
    return (start, end_exclusive) to replace it.

    We scan up to 6 lines above the def to be forgiving about blank lines.
    """
    start_scan = max(0, def_line_0 - 6)
    window = lines[start_scan:def_line_0]

    # Work from bottom upward to find a contiguous block that includes ROLE/INPUTS/OUTPUTS
    indices = []
    for i, line in enumerate(window):
        s = line.lstrip()
        if s.startswith((ROLE_PREFIX, INPUTS_PREFIX, OUTPUTS_PREFIX)):
            indices.append(start_scan + i)

    if not indices:
        return None

    # If these markers are not close to def, skip replacement
    if max(indices) < def_line_0 - 6:
        return None

    # Expand to contiguous-ish block: include blank lines between marker lines
    block_start = min(indices)
    block_end = max(indices) + 1

    # Pull block_end upward if there are trailing blank lines just before def
    while block_end < def_line_0 and lines[block_end].strip() == "":
        block_end += 1

    # Also include any blank lines directly above the first marker (optional)
    while block_start > 0 and lines[block_start - 1].strip() == "":
        block_start -= 1

    return (block_start, def_line_0)

def plan_edits_for_file(path: Path, log: TkLog) -> list[PlannedEdit]:
    raw = path.read_text(encoding="utf-8", errors="replace")
    # Normalize line endings only in memory; we preserve original by re-joining with existing \n in lines.
    lines = raw.splitlines(keepends=True)

    try:
        tree = ast.parse(raw)
    except SyntaxError as e:
        log.write(f"SKIP (syntax error): {path.name} :: {e}")
        return []

    edits: list[PlannedEdit] = []

    for node in ast.walk(tree):
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            continue
        if not node.decorator_list:
            continue

        dec_call = None
        for dec in node.decorator_list:
            if _is_service_endpoint_decorator(dec):
                dec_call = dec  # type: ignore[assignment]
                break
        if dec_call is None or not isinstance(dec_call, ast.Call):
            continue

        kwargs = _extract_endpoint_kwargs(dec_call)
        inputs_obj = kwargs.get("inputs")
        outputs_obj = kwargs.get("outputs")
        desc = kwargs.get("description")

        def_line_0 = (node.lineno - 1) if getattr(node, "lineno", None) else None
        if def_line_0 is None or def_line_0 < 0 or def_line_0 >= len(lines):
            continue

        indent = _leading_ws(lines[def_line_0])

        new_header = _build_header(desc, inputs_obj, outputs_obj, indent)

        existing = _find_existing_header_block(lines, def_line_0)
        if existing:
            insert_at = existing[0]
            span = existing
            log.write(f"PLAN replace header: {path.name} :: {node.name} @ line {def_line_0+1}")
        else:
            insert_at = def_line_0
            span = None
            log.write(f"PLAN insert header:  {path.name} :: {node.name} @ line {def_line_0+1}")

        edits.append(
            PlannedEdit(
                file_path=path,
                func_name=node.name,
                insert_at_line_0based=insert_at,
                old_header_span=span,
                new_header_lines=new_header,
            )
        )

    return edits

def apply_edits_to_text(raw: str, edits: list[PlannedEdit]) -> str:
    lines = raw.splitlines(keepends=True)

    # Apply from bottom to top to keep line indices stable.
    # For each file, edits must be sorted descending by insertion position.
    edits_sorted = sorted(edits, key=lambda e: e.insert_at_line_0based, reverse=True)

    for e in edits_sorted:
        if e.old_header_span:
            start, end = e.old_header_span
            # Replace that region with new header (and ensure exactly one blank line after header? no)
            lines[start:end] = e.new_header_lines
        else:
            lines[e.insert_at_line_0based:e.insert_at_line_0based] = e.new_header_lines

    return "".join(lines)

# ----------------------------
# Tkinter App
# ----------------------------

class MarkupApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Microservice Endpoint Markup Tool")
        self.geometry("920x620")

        self.log_text = tk.Text(self, height=24, wrap="word", state="disabled")
        self.log_text.pack(fill="both", expand=True, padx=10, pady=(10, 6))

        self.log = TkLog(self.log_text)

        bar = ttk.Frame(self)
        bar.pack(fill="x", padx=10, pady=(0, 10))

        self.dir_var = tk.StringVar(value=str(Path.cwd()))
        ttk.Label(bar, text="microservices dir:").grid(row=0, column=0, sticky="w")
        ttk.Entry(bar, textvariable=self.dir_var).grid(row=0, column=1, sticky="ew", padx=6)
        ttk.Button(bar, text="Browse...", command=self.browse_dir).grid(row=0, column=2, padx=(0, 6))

        self.scan_btn = ttk.Button(bar, text="Scan", command=self.start_scan)
        self.scan_btn.grid(row=0, column=3, padx=(0, 6))

        self.save_btn = ttk.Button(bar, text="Save Changes", command=self.save_changes, state="disabled")
        self.save_btn.grid(row=0, column=4, padx=(0, 6))

        self.cancel_btn = ttk.Button(bar, text="Cancel", command=self.cancel_run, state="disabled")
        self.cancel_btn.grid(row=0, column=5)

        bar.columnconfigure(1, weight=1)

        self._worker: threading.Thread | None = None
        self._cancel_flag = threading.Event()

        self._planned_by_file: dict[Path, list[PlannedEdit]] = {}
        self._touched_files: set[Path] = set()

        # UI log pump
        self.after(50, self._tick)

    def _tick(self):
        self.log.pump()
        self.after(50, self._tick)

    def browse_dir(self):
        d = filedialog.askdirectory(title="Select src/microservices folder")
        if d:
            self.dir_var.set(d)

    def start_scan(self):
        micro_dir = Path(self.dir_var.get()).expanduser().resolve()
        if not micro_dir.exists() or not micro_dir.is_dir():
            messagebox.showerror("Invalid folder", "Please select a valid microservices directory.")
            return

        self._planned_by_file.clear()
        self._touched_files.clear()
        self._cancel_flag.clear()

        self.save_btn.configure(state="disabled")
        self.cancel_btn.configure(state="normal")
        self.scan_btn.configure(state="disabled")

        self.log.write(f"Scan start: {micro_dir}")
        self._worker = threading.Thread(target=self._scan_worker, args=(micro_dir,), daemon=True)
        self._worker.start()

    def cancel_run(self):
        self.log.write("Cancel requested...")
        self._cancel_flag.set()

    def _scan_worker(self, micro_dir: Path):
        # Ignore library files
        ignore = {"__init__.py", "base_service.py", "microservice_std_lib.py", "fix.py", "document_utils.py"}
        py_files = sorted([p for p in micro_dir.glob("*.py") if p.name not in ignore])

        total_edits = 0

        for p in py_files:
            if self._cancel_flag.is_set():
                self.log.write("Scan cancelled.")
                break

            self.log.write(f"Parse AST: {p.name}")
            try:
                edits = plan_edits_for_file(p, self.log)
            except Exception as e:
                self.log.write(f"ERROR planning {p.name}: {e}")
                continue

            if edits:
                self._planned_by_file[p] = edits
                total_edits += len(edits)
                self.log.write(f"Planned {len(edits)} edit(s) in {p.name}")
            else:
                self.log.write(f"No endpoints found in {p.name}")

        if not self._cancel_flag.is_set():
            self.log.write(f"Scan complete. Files with changes: {len(self._planned_by_file)} | Total planned edits: {total_edits}")

        # Enable Save if we have edits and not cancelled
        def _enable():
            self.scan_btn.configure(state="normal")
            self.cancel_btn.configure(state="disabled")
            if self._planned_by_file and not self._cancel_flag.is_set():
                self.save_btn.configure(state="normal")
            else:
                self.save_btn.configure(state="disabled")

        self.after(0, _enable)

    def save_changes(self):
        if not self._planned_by_file:
            messagebox.showinfo("Nothing to do", "No planned edits.")
            return

        if not messagebox.askyesno("Confirm", f"Apply changes to {len(self._planned_by_file)} file(s)? Backups (.bak) will be created."):
            return

        self.save_btn.configure(state="disabled")
        self.cancel_btn.configure(state="normal")
        self.scan_btn.configure(state="disabled")
        self._cancel_flag.clear()

        self._worker = threading.Thread(target=self._save_worker, daemon=True)
        self._worker.start()

    def _save_worker(self):
        for path, edits in sorted(self._planned_by_file.items(), key=lambda kv: kv[0].name):
            if self._cancel_flag.is_set():
                self.log.write("Save cancelled.")
                break

            try:
                raw = path.read_text(encoding="utf-8", errors="replace")
                new_text = apply_edits_to_text(raw, edits)

                if new_text == raw:
                    self.log.write(f"SKIP unchanged: {path.name}")
                    continue

                bak = path.with_suffix(path.suffix + ".bak")
                if not bak.exists():
                    bak.write_text(raw, encoding="utf-8")
                    self.log.write(f"Backup created: {bak.name}")

                path.write_text(new_text, encoding="utf-8")
                self._touched_files.add(path)
                self.log.write(f"UPDATED: {path.name} ({len(edits)} endpoint header(s))")
            except Exception as e:
                self.log.write(f"ERROR writing {path.name}: {e}")

        def _done():
            self.scan_btn.configure(state="normal")
            self.cancel_btn.configure(state="disabled")
            # keep planned edits, but disable save if none actually written
            if self._touched_files:
                messagebox.showinfo("Done", f"Updated {len(self._touched_files)} file(s). Backups saved as *.bak.")
            else:
                messagebox.showinfo("Done", "No files were modified.")

        self.after(0, _done)

if __name__ == "__main__":
    # This tool is designed around your decorator contract:
    # @service_endpoint(inputs=..., outputs=..., description=..., tags=..., side_effects=..., mode=...)
    # :contentReference[oaicite:5]{index=5}
    app = MarkupApp()
    app.mainloop()

--------------------------------------------------------------------------------
FILE: src\microservices\_MicroServiceTOOLS\_TkinterUiMAPPER.py
--------------------------------------------------------------------------------
"""tk_ui_mapper.py

Tkinter UI Mapper (AST-first, optional Ollama inference, human-in-the-loop decisions)

What it does (MVP):
- Choose a project folder
- Crawl .py files (excluding common junk)
- Find entrypoint candidates ("if __name__ == '__main__':" blocks)
- If multiple entrypoints are found, ask the user to pick one (HITL)
- Parse all project python files with AST to:
  - discover widget creation calls (tk/ttk constructors)
  - discover layout calls (.pack/.grid/.place)
  - discover wiring (command=, .bind, menu add_command)
  - discover handlers (function/method defs) and link when resolvable
- Collect UNKNOWN cases (dynamic parents, loops, getattr handlers, etc.)
- Optional: use Ollama model (default qwen2.5-coder:0.5b) to infer UNKNOWN cases
  - Still HITL: user can approve/skip inference results when ambiguity is high
- Export monolithic report as Markdown + JSON

No external deps: uses stdlib only.

Notes:
- AST does NOT preserve comments; this tool maps structure for reporting.
- Import resolution is deliberately lightweight. The report marks PROVEN vs INFERRED.

Author: Prototype for Raithe's _UsefulHelperSCRIPTS ecosystem
"""

from __future__ import annotations

import ast
import json
import os
import queue
import threading
import time
import traceback
import urllib.request
import urllib.error
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from tkinter.scrolledtext import ScrolledText


# -----------------------------
# Config
# -----------------------------

DEFAULT_MODEL = "qwen2.5-coder:0.5b"
DEFAULT_OLLAMA_URL = "http://localhost:11434"

EXCLUDE_DIRS = {
    ".git", "__pycache__", ".venv", "venv", "env", ".mypy_cache", ".pytest_cache",
    "dist", "build", ".idea", ".vscode", "node_modules",
}

# ---- .gitignore support (stdlib-only, best-effort) ----
# We intentionally keep this lightweight (no pathspec dep).
# Supported patterns:
#   - blank lines / comments (# ...)
#   - directory patterns: .venv/  build/  dist/
#   - file globs: *.log  *.pyc
#   - simple basename entries: .env  thumbs.db
# Unsupported (will be ignored safely): negation (!pattern) and complex gitignore rules.

def _load_gitignore_patterns(project_root: Path) -> list[str]:
    gi = project_root / ".gitignore"
    if not gi.exists():
        return []
    try:
        raw = gi.read_text(encoding="utf-8", errors="replace")
    except Exception:
        return []

    patterns: list[str] = []
    for line in raw.splitlines():
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        # We intentionally do not implement negation in this MVP
        if s.startswith("!"):
            continue
        patterns.append(s)
    return patterns


def _is_ignored_by_gitignore(rel_posix: str, patterns: list[str]) -> bool:
    """Best-effort matcher for a subset of .gitignore patterns."""
    if not patterns:
        return False

    # normalize
    rel_posix = rel_posix.lstrip("/")
    base = rel_posix.split("/")[-1]

    for pat in patterns:
        p = pat.strip()
        if not p or p.startswith("#") or p.startswith("!"):
            continue

        # directory pattern
        if p.endswith("/"):
            dp = p.rstrip("/").lstrip("/")
            # match any segment == dp
            if f"/{dp}/" in f"/{rel_posix}/" or rel_posix.startswith(dp + "/"):
                return True
            continue

        # anchored path
        if "/" in p:
            ap = p.lstrip("/")
            # prefix match (treat like path glob without wildcards)
            if rel_posix == ap or rel_posix.startswith(ap.rstrip("/") + "/"):
                return True

        # glob (basename)
        if "*" in p or "?" in p:
            import fnmatch
            if fnmatch.fnmatch(base, p):
                return True
            continue

        # simple basename
        if base == p:
            return True

    return False

WIDGET_METHODS_LAYOUT = {"pack", "grid", "place"}
WIRING_METHODS = {"bind", "bind_all", "trace_add", "add_command", "add_checkbutton", "add_radiobutton"}


# -----------------------------
# Logging to Tk (queue-driven)
# -----------------------------

class TkLogger:
    def __init__(self, text: tk.Text):
        self.text = text
        self.q: "queue.Queue[str]" = queue.Queue()
        self.closed = False

    def log(self, msg: str):
        if self.closed:
            return
        ts = time.strftime("%H:%M:%S")
        self.q.put(f"[{ts}] {msg}\n")

    def pump(self):
        if self.closed:
            return
        try:
            while True:
                line = self.q.get_nowait()
                self.text.configure(state="normal")
                self.text.insert("end", line)
                self.text.see("end")
                self.text.configure(state="disabled")
        except queue.Empty:
            return

    def close(self):
        self.closed = True


# -----------------------------
# Data model
# -----------------------------

@dataclass
class EntrypointCandidate:
    file: str
    line: int
    summary: str


@dataclass
class WidgetNode:
    id: str
    file: str
    line: int
    name: str                    # variable or attribute name
    widget_type: str             # e.g., ttk.Button
    parent_expr: str             # textual expression
    kwargs: dict
    confidence: float            # 0..1 (AST confidence)


@dataclass
class LayoutCall:
    file: str
    line: int
    target: str                  # widget expression
    manager: str                 # pack/grid/place
    kwargs: dict


@dataclass
class WiringEdge:
    file: str
    line: int
    source: str                  # widget expression
    kind: str                    # command/bind/menu/trace
    event: Optional[str]         # e.g., "<Button-1>" for bind
    handler: str                 # handler expression
    confidence: float


@dataclass
class HandlerDef:
    file: str
    line: int
    qualname: str                # e.g., Class.method or function


@dataclass
class UnknownCase:
    case_type: str
    file: str
    line: int
    snippet: str
    question: str
    context: str


@dataclass
class InferenceResult:
    case: UnknownCase
    best_guess: str
    confidence: float
    evidence: list[str]
    explanation: str


@dataclass
class UiMap:
    project_root: str
    entrypoint: Optional[EntrypointCandidate]
    widgets: list[WidgetNode]
    layouts: list[LayoutCall]
    wiring: list[WiringEdge]
    handlers: list[HandlerDef]
    unknowns: list[UnknownCase]
    inferred: list[InferenceResult]


# -----------------------------
# Small AST utilities
# -----------------------------

class SourceLines:
    def __init__(self, text: str):
        self.text = text
        self.lines = text.splitlines()

    def snippet_around(self, line_1based: int, radius: int = 6) -> str:
        i = max(0, line_1based - 1 - radius)
        j = min(len(self.lines), line_1based - 1 + radius + 1)
        out = []
        for idx in range(i, j):
            out.append(f"{idx+1:>5}: {self.lines[idx]}")
        return "\n".join(out)

    def context_block(self, start_line_1based: int, end_line_1based: int) -> str:
        i = max(0, start_line_1based - 1)
        j = min(len(self.lines), end_line_1based)
        out = []
        for idx in range(i, j):
            out.append(f"{idx+1:>5}: {self.lines[idx]}")
        return "\n".join(out)


def is_main_guard_test(node: ast.AST) -> bool:
    # if __name__ == "__main__":
    if not isinstance(node, ast.Compare):
        return False
    if not isinstance(node.left, ast.Name) or node.left.id != "__name__":
        return False
    if len(node.ops) != 1 or not isinstance(node.ops[0], ast.Eq):
        return False
    if len(node.comparators) != 1:
        return False
    comp = node.comparators[0]
    return isinstance(comp, ast.Constant) and comp.value == "__main__"


def expr_to_str(node: ast.AST) -> str:
    # best-effort rendering
    try:
        return ast.unparse(node)  # py3.9+
    except Exception:
        return node.__class__.__name__


def literal_kwargs(call: ast.Call) -> dict:
    out: dict[str, Any] = {}
    for kw in call.keywords or []:
        if kw.arg is None:
            out["**kwargs"] = expr_to_str(kw.value)
            continue
        try:
            out[kw.arg] = ast.literal_eval(kw.value)
        except Exception:
            out[kw.arg] = expr_to_str(kw.value)
    return out


def looks_like_tk_constructor(func_expr: ast.AST) -> Optional[str]:
    """Return qualified name string if func looks like tk/ttk constructor, else None."""
    # Matches: tk.Button, ttk.Frame, tkinter.Tk, tkinter.ttk.Button, etc.
    if isinstance(func_expr, ast.Attribute):
        base = expr_to_str(func_expr.value)
        attr = func_expr.attr
        # simple heuristics
        if base in {"tk", "ttk", "tkinter", "tkinter.ttk"}:
            return f"{base}.{attr}"
        # some code uses aliased imports; we can't know. return None.
    return None


# -----------------------------
# Project crawling + entrypoints
# -----------------------------

def iter_py_files(project_root: Path) -> list[Path]:
    files: list[Path] = []

    # Load .gitignore patterns once (best-effort subset)
    gitignore_patterns = _load_gitignore_patterns(project_root)

    for root, dirs, filenames in os.walk(project_root):
        root_p = Path(root)
        rel_root = root_p.relative_to(project_root).as_posix() if root_p != project_root else ""

        # prune dirs by hard excludes + .gitignore
        kept_dirs: list[str] = []
        for d in dirs:
            if d in EXCLUDE_DIRS:
                continue

            rel_dir = f"{rel_root}/{d}" if rel_root else d

            # extra safety: never crawl common venv dirs even if gitignore missing
            if d.lower() in {".venv", "venv", "env"}:
                continue

            if _is_ignored_by_gitignore(rel_dir + "/", gitignore_patterns):
                continue

            kept_dirs.append(d)

        dirs[:] = kept_dirs

        for fn in filenames:
            if not fn.endswith(".py"):
                continue

            rel_file = f"{rel_root}/{fn}" if rel_root else fn
            if _is_ignored_by_gitignore(rel_file, gitignore_patterns):
                continue

            files.append(root_p / fn)

    return sorted(files)


def find_entrypoints(py_files: list[Path], log: TkLogger, cancel: threading.Event) -> list[EntrypointCandidate]:
    cands: list[EntrypointCandidate] = []
    for p in py_files:
        if cancel.is_set():
            return cands
        try:
            text = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(text)
        except Exception:
            continue

        for node in ast.walk(tree):
            if cancel.is_set():
                return cands
            if isinstance(node, ast.If) and is_main_guard_test(node.test):
                # summarize first non-empty line in the body
                body_summary = ""
                for b in node.body:
                    if isinstance(b, ast.Expr) and isinstance(b.value, ast.Constant) and isinstance(b.value.value, str):
                        continue
                    body_summary = expr_to_str(b)
                    break
                line = getattr(node, "lineno", 1)
                cands.append(EntrypointCandidate(file=str(p), line=int(line), summary=body_summary))
    log.log(f"Entrypoint candidates found: {len(cands)}")
    return cands


# -----------------------------
# AST Mapper
# -----------------------------

class TkUiAstMapper(ast.NodeVisitor):
    def __init__(self, file_path: Path, source: str, log: TkLogger):
        self.file_path = file_path
        self.src = source
        self.lines = SourceLines(source)
        self.log = log

        self.widgets: list[WidgetNode] = []
        self.layouts: list[LayoutCall] = []
        self.wiring: list[WiringEdge] = []
        self.handlers: list[HandlerDef] = []
        self.unknowns: list[UnknownCase] = []

        # scope tracking
        self._class_stack: list[str] = []

        # symbol tables: map var/attr name -> widget type
        self._widget_symbols: dict[str, str] = {}

    def current_qualprefix(self) -> str:
        return ".".join(self._class_stack) if self._class_stack else ""

    def visit_ClassDef(self, node: ast.ClassDef):
        self._class_stack.append(node.name)
        self.generic_visit(node)
        self._class_stack.pop()

    def visit_FunctionDef(self, node: ast.FunctionDef):
        q = self.current_qualprefix()
        qual = f"{q}.{node.name}" if q else node.name
        self.handlers.append(HandlerDef(file=str(self.file_path), line=getattr(node, "lineno", 1), qualname=qual))
        self.generic_visit(node)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        q = self.current_qualprefix()
        qual = f"{q}.{node.name}" if q else node.name
        self.handlers.append(HandlerDef(file=str(self.file_path), line=getattr(node, "lineno", 1), qualname=qual))
        self.generic_visit(node)

    def visit_Assign(self, node: ast.Assign):
        # widget creation if RHS is call to tk/ttk constructor
        if isinstance(node.value, ast.Call):
            ctor = looks_like_tk_constructor(node.value.func)
            if ctor:
                # name
                target_name = None
                if node.targets:
                    t0 = node.targets[0]
                    if isinstance(t0, ast.Name):
                        target_name = t0.id
                    elif isinstance(t0, ast.Attribute):
                        target_name = expr_to_str(t0)

                # parent expr = first arg if present
                parent_expr = expr_to_str(node.value.args[0]) if node.value.args else "<unknown>"
                kwargs = literal_kwargs(node.value)

                line = getattr(node, "lineno", 1)
                wid = f"{self.file_path}:{line}:{target_name or 'widget'}"

                confidence = 0.9 if parent_expr != "<unknown>" else 0.6

                self.widgets.append(
                    WidgetNode(
                        id=wid,
                        file=str(self.file_path),
                        line=int(line),
                        name=target_name or "<unnamed>",
                        widget_type=ctor,
                        parent_expr=parent_expr,
                        kwargs=kwargs,
                        confidence=confidence,
                    )
                )

                if target_name:
                    self._widget_symbols[target_name] = ctor

                # wiring: command=...
                if "command" in kwargs:
                    self.wiring.append(
                        WiringEdge(
                            file=str(self.file_path),
                            line=int(line),
                            source=target_name or wid,
                            kind="command",
                            event=None,
                            handler=str(kwargs["command"]),
                            confidence=0.85,
                        )
                    )

                # unknowns: if parent expr is complex
                if parent_expr.startswith("(") or "." in parent_expr and parent_expr.count("("):
                    self.unknowns.append(
                        UnknownCase(
                            case_type="DYNAMIC_PARENT",
                            file=str(self.file_path),
                            line=int(line),
                            snippet=self.lines.snippet_around(int(line), radius=3),
                            question="What is the likely parent container for this widget?",
                            context=self.lines.snippet_around(int(line), radius=12),
                        )
                    )

        self.generic_visit(node)

    def visit_Call(self, node: ast.Call):
        # layout calls: x.pack/grid/place(...)
        if isinstance(node.func, ast.Attribute):
            attr = node.func.attr
            if attr in WIDGET_METHODS_LAYOUT:
                line = getattr(node, "lineno", 1)
                target = expr_to_str(node.func.value)
                kwargs = literal_kwargs(node)
                self.layouts.append(
                    LayoutCall(
                        file=str(self.file_path),
                        line=int(line),
                        target=target,
                        manager=attr,
                        kwargs=kwargs,
                    )
                )

            # wiring calls
            if attr in WIRING_METHODS:
                line = getattr(node, "lineno", 1)
                source = expr_to_str(node.func.value)
                kind = attr
                event = None
                handler = ""

                if attr in {"bind", "bind_all"}:
                    if node.args:
                        event = expr_to_str(node.args[0])
                    if len(node.args) >= 2:
                        handler = expr_to_str(node.args[1])
                elif attr == "trace_add":
                    # var.trace_add(mode, callback)
                    if node.args:
                        event = expr_to_str(node.args[0])
                    if len(node.args) >= 2:
                        handler = expr_to_str(node.args[1])
                else:
                    # menu.add_command(label=..., command=...)
                    k = literal_kwargs(node)
                    if "command" in k:
                        handler = str(k["command"])

                if handler:
                    self.wiring.append(
                        WiringEdge(
                            file=str(self.file_path),
                            line=int(line),
                            source=source,
                            kind="bind" if attr in {"bind", "bind_all"} else ("trace" if attr == "trace_add" else "menu"),
                            event=event,
                            handler=handler,
                            confidence=0.75,
                        )
                    )

                # unknowns: getattr handler
                if "getattr" in handler:
                    self.unknowns.append(
                        UnknownCase(
                            case_type="DYNAMIC_HANDLER",
                            file=str(self.file_path),
                            line=int(line),
                            snippet=self.lines.snippet_around(int(line), radius=3),
                            question="What handler does this resolve to at runtime?",
                            context=self.lines.snippet_around(int(line), radius=12),
                        )
                    )

        self.generic_visit(node)


def map_project_ast(project_root: Path, py_files: list[Path], log: TkLogger, cancel: threading.Event) -> UiMap:
    widgets: list[WidgetNode] = []
    layouts: list[LayoutCall] = []
    wiring: list[WiringEdge] = []
    handlers: list[HandlerDef] = []
    unknowns: list[UnknownCase] = []

    for p in py_files:
        if cancel.is_set():
            break
        try:
            text = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(text)
        except Exception as e:
            log.log(f"SKIP parse error: {p} :: {e}")
            continue

        mapper = TkUiAstMapper(p, text, log)
        try:
            mapper.visit(tree)
        except Exception as e:
            log.log(f"ERROR mapping {p.name}: {e}")
            continue

        widgets.extend(mapper.widgets)
        layouts.extend(mapper.layouts)
        wiring.extend(mapper.wiring)
        handlers.extend(mapper.handlers)
        unknowns.extend(mapper.unknowns)

    return UiMap(
        project_root=str(project_root),
        entrypoint=None,
        widgets=widgets,
        layouts=layouts,
        wiring=wiring,
        handlers=handlers,
        unknowns=unknowns,
        inferred=[],
    )


# -----------------------------
# Ollama client (stdlib urllib)
# -----------------------------

class OllamaClient:
    def __init__(self, base_url: str, log: TkLogger):
        self.base_url = base_url.rstrip("/")
        self.log = log

    def list_models(self, timeout: float = 3.0) -> list[str]:
        url = f"{self.base_url}/api/tags"
        req = urllib.request.Request(url, method="GET")
        try:
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                data = json.loads(resp.read().decode("utf-8", errors="replace"))
            models = [m.get("name") for m in data.get("models", []) if m.get("name")]
            return sorted(models)
        except Exception as e:
            self.log.log(f"Ollama list_models failed: {e}")
            return []

    def generate_json(self, model: str, prompt: str, timeout: float = 30.0) -> dict:
        url = f"{self.base_url}/api/generate"
        payload = {
            "model": model,
            "prompt": prompt,
            "stream": False,
            "options": {
                "temperature": 0.1,
            },
        }
        data = json.dumps(payload).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"}, method="POST")
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            raw = resp.read().decode("utf-8", errors="replace")
        j = json.loads(raw)
        # Ollama returns {'response': '...'}
        txt = j.get("response", "")
        # Try parse as JSON
        try:
            return json.loads(txt)
        except Exception:
            return {"raw": txt}


def build_inference_prompt(case: UnknownCase) -> str:
    schema = {
        "best_guess": "string",
        "confidence": "0..1",
        "evidence": ["line refs or short quotes"],
        "explanation": "short"
    }
    return (
        "You are helping map a Tkinter UI using static AST evidence.\n"
        "Only infer what is strongly supported by the provided code context.\n"
        "Return ONLY valid JSON with keys: best_guess, confidence, evidence, explanation.\n\n"
        f"CASE_TYPE: {case.case_type}\n"
        f"QUESTION: {case.question}\n\n"
        "SNIPPET:\n"
        f"{case.snippet}\n\n"
        "CONTEXT:\n"
        f"{case.context}\n\n"
        "JSON_SCHEMA_EXAMPLE:\n"
        f"{json.dumps(schema, indent=2)}\n"
    )


# -----------------------------
# Reporting
# -----------------------------

def write_report_md(ui: UiMap, out_path: Path):
    def fmt_conf(x: float) -> str:
        return f"{x:.2f}"

    lines: list[str] = []
    lines.append(f"# Tkinter UI Map Report\n")
    lines.append(f"**Project Root:** `{ui.project_root}`\n")

    if ui.entrypoint:
        lines.append("## Entrypoint (Selected)\n")
        lines.append(f"- File: `{ui.entrypoint.file}`\n")
        lines.append(f"- Line: {ui.entrypoint.line}\n")
        lines.append(f"- Summary: `{ui.entrypoint.summary}`\n")

    lines.append("## Widgets (PROVEN via AST)\n")
    for w in sorted(ui.widgets, key=lambda x: (x.file, x.line)):
        lines.append(f"- **{w.widget_type}** `{w.name}`  ")
        lines.append(f"  - Location: `{w.file}`:{w.line}  ")
        lines.append(f"  - Parent: `{w.parent_expr}`  ")
        lines.append(f"  - Kwargs: `{json.dumps(w.kwargs, sort_keys=True)}`  ")
        lines.append(f"  - Confidence: {fmt_conf(w.confidence)}\n")

    lines.append("## Layout Calls (PROVEN via AST)\n")
    for lc in sorted(ui.layouts, key=lambda x: (x.file, x.line)):
        lines.append(f"- `{lc.target}`.{lc.manager}({json.dumps(lc.kwargs, sort_keys=True)})  ")
        lines.append(f"  - Location: `{lc.file}`:{lc.line}\n")

    lines.append("## Wiring (PROVEN via AST)\n")
    for e in sorted(ui.wiring, key=lambda x: (x.file, x.line)):
        ev = f" event={e.event}" if e.event else ""
        lines.append(f"- **{e.kind}** source=`{e.source}` handler=`{e.handler}`{ev}  ")
        lines.append(f"  - Location: `{e.file}`:{e.line}  ")
        lines.append(f"  - Confidence: {fmt_conf(e.confidence)}\n")

    lines.append("## Handlers Discovered (PROVEN via AST defs)\n")
    for h in sorted(ui.handlers, key=lambda x: (x.file, x.line, x.qualname)):
        lines.append(f"- `{h.qualname}`  ({h.file}:{h.line})")
    lines.append("\n")

    lines.append("## Unknowns (AST could not resolve)\n")
    for u in sorted(ui.unknowns, key=lambda x: (x.file, x.line)):
        lines.append(f"### {u.case_type} @ `{u.file}`:{u.line}\n")
        lines.append(f"**Question:** {u.question}\n")
        lines.append("```\n" + u.snippet + "\n```\n")

    if ui.inferred:
        lines.append("## Inferred (LLM-assisted)\n")
        for inf in ui.inferred:
            u = inf.case
            lines.append(f"### {u.case_type} @ `{u.file}`:{u.line}\n")
            lines.append(f"- **Best guess:** {inf.best_guess}\n")
            lines.append(f"- **Confidence:** {fmt_conf(inf.confidence)}\n")
            if inf.evidence:
                lines.append("- **Evidence:**\n")
                for ev in inf.evidence:
                    lines.append(f"  - {ev}\n")
            lines.append(f"- **Explanation:** {inf.explanation}\n")

    out_path.write_text("\n".join(lines), encoding="utf-8")


def write_report_json(ui: UiMap, out_path: Path):
    # Convert dataclasses to JSON-serializable
    def ser(o):
        if hasattr(o, "__dataclass_fields__"):
            return asdict(o)
        raise TypeError

    out_path.write_text(json.dumps(ui, default=ser, indent=2), encoding="utf-8")


# -----------------------------
# HITL dialogs
# -----------------------------

class CandidatePicker(tk.Toplevel):
    def __init__(self, master: tk.Tk, cands: list[EntrypointCandidate]):
        super().__init__(master)
        self.title("Select Entrypoint")
        self.geometry("820x380")
        self.resizable(True, True)
        self.choice: Optional[EntrypointCandidate] = None

        ttk.Label(self, text="Multiple entrypoints were found. Select the one that launches the UI.").pack(anchor="w", padx=10, pady=(10, 6))

        cols = ("file", "line", "summary")
        self.tree = ttk.Treeview(self, columns=cols, show="headings", height=12)
        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=220 if c == "file" else 80, stretch=True)
        self.tree.column("summary", width=460)
        self.tree.pack(fill="both", expand=True, padx=10)

        for i, c in enumerate(cands):
            self.tree.insert("", "end", iid=str(i), values=(c.file, c.line, c.summary))

        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10, pady=10)
        ttk.Button(btns, text="Select", command=self._select).pack(side="right")
        ttk.Button(btns, text="Cancel", command=self._cancel).pack(side="right", padx=(0, 8))

        self.tree.bind("<Double-1>", lambda e: self._select())

        self.grab_set()
        self.transient(master)

    def _select(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Pick one", "Select an entrypoint candidate.", parent=self)
            return
        idx = int(sel[0])
        vals = self.tree.item(sel[0], "values")
        self.choice = EntrypointCandidate(file=vals[0], line=int(vals[1]), summary=vals[2])
        self.destroy()

    def _cancel(self):
        self.choice = None
        self.destroy()


# -----------------------------
# Main App
# -----------------------------

class TkUiMapperApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Tkinter UI Mapper (AST + optional Ollama)")
        self.geometry("980x720")

        self.cancel_flag = threading.Event()
        self.worker: Optional[threading.Thread] = None

        # state
        self.project_dir = tk.StringVar(value=str(Path.cwd()))
        self.ollama_url = tk.StringVar(value=DEFAULT_OLLAMA_URL)
        self.model = tk.StringVar(value=DEFAULT_MODEL)
        self.use_llm = tk.BooleanVar(value=True)

        self.ui_map: Optional[UiMap] = None

        # top controls
        top = ttk.Frame(self)
        top.pack(fill="x", padx=10, pady=10)

        ttk.Label(top, text="Project folder:").grid(row=0, column=0, sticky="w")
        ttk.Entry(top, textvariable=self.project_dir).grid(row=0, column=1, sticky="ew", padx=6)
        ttk.Button(top, text="Browseâ€¦", command=self.pick_project).grid(row=0, column=2)

        ttk.Label(top, text="Ollama URL:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        ttk.Entry(top, textvariable=self.ollama_url).grid(row=1, column=1, sticky="ew", padx=6, pady=(8, 0))
        ttk.Button(top, text="Refresh models", command=self.refresh_models).grid(row=1, column=2, pady=(8, 0))

        ttk.Label(top, text="Model:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.model_combo = ttk.Combobox(top, textvariable=self.model, values=[DEFAULT_MODEL], state="readonly")
        self.model_combo.grid(row=2, column=1, sticky="w", padx=6, pady=(8, 0))

        ttk.Checkbutton(top, text="Use LLM to infer unknowns (HITL)", variable=self.use_llm).grid(row=2, column=2, sticky="w", pady=(8, 0))

        top.columnconfigure(1, weight=1)

        # buttons
        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10)
        self.run_btn = ttk.Button(btns, text="Run Map", command=self.run_map)
        self.run_btn.pack(side="left")
        self.save_btn = ttk.Button(btns, text="Save Report", command=self.save_report, state="disabled")
        self.save_btn.pack(side="left", padx=(8, 0))
        self.cancel_btn = ttk.Button(btns, text="Cancel", command=self.cancel, state="disabled")
        self.cancel_btn.pack(side="left", padx=(8, 0))

        # log
        self.log_text = ScrolledText(self, height=28)
        self.log_text.pack(fill="both", expand=True, padx=10, pady=10)
        self.log_text.configure(state="disabled")
        self.log = TkLogger(self.log_text)

        self.after(80, self._pump)

    def _pump(self):
        self.log.pump()
        self.after(80, self._pump)

    def pick_project(self):
        d = filedialog.askdirectory(title="Select project folder")
        if d:
            self.project_dir.set(d)

    def cancel(self):
        self.log.log("Cancel requestedâ€¦")
        self.cancel_flag.set()

    def set_busy(self, busy: bool):
        self.run_btn.configure(state="disabled" if busy else "normal")
        self.save_btn.configure(state="disabled" if busy or not self.ui_map else "normal")
        self.cancel_btn.configure(state="normal" if busy else "disabled")

    def refresh_models(self):
        # async refresh
        self.log.log("Refreshing Ollama modelsâ€¦")
        url = self.ollama_url.get().strip()
        client = OllamaClient(url, self.log)

        def _work():
            models = client.list_models()
            def _apply():
                if models:
                    self.model_combo["values"] = models
                    # keep default if present
                    if self.model.get() not in models and DEFAULT_MODEL in models:
                        self.model.set(DEFAULT_MODEL)
                    elif self.model.get() not in models and models:
                        self.model.set(models[0])
                    self.log.log(f"Loaded {len(models)} model(s) from Ollama")
                else:
                    self.log.log("No models returned (is Ollama running?)")
            self.after(0, _apply)

        threading.Thread(target=_work, daemon=True).start()

    def run_map(self):
        root = Path(self.project_dir.get()).expanduser().resolve()
        if not root.exists() or not root.is_dir():
            messagebox.showerror("Invalid folder", "Select a valid project folder.")
            return

        self.cancel_flag.clear()
        self.ui_map = None
        self.set_busy(True)

        def _worker():
            try:
                self.log.log(f"Scanning project: {root}")
                py_files = iter_py_files(root)
                self.log.log(f"Python files found: {len(py_files)}")

                cands = find_entrypoints(py_files, self.log, self.cancel_flag)
                entry = None

                if self.cancel_flag.is_set():
                    raise RuntimeError("Cancelled")

                # HITL: select entrypoint when ambiguous
                if len(cands) == 0:
                    self.log.log("No __main__ entrypoints found. Proceeding with AST mapping anyway.")
                elif len(cands) == 1:
                    entry = cands[0]
                    self.log.log(f"Selected entrypoint: {entry.file}:{entry.line}")
                else:
                    # ask user on UI thread
                    entry = self._ask_pick_entrypoint(cands)
                    if entry is None:
                        raise RuntimeError("User cancelled entrypoint selection")
                    self.log.log(f"User selected entrypoint: {entry.file}:{entry.line}")

                if self.cancel_flag.is_set():
                    raise RuntimeError("Cancelled")

                ui_map = map_project_ast(root, py_files, self.log, self.cancel_flag)
                ui_map.entrypoint = entry

                self.log.log(f"AST map done: widgets={len(ui_map.widgets)} layouts={len(ui_map.layouts)} wiring={len(ui_map.wiring)} unknowns={len(ui_map.unknowns)}")

                if self.use_llm.get() and ui_map.unknowns and not self.cancel_flag.is_set():
                    self.log.log("LLM inference enabled: starting UNKNOWN case inference (HITL)â€¦")
                    inferred = self._infer_unknowns_hitl(ui_map.unknowns)
                    ui_map.inferred = inferred
                    self.log.log(f"LLM inference complete: inferred={len(inferred)}")

                self.ui_map = ui_map

                def _done():
                    self.set_busy(False)
                    self.save_btn.configure(state="normal")
                    self.log.log("Run complete.")

                self.after(0, _done)

            except Exception as e:
                tb = traceback.format_exc()
                self.log.log(f"ERROR: {e}\n{tb}")
                self.after(0, lambda: self.set_busy(False))

        self.worker = threading.Thread(target=_worker, daemon=True)
        self.worker.start()

    def _ask_pick_entrypoint(self, cands: list[EntrypointCandidate]) -> Optional[EntrypointCandidate]:
        # synchronous ask (but must run on main thread)
        result_holder: dict[str, Any] = {"choice": None}
        ev = threading.Event()

        def _show():
            dlg = CandidatePicker(self, cands)
            self.wait_window(dlg)
            result_holder["choice"] = dlg.choice
            ev.set()

        self.after(0, _show)
        ev.wait()
        return result_holder["choice"]

    def _infer_unknowns_hitl(self, unknowns: list[UnknownCase]) -> list[InferenceResult]:
        url = self.ollama_url.get().strip()
        model = self.model.get().strip() or DEFAULT_MODEL
        client = OllamaClient(url, self.log)

        results: list[InferenceResult] = []

        for idx, case in enumerate(unknowns, start=1):
            if self.cancel_flag.is_set():
                self.log.log("Inference cancelled.")
                break

            self.log.log(f"Infer {idx}/{len(unknowns)}: {case.case_type} @ {Path(case.file).name}:{case.line}")
            prompt = build_inference_prompt(case)

            try:
                j = client.generate_json(model=model, prompt=prompt, timeout=45.0)
            except Exception as e:
                self.log.log(f"Ollama inference failed: {e}")
                continue

            # parse
            best_guess = str(j.get("best_guess", j.get("raw", ""))).strip()
            conf = j.get("confidence", 0.4)
            try:
                conf_f = float(conf)
            except Exception:
                conf_f = 0.4
            evidence = j.get("evidence", [])
            if not isinstance(evidence, list):
                evidence = [str(evidence)]
            explanation = str(j.get("explanation", "")).strip()

            inf = InferenceResult(
                case=case,
                best_guess=best_guess,
                confidence=max(0.0, min(1.0, conf_f)),
                evidence=[str(x) for x in evidence][:8],
                explanation=explanation,
            )

            # HITL approval for low confidence
            approved = self._ask_approve_inference(inf)
            if approved:
                results.append(inf)
                self.log.log(f"Approved inference: {inf.best_guess} (conf={inf.confidence:.2f})")
            else:
                self.log.log("Skipped inference (user declined).")

        return results

    def _ask_approve_inference(self, inf: InferenceResult) -> bool:
        # Always HITL prompt; user can skip noisy guesses.
        holder = {"ok": False}
        ev = threading.Event()

        def _show():
            msg = (
                f"UNKNOWN: {inf.case.case_type}\n"
                f"Location: {inf.case.file}:{inf.case.line}\n\n"
                f"Best guess: {inf.best_guess}\n"
                f"Confidence: {inf.confidence:.2f}\n\n"
                f"Explanation: {inf.explanation}\n\n"
                "Approve this inference to include it in the report?"
            )
            holder["ok"] = messagebox.askyesno("Approve inference?", msg, parent=self)
            ev.set()

        self.after(0, _show)
        ev.wait()
        return bool(holder["ok"])

    def save_report(self):
        if not self.ui_map:
            messagebox.showinfo("Nothing to save", "Run the mapper first.")
            return

        out_dir = filedialog.askdirectory(title="Select output folder")
        if not out_dir:
            return

        out = Path(out_dir)
        md_path = out / "ui_map_report.md"
        js_path = out / "ui_map_report.json"

        try:
            write_report_md(self.ui_map, md_path)
            write_report_json(self.ui_map, js_path)
            self.log.log(f"Saved report: {md_path}")
            self.log.log(f"Saved report: {js_path}")
            messagebox.showinfo("Saved", f"Report saved to:\n{md_path}\n{js_path}")
        except Exception as e:
            messagebox.showerror("Save failed", str(e))


if __name__ == "__main__":
    app = TkUiMapperApp()
    app.mainloop()


--------------------------------------------------------------------------------
FILE: _sanbox-area\app.py
--------------------------------------------------------------------------------
import tkinter as tk
from tkinter import messagebox, StringVar

class TaskListGenerator:
    def __init__(self, root):
        self.root = root
        self.root.title("Task List Generator")
        
        # Initialize StringVars for storing user input
        self.task_var = StringVar()
        self.description_var = StringVar()
        
        # Create a frame to hold the widgets
        self.frame = tk.Frame(root)
        self.frame.pack(padx=20, pady=20)
        
        # Create labels and entry widgets
        tk.Label(self.frame, text="Task Name:").grid(row=0, column=0, sticky=tk.W)
        self.task_entry = tk.Entry(self.frame, textvariable=self.task_var)
        self.task_entry.grid(row=0, column=1)
        
        tk.Label(self.frame, text="Description:").grid(row=1, column=0, sticky=tk.W)
        self.description_entry = tk.Entry(self.frame, textvariable=self.description_var)
        self.description_entry.grid(row=1, column=1)
            
        # Create a submit button
        self.submit_button = tk.Button(self.frame, text="Submit", command=self.show_results)
        self.submit_button.grid(row=2, column=0, columnspan=2)
        
    def show_results(self):
        task = self.task_var.get()
        description = self.description_var.get()
        
        # Create a formatted string to display the user's input
        result_text = f"Task Name: {task}\nDescription: {description}"
        
        # Display the results in a message box
        messagebox.showinfo("Task List", result_text)

if __name__ == "__main__":
    root = tk.Tk()
    app = TaskListGenerator(root)
    root.mainloop()
--------------------------------------------------------------------------------
FILE: _uimapper_reports\uimap_report.json
--------------------------------------------------------------------------------
{
  "parse_errors": [],
  "project_root": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL",
  "unknowns": [],
  "widgets": {
    "w1": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 35,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "columns": "Tuple",
        "show": "'headings'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w1",
      "widget_type": "Treeview"
    },
    "w10": {
      "bind_events": [],
      "command_targets": [
        "self._italic_text"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 216,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "command": "self._italic_text",
        "font": "Tuple",
        "text": "'I'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w10",
      "widget_type": "Button"
    },
    "w11": {
      "bind_events": [],
      "command_targets": [
        "self._bullet_list"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 218,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "command": "self._bullet_list",
        "text": "'â€¢ List'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w11",
      "widget_type": "Button"
    },
    "w12": {
      "bind_events": [],
      "command_targets": [
        "self._open_settings"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 221,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "command": "self._open_settings",
        "text": "'âš™'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w12",
      "widget_type": "Button"
    },
    "w13": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 225,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bd": "1",
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "relief": "'solid'",
        "text": "' Inference Parameters '"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w13",
      "widget_type": "LabelFrame"
    },
    "w14": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 231,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "text": "'Model:'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w14",
      "widget_type": "Label"
    },
    "w15": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 234,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "textvariable": "self.model_var"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w15",
      "widget_type": "Combobox"
    },
    "w16": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 239,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "text": "'System Role:'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w16",
      "widget_type": "Label"
    },
    "w17": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 241,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w17",
      "widget_type": "Frame"
    },
    "w18": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 244,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "insertbackground": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w18",
      "widget_type": "Entry"
    },
    "w19": {
      "bind_events": [],
      "command_targets": [
        "Lambda"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 253,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "Lambda",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "text": "'ðŸ’¾'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w19",
      "widget_type": "Button"
    },
    "w2": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 48,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w2",
      "widget_type": "Frame"
    },
    "w20": {
      "bind_events": [],
      "command_targets": [
        "Lambda"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 256,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "Lambda",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "text": "'ðŸ“‚'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w20",
      "widget_type": "Button"
    },
    "w21": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 261,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "text": "'System Prompt:'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w21",
      "widget_type": "Label"
    },
    "w22": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 263,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w22",
      "widget_type": "Frame"
    },
    "w23": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 266,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "height": "3",
        "insertbackground": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w23",
      "widget_type": "Text"
    },
    "w24": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 276,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w24",
      "widget_type": "Frame"
    },
    "w25": {
      "bind_events": [],
      "command_targets": [
        "Lambda"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 278,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "Lambda",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "text": "'ðŸ’¾'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w25",
      "widget_type": "Button"
    },
    "w26": {
      "bind_events": [],
      "command_targets": [
        "Lambda"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 281,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "Lambda",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "text": "'ðŸ“‚'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w26",
      "widget_type": "Button"
    },
    "w27": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 288,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "insertbackground": "self.colors.get(...)",
        "selectbackground": "self.colors.get(...)",
        "undo": "True",
        "wrap": "'word'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w27",
      "widget_type": "Text"
    },
    "w28": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 302,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w28",
      "widget_type": "Frame"
    },
    "w29": {
      "bind_events": [],
      "command_targets": [
        "self._save_full_template"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 305,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self._save_full_template",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "text": "'SAVE AS TEMPLATE'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w29",
      "widget_type": "Button"
    },
    "w3": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 190,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w3",
      "widget_type": "Frame"
    },
    "w30": {
      "bind_events": [],
      "command_targets": [
        "Lambda"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 315,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "Lambda",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "text": "'LOAD TEMPLATE'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w30",
      "widget_type": "Button"
    },
    "w31": {
      "bind_events": [],
      "command_targets": [
        "self._submit"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 325,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self._submit",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "text": "'RUN CELL'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w31",
      "widget_type": "Button"
    },
    "w32": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 338,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bd": "1",
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "relief": "'solid'",
        "text": "' Inference Console '"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w32",
      "widget_type": "LabelFrame"
    },
    "w33": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 347,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "height": "6",
        "insertbackground": "self.colors.get(...)",
        "wrap": "'word'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w33",
      "widget_type": "Text"
    },
    "w34": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 363,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bd": "1",
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "relief": "'solid'",
        "text": "' Result + HITL '"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w34",
      "widget_type": "LabelFrame"
    },
    "w35": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 372,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "height": "8",
        "insertbackground": "self.colors.get(...)",
        "wrap": "'word'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w35",
      "widget_type": "Text"
    },
    "w36": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 385,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [
        "pack(fill='x', padx=10, pady=Tuple)"
      ],
      "parent_id": null,
      "widget_id": "w36",
      "widget_type": "Frame"
    },
    "w37": {
      "bind_events": [],
      "command_targets": [
        "self._on_accept"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 388,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self._on_accept",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "state": "'disabled'",
        "text": "'ACCEPT'"
      },
      "layout_calls": [],
      "parent_id": "w36",
      "widget_id": "w37",
      "widget_type": "Button"
    },
    "w38": {
      "bind_events": [],
      "command_targets": [
        "self._on_reject"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 399,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self._on_reject",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "state": "'disabled'",
        "text": "'REJECT & EDIT'"
      },
      "layout_calls": [],
      "parent_id": "w36",
      "widget_id": "w38",
      "widget_type": "Button"
    },
    "w39": {
      "bind_events": [],
      "command_targets": [
        "self.shell.root.destroy"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 410,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self.shell.root.destroy",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "text": "'EXIT CELL'"
      },
      "layout_calls": [],
      "parent_id": "w36",
      "widget_id": "w39",
      "widget_type": "Button"
    },
    "w4": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 193,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w4",
      "widget_type": "Frame"
    },
    "w40": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 421,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bd": "1",
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "relief": "'solid'",
        "text": "' Export / Spawn '"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w40",
      "widget_type": "LabelFrame"
    },
    "w41": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 430,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w41",
      "widget_type": "Frame"
    },
    "w42": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 433,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [
        "pack(fill='x')"
      ],
      "parent_id": null,
      "widget_id": "w42",
      "widget_type": "Frame"
    },
    "w43": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 439,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "state": "'readonly'",
        "textvariable": "self.export_dest_var",
        "values": "List"
      },
      "layout_calls": [],
      "parent_id": "w42",
      "widget_id": "w43",
      "widget_type": "Combobox"
    },
    "w44": {
      "bind_events": [],
      "command_targets": [
        "self._handle_export"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 447,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "command": "self._handle_export",
        "fg": "self.colors.get(...)",
        "relief": "'flat'",
        "state": "'disabled'",
        "text": "'EXECUTE'"
      },
      "layout_calls": [],
      "parent_id": "w42",
      "widget_id": "w44",
      "widget_type": "Button"
    },
    "w45": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 455,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w45",
      "widget_type": "Frame"
    },
    "w46": {
      "bind_events": [
        "'<Return>' -> Lambda",
        "'<Escape>' -> Lambda"
      ],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 592,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {},
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w46",
      "widget_type": "Toplevel"
    },
    "w47": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 601,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {},
      "layout_calls": [
        "pack(padx=10, fill='x')"
      ],
      "parent_id": "w46",
      "widget_id": "w47",
      "widget_type": "Entry"
    },
    "w48": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 636,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [
        "pack(pady=10)"
      ],
      "parent_id": "w46",
      "widget_id": "w48",
      "widget_type": "Frame"
    },
    "w49": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...))",
        "configure(bg=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 668,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {},
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w49",
      "widget_type": "Toplevel"
    },
    "w5": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 196,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w5",
      "widget_type": "Frame"
    },
    "w50": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...), fg=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 689,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "text": "'Theme:'"
      },
      "layout_calls": [
        "pack(pady=Tuple)"
      ],
      "parent_id": "w49",
      "widget_id": "w50",
      "widget_type": "Label"
    },
    "w51": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 693,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "state": "'readonly'",
        "textvariable": "theme_var",
        "values": "List"
      },
      "layout_calls": [
        "pack(pady=2)"
      ],
      "parent_id": "w49",
      "widget_id": "w51",
      "widget_type": "Combobox"
    },
    "w52": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...), fg=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 697,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "text": "'Window Size (WxH):'"
      },
      "layout_calls": [
        "pack(pady=Tuple)"
      ],
      "parent_id": "w49",
      "widget_id": "w52",
      "widget_type": "Label"
    },
    "w53": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...), fg=self.colors.get(...), insertbackground=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 700,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "insertbackground": "self.colors.get(...)",
        "relief": "'flat'"
      },
      "layout_calls": [
        "pack(pady=2)"
      ],
      "parent_id": "w49",
      "widget_id": "w53",
      "widget_type": "Entry"
    },
    "w54": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [
        "configure(bg=self.colors.get(...))"
      ],
      "created_at": {
        "col": 8,
        "lineno": 711,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [
        "pack(side='bottom', fill='x', pady=20)"
      ],
      "parent_id": "w49",
      "widget_id": "w54",
      "widget_type": "Frame"
    },
    "w55": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 798,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [
        "pack(anchor='center')"
      ],
      "parent_id": "w54",
      "widget_id": "w55",
      "widget_type": "Frame"
    },
    "w56": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 813,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "tearoff": "0"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w56",
      "widget_type": "Menu"
    },
    "w6": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 200,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w6",
      "widget_type": "Frame"
    },
    "w7": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 204,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)",
        "fg": "self.colors.get(...)",
        "font": "Tuple",
        "text": "'Type in your idea HERE.'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w7",
      "widget_type": "Label"
    },
    "w8": {
      "bind_events": [],
      "command_targets": [],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 210,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "bg": "self.colors.get(...)"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w8",
      "widget_type": "Frame"
    },
    "w9": {
      "bind_events": [],
      "command_targets": [
        "self._bold_text"
      ],
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 214,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\ui.py"
      },
      "kwargs": {
        "command": "self._bold_text",
        "font": "Tuple",
        "text": "'B'"
      },
      "layout_calls": [],
      "parent_id": null,
      "widget_id": "w9",
      "widget_type": "Button"
    }
  },
  "windows": {
    "win1": {
      "config_calls": [],
      "created_at": {
        "col": 8,
        "lineno": 51,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\microservices\\_TkinterAppShellMS.py"
      },
      "geometry_calls": [],
      "title_calls": [],
      "window_id": "win1"
    },
    "win3": {
      "config_calls": [],
      "created_at": {
        "col": 4,
        "lineno": 131,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\microservices\\_OllamaModelSelectorMS.py"
      },
      "geometry_calls": [
        "root.geometry('400x100')"
      ],
      "title_calls": [
        "root.title('Ollama Selector Test')"
      ],
      "window_id": "win3"
    },
    "win4": {
      "config_calls": [],
      "created_at": {
        "col": 4,
        "lineno": 57,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\microservices\\_TkinterSmartExplorerMS.py"
      },
      "geometry_calls": [],
      "title_calls": [],
      "window_id": "win4"
    },
    "win5": {
      "config_calls": [],
      "created_at": {
        "col": 4,
        "lineno": 148,
        "path": "C:\\Users\\jacob\\Documents\\_UsefulHelperSCRIPTS\\_theCELL\\src\\microservices\\_LogViewMS.py"
      },
      "geometry_calls": [
        "root.geometry('600x400')"
      ],
      "title_calls": [
        "root.title('Log View Test')"
      ],
      "window_id": "win5"
    }
  }
}

--------------------------------------------------------------------------------
FILE: _uimapper_reports\uimap_report.md
--------------------------------------------------------------------------------
# UI Mapper Report
_Generated: 2026-02-12T19:08:12_

**Project Root:** `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL`

## Summary
- Windows detected: **4**
- Widgets detected: **56**
- Unknown cases: **0**
- Parse errors: **0**

## Windows
### win1
- Created at: `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\microservices\_TkinterAppShellMS.py:51:8`
### win3
- Created at: `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\microservices\_OllamaModelSelectorMS.py:131:4`
- Title calls:
  - `root.title('Ollama Selector Test')`
- Geometry calls:
  - `root.geometry('400x100')`
### win4
- Created at: `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\microservices\_TkinterSmartExplorerMS.py:57:4`
### win5
- Created at: `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\microservices\_LogViewMS.py:148:4`
- Title calls:
  - `root.title('Log View Test')`
- Geometry calls:
  - `root.geometry('600x400')`

## Widgets
### Button (15)
- **w10** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:216:8`
  - kwargs:
    - `command` = `self._italic_text`
    - `font` = `Tuple`
    - `text` = `'I'`
  - commands:
    - `self._italic_text`
- **w11** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:218:8`
  - kwargs:
    - `command` = `self._bullet_list`
    - `text` = `'â€¢ List'`
  - commands:
    - `self._bullet_list`
- **w12** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:221:8`
  - kwargs:
    - `command` = `self._open_settings`
    - `text` = `'âš™'`
  - commands:
    - `self._open_settings`
- **w19** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:253:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `Lambda`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `text` = `'ðŸ’¾'`
  - commands:
    - `Lambda`
- **w20** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:256:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `Lambda`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `text` = `'ðŸ“‚'`
  - commands:
    - `Lambda`
- **w25** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:278:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `Lambda`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `text` = `'ðŸ’¾'`
  - commands:
    - `Lambda`
- **w26** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:281:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `Lambda`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `text` = `'ðŸ“‚'`
  - commands:
    - `Lambda`
- **w29** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:305:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self._save_full_template`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `text` = `'SAVE AS TEMPLATE'`
  - commands:
    - `self._save_full_template`
- **w30** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:315:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `Lambda`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `text` = `'LOAD TEMPLATE'`
  - commands:
    - `Lambda`
- **w31** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:325:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self._submit`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `text` = `'RUN CELL'`
  - commands:
    - `self._submit`
- **w37** (parent: `w36`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:388:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self._on_accept`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `state` = `'disabled'`
    - `text` = `'ACCEPT'`
  - commands:
    - `self._on_accept`
- **w38** (parent: `w36`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:399:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self._on_reject`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `state` = `'disabled'`
    - `text` = `'REJECT & EDIT'`
  - commands:
    - `self._on_reject`
- **w39** (parent: `w36`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:410:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self.shell.root.destroy`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `text` = `'EXIT CELL'`
  - commands:
    - `self.shell.root.destroy`
- **w44** (parent: `w42`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:447:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `command` = `self._handle_export`
    - `fg` = `self.colors.get(...)`
    - `relief` = `'flat'`
    - `state` = `'disabled'`
    - `text` = `'EXECUTE'`
  - commands:
    - `self._handle_export`
- **w9** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:214:8`
  - kwargs:
    - `command` = `self._bold_text`
    - `font` = `Tuple`
    - `text` = `'B'`
  - commands:
    - `self._bold_text`

### Combobox (3)
- **w15** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:234:8`
  - kwargs:
    - `textvariable` = `self.model_var`
- **w43** (parent: `w42`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:439:8`
  - kwargs:
    - `state` = `'readonly'`
    - `textvariable` = `self.export_dest_var`
    - `values` = `List`
- **w51** (parent: `w49`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:693:8`
  - kwargs:
    - `state` = `'readonly'`
    - `textvariable` = `theme_var`
    - `values` = `List`
  - layout:
    - `pack(pady=2)`

### Entry (3)
- **w18** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:244:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `insertbackground` = `self.colors.get(...)`
- **w47** (parent: `w46`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:601:8`
  - layout:
    - `pack(padx=10, fill='x')`
- **w53** (parent: `w49`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:700:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `insertbackground` = `self.colors.get(...)`
    - `relief` = `'flat'`
  - layout:
    - `pack(pady=2)`
  - config:
    - `configure(bg=self.colors.get(...), fg=self.colors.get(...), insertbackground=self.colors.get(...))`

### Frame (17)
- **w17** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:241:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w2** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:48:8`
  - kwargs:
    - `bg` = `colors.get(...)`
- **w22** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:263:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w24** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:276:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w28** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:302:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w3** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:190:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w36** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:385:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
  - layout:
    - `pack(fill='x', padx=10, pady=Tuple)`
- **w4** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:193:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w41** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:430:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w42** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:433:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
  - layout:
    - `pack(fill='x')`
- **w45** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:455:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w48** (parent: `w46`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:636:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
  - layout:
    - `pack(pady=10)`
- **w5** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:196:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w54** (parent: `w49`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:711:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
  - layout:
    - `pack(side='bottom', fill='x', pady=20)`
  - config:
    - `configure(bg=self.colors.get(...))`
- **w55** (parent: `w54`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:798:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
  - layout:
    - `pack(anchor='center')`
- **w6** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:200:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
- **w8** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:210:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`

### Label (6)
- **w14** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:231:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `text` = `'Model:'`
- **w16** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:239:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `text` = `'System Role:'`
- **w21** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:261:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `text` = `'System Prompt:'`
- **w50** (parent: `w49`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:689:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `text` = `'Theme:'`
  - layout:
    - `pack(pady=Tuple)`
  - config:
    - `configure(bg=self.colors.get(...), fg=self.colors.get(...))`
- **w52** (parent: `w49`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:697:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `text` = `'Window Size (WxH):'`
  - layout:
    - `pack(pady=Tuple)`
  - config:
    - `configure(bg=self.colors.get(...), fg=self.colors.get(...))`
- **w7** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:204:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `text` = `'Type in your idea HERE.'`

### LabelFrame (4)
- **w13** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:225:8`
  - kwargs:
    - `bd` = `1`
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `relief` = `'solid'`
    - `text` = `' Inference Parameters '`
- **w32** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:338:8`
  - kwargs:
    - `bd` = `1`
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `relief` = `'solid'`
    - `text` = `' Inference Console '`
- **w34** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:363:8`
  - kwargs:
    - `bd` = `1`
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `relief` = `'solid'`
    - `text` = `' Result + HITL '`
- **w40** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:421:8`
  - kwargs:
    - `bd` = `1`
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `relief` = `'solid'`
    - `text` = `' Export / Spawn '`

### Menu (1)
- **w56** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:813:8`
  - kwargs:
    - `tearoff` = `0`

### Text (4)
- **w23** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:266:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `height` = `3`
    - `insertbackground` = `self.colors.get(...)`
- **w27** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:288:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `insertbackground` = `self.colors.get(...)`
    - `selectbackground` = `self.colors.get(...)`
    - `undo` = `True`
    - `wrap` = `'word'`
- **w33** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:347:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `height` = `6`
    - `insertbackground` = `self.colors.get(...)`
    - `wrap` = `'word'`
- **w35** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:372:8`
  - kwargs:
    - `bg` = `self.colors.get(...)`
    - `fg` = `self.colors.get(...)`
    - `font` = `Tuple`
    - `height` = `8`
    - `insertbackground` = `self.colors.get(...)`
    - `wrap` = `'word'`

### Toplevel (2)
- **w46** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:592:8`
  - config:
    - `configure(bg=self.colors.get(...))`
  - binds:
    - `'<Return>' -> Lambda`
    - `'<Escape>' -> Lambda`
- **w49** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:668:8`
  - config:
    - `configure(bg=self.colors.get(...))`
    - `configure(bg=self.colors.get(...))`

### Treeview (1)
- **w1** (parent: `None`) â€” created at `C:\Users\jacob\Documents\_UsefulHelperSCRIPTS\_theCELL\src\ui.py:35:8`
  - kwargs:
    - `columns` = `Tuple`
    - `show` = `'headings'`


## Unknown Cases
_None._

## Parse Errors
_None._
