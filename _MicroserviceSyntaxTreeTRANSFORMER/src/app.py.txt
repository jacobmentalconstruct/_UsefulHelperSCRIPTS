#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Microservice Syntax Tree Transformer (Prototype)

This tool:
- Loads a JSON tasklist (tasklist_microservice_refactor.json).
- Lets the user select a folder of Python files.
- Iterates over each .py file in that folder.
- Runs a simple, ordered pipeline of tasks per file.
- Logs all activity to a Tkinter UI log panel and stderr.

NOTE:
- This prototype focuses on orchestration + monitoring.
- The actual "parse / scaffold / patch" logic is stubbed out with clear hooks
  where you can integrate:
    - your semantic diff-based patcher
    - Ollama / Qwen model calls
    - your microservice-specific scaffold + IR logic.
"""

# =========================================================
# 1. IMPORTS
# =========================================================

import sys
import os
import json
import threading
import queue
import time
from typing import List, Dict, Any, Optional

import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import scrolledtext

# =========================================================
# 2. GLOBAL CONFIGURATION
# =========================================================

WINDOW_TITLE = "Microservice Syntax Tree Transformer"
WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 700
LOG_FONT = ("Consolas", 10)

DEFAULT_TASKLIST_PATH = os.path.join(
    os.path.dirname(__file__),
    "tasklist_microservice_refactor.json"
)

VALID_EXTENSIONS = [".py"]

LOG_PREFIX_INFO = "[INFO]"
LOG_PREFIX_WARN = "[WARN]"
LOG_PREFIX_ERROR = "[ERROR]"
LOG_PREFIX_TASK = "[TASK]"
LOG_PREFIX_FILE = "[FILE]"

# =========================================================
# 3. LOGGING + UTILITY HELPERS
# =========================================================

class UILogger:
    """
    Thread-safe logger that writes to:
    - a Tkinter Text/ScrolledText widget (if available)
    - stderr

    Uses an internal queue to synchronize log messages
    from worker threads into the main Tkinter thread.
    """

    def __init__(self, text_widget: Optional[tk.Text] = None):
        self.text_widget = text_widget
        self.queue: "queue.Queue[str]" = queue.Queue()
        self._stop = False

    def attach_widget(self, text_widget: tk.Text) -> None:
        self.text_widget = text_widget

    def log(self, prefix: str, message: str) -> None:
        line = f"{prefix} {message}"
        print(line, file=sys.stderr)
        self.queue.put(line + "\n")

    def info(self, message: str) -> None:
        self.log(LOG_PREFIX_INFO, message)

    def warn(self, message: str) -> None:
        self.log(LOG_PREFIX_WARN, message)

    def error(self, message: str) -> None:
        self.log(LOG_PREFIX_ERROR, message)

    def task(self, message: str) -> None:
        self.log(LOG_PREFIX_TASK, message)

    def file(self, message: str) -> None:
        self.log(LOG_PREFIX_FILE, message)

    def pump(self):
        """
        Drain the queue into the UI text widget.
        This should be called periodically from the Tkinter main thread.
        """
        if self.text_widget is None:
            while not self.queue.empty():
                _ = self.queue.get_nowait()
            return

        try:
            while True:
                line = self.queue.get_nowait()
                self.text_widget.insert(tk.END, line)
                self.text_widget.see(tk.END)
        except queue.Empty:
            pass

        if not self._stop:
            self.text_widget.after(100, self.pump)

    def stop(self):
        self._stop = True


def load_tasklist(tasklist_path: str, logger: UILogger) -> List[Dict[str, Any]]:
    logger.info(f"Loading tasklist from: {tasklist_path}")
    if not os.path.exists(tasklist_path):
        logger.error(f"Tasklist not found at: {tasklist_path}")
        return []

    try:
        with open(tasklist_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        if not isinstance(data, list):
            logger.error("Tasklist JSON is not a list.")
            return []
        logger.info(f"Loaded {len(data)} tasks from tasklist.")
        return data
    except Exception as e:
        logger.error(f"Failed to load tasklist JSON: {e}")
        return []


def discover_python_files(root_folder: str, logger: UILogger) -> List[str]:
    logger.info(f"Scanning for Python files in: {root_folder}")
    results: List[str] = []

    for dirpath, dirnames, filenames in os.walk(root_folder):
        for name in filenames:
            _, ext = os.path.splitext(name)
            if ext.lower() in VALID_EXTENSIONS:
                full_path = os.path.join(dirpath, name)
                results.append(full_path)

    logger.info(f"Discovered {len(results)} Python files.")
    return results

# =========================================================
# 4. CORE PIPELINE ROLES (STUBS)
# =========================================================

class RefactorContext:
    """
    Per-file context for the refactor pipeline.
    """

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.original_source: str = ""
        self.ir: Dict[str, Any] = {}
        self.scaffold_source: str = ""


class ParserRole:
    """
    Task: 'parse_file'
    Loads the file and extracts a minimal IR.
    """

    TASK_NAME = "parse_file"

    def run(self, ctx: RefactorContext, logger: UILogger) -> None:
        logger.task(f"[{self.TASK_NAME}] Parsing file: {ctx.file_path}")
        try:
            with open(ctx.file_path, "r", encoding="utf-8") as f:
                ctx.original_source = f.read()
        except Exception as e:
            logger.error(f"[{self.TASK_NAME}] Failed to read file: {e}")
            return

        ctx.ir = {
            "file_path": ctx.file_path,
            "service_name": None,
            "imports": [],
            "endpoints": [],
            "metadata": {},
        }
        logger.info(f"[{self.TASK_NAME}] IR initialized (stub).")


class ScaffoldRole:
    """
    Task: 'generate_scaffold'
    Creates the symbolic scaffold with placeholders.
    """

    TASK_NAME = "generate_scaffold"

    # --- STUB SCAFFOLD (will be replaced by patch) ---
    SCAFFOLD_TEMPLATE = """# {{IMPORTS}}

# {{METADATA}}

class {{CLASS_NAME}}:
    def __init__(self):
        # {{INIT}}
        pass

    # {{ENDPOINTS}}
"""

    def run(self, ctx: RefactorContext, logger: UILogger) -> None:
        logger.task(f"[{self.TASK_NAME}] Generating scaffold.")
        ctx.scaffold_source = self.SCAFFOLD_TEMPLATE
        logger.info(f"[{self.TASK_NAME}] Scaffold initialized (stub).")


class PatchRole:
    """
    Handles all patch_* tasks.
    """

    SUPPORTED_TASKS = {
        "patch_imports",
        "patch_metadata",
        "patch_class_header",
        "patch_init",
        "patch_endpoints",
        "final_cleanup",
    }

    def run(self, task_name: str, ctx: RefactorContext, logger: UILogger) -> None:
        if task_name not in self.SUPPORTED_TASKS:
            logger.warn(f"[PatchRole] Unsupported task: {task_name}")
            return

        logger.task(f"[{task_name}] (stub) Would generate and apply patch hunks here.")
        # This is where your semantic patcher will be integrated.


# =========================================================
# 5. TASKLIST-DRIVEN PIPELINE EXECUTION
# =========================================================

class RefactorEngine:
    """
    Orchestrates:
    - loading the tasklist
    - discovering files
    - running each task over each file
    """

    def __init__(self, logger: UILogger, tasklist_path: str = DEFAULT_TASKLIST_PATH):
        self.logger = logger
        self.tasklist_path = tasklist_path
        self.tasklist: List[Dict[str, Any]] = []
        self.parser = ParserRole()
        self.scaffold = ScaffoldRole()
        self.patcher = PatchRole()

    def load_tasklist(self) -> None:
        self.tasklist = load_tasklist(self.tasklist_path, self.logger)

    def run_for_folder(self, folder: str) -> None:
        if not self.tasklist:
            self.logger.error("No tasklist loaded. Aborting.")
            return

        files = discover_python_files(folder, self.logger)
        if not files:
            self.logger.warn("No Python files found in selected folder.")
            return

        for file_path in files:
            self.logger.file(f"Processing file: {file_path}")
            ctx = RefactorContext(file_path)
            self._run_for_file(ctx)

        self.logger.info("Refactor pipeline complete for all files.")

    def _run_for_file(self, ctx: RefactorContext) -> None:
        for task in self.tasklist:
            task_name = task.get("task")
            description = task.get("description", "")
            self.logger.task(f"Running task '{task_name}': {description}")

            if task_name == ParserRole.TASK_NAME:
                self.parser.run(ctx, self.logger)
            elif task_name == ScaffoldRole.TASK_NAME:
                self.scaffold.run(ctx, self.logger)
            else:
                self.patcher.run(task_name, ctx, self.logger)

            time.sleep(0.05)

# =========================================================
# 6. TKINTER UI
# =========================================================

class RefactorApp(tk.Tk):
    """
    Tkinter UI wrapper for:
    - choosing a folder
    - kicking off the refactor pipeline
    - monitoring logs
    """

    def __init__(self):
        super().__init__()
        self.title(WINDOW_TITLE)
        self.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")

        self.logger = UILogger()
        self.engine = RefactorEngine(self.logger)

        self.selected_folder: Optional[str] = None
        self.worker_thread: Optional[threading.Thread] = None
        self._is_running = False

        self._build_ui()

        self.logger.attach_widget(self.log_text)
        self.logger.pump()

        self.engine.load_tasklist()

    def _build_ui(self) -> None:
        top_frame = tk.Frame(self)
        top_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

        folder_label = tk.Label(top_frame, text="Target folder:")
        folder_label.pack(side=tk.LEFT)

        self.folder_var = tk.StringVar(value="")
        folder_entry = tk.Entry(top_frame, textvariable=self.folder_var, width=60)
        folder_entry.pack(side=tk.LEFT, padx=5)

        browse_btn = tk.Button(top_frame, text="Browse...", command=self._on_browse)
        browse_btn.pack(side=tk.LEFT, padx=5)

        self.run_btn = tk.Button(top_frame, text="Run Refactor", command=self._on_run)
        self.run_btn.pack(side=tk.LEFT, padx=10)

        self.status_var = tk.StringVar(value="Idle")
        status_label = tk.Label(self, textvariable=self.status_var, anchor="w")
        status_label.pack(side=tk.TOP, fill=tk.X, padx=10)

        self.log_text = scrolledtext.ScrolledText(self, font=LOG_FONT, wrap=tk.WORD)
        self.log_text.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=10, pady=10)

    def _on_browse(self) -> None:
        folder = filedialog.askdirectory(title="Select folder containing microservices")
        if folder:
            self.selected_folder = folder
            self.folder_var.set(folder)
            self.logger.info(f"Selected folder: {folder}")

    def _on_run(self) -> None:
        if self._is_running:
            messagebox.showinfo("In Progress", "The refactor pipeline is already running.")
            return

        folder = self.folder_var.get().strip()
        if not folder or not os.path.isdir(folder):
            messagebox.showerror("Invalid Folder", "Please select a valid folder first.")
            return

        self.selected_folder = folder
        self._is_running = True
        self.status_var.set("Running...")
        self.run_btn.config(state=tk.DISABLED)

        self.logger.info(f"Starting refactor pipeline for folder: {folder}")

        self.worker_thread = threading.Thread(
            target=self._run_in_background,
            args=(folder,),
            daemon=True,
        )
        self.worker_thread.start()

        self.after(250, self._check_worker)

    def _run_in_background(self, folder: str) -> None:
        try:
            self.engine.run_for_folder(folder)
        except Exception as e:
            self.logger.error(f"Unexpected error in worker thread: {e}")
        finally:
            self._is_running = False

    def _check_worker(self) -> None:
        if self._is_running:
            self.after(250, self._check_worker)
        else:
            self.status_var.set("Idle")
            self.run_btn.config(state=tk.NORMAL)
            self.logger.info("Refactor pipeline finished or aborted.")

# =========================================================
# 7. ENTRYPOINT
# =========================================================

def main():
    app = RefactorApp()
    app.mainloop()


if __name__ == "__main__":
    main()
