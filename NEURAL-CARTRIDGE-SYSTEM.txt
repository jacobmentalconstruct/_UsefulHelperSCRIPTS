PROJECT CONTEXT: THE NEURAL CARTRIDGE SYSTEM

Classification: System Architecture & Philosophy Status: Initialization Phase Role: Onboarding Documentation for AI Assistants
1. THE MANDATE

We are moving beyond linear "Input → Process → Output" pipelines. We are building a Cognitive Exoskeleton: a unified, local-first development environment that allows a human user to curate complex applications ("complex cohesive data objects") using a swarm of small, specialized AI models (e.g., Qwen 2.5 family).

The goal is to solve the Context Window Bottleneck and Complexity Scatter by shifting the "Brain" of the operation from the Model to the Database.
2. CORE PHILOSOPHY: THE SPIRAL

We reject linear checklists. We adopt Fractal/Spiral Architecture.

    The Seed: Every project begins with a "Source of Truth" (a raw file, idea, or data source).

    The Shells: We do not build forward; we build outward. We wrap the Seed in layers of understanding ("Dimensioning").

    The Graph: Complexity is managed via a Directed Acyclic Graph (DAG) stored in SQLite. Relationships (dependencies, imports, logic flows) are explicit edges in the database, not implicit context in a prompt.

3. THE LEXICON

To participate in this system, you must understand these terms as defined below:

    The Cartridge (.sqlite): The atomic unit of the project. A portable SQLite file that acts as the "Anchor." It contains both the Content (Code/Text) and the Context (Graph/Vector Map).

    The Forge (UI): The Human-in-the-Loop interface (Python/Tkinter). It is the control center where the user visualizes the Spiral and triggers tools.

    The Hunk: The smallest unit of data. A file is not a single string; it is a collection of Hunks (functions, classes, paragraphs) derived via parsing strategies.

    The Lens: The mechanism of retrieving only the specific Hunks required for a task, filtering out noise.

    Dimensioning: The process of analyzing a Node (file/hunk) and generating its metadata, vectors, and relationships (Edges).

4. SYSTEM ARCHITECTURE

The system is composed of three distinct layers:
A. The Ledger (Memory)

    Role: The Source of Truth.

    Implementation: SQLite.

    Dual-State:

        Immutable Archive: Stores raw files verbatim (BLOBs).

        Mutable Map: Stores parsed Hunks, Vectors, and the Node Graph.

B. The Engine (Logic)

    Role: The "Hands" of the system.

    Implementation: Modular Python Micro-services.

    Key Services:

        _CartridgeDRIVER: Manages DB I/O.

        _IngestionENGINE: Parses raw data into Hunks using Strategy Patterns (AST, Recursive, Tabular).

        _GraphMAPPER: Manages the connections between Hunks.

C. The Swarm (Intelligence)

    Role: Transient workers. Stateless and specialized.

    The Librarian (Embedding): Vectorizes Hunks during ingestion.

    The Architect (7b+ LLM): Views the Graph Map to plan "Shell Expansion" (tasks).

    The Mason (0.5b - 3b LLM): Receives a specific Hunk and executes a specific edit.

5. OPERATIONAL WORKFLOW

    Ingestion: The User introduces a "Seed" (file). The Engine parses it into Hunks and logs it in the Ledger.

    Focus: The User applies a "Lens" to a specific branch of the Spiral (e.g., "Focus on the UI Node").

    Inference: The Swarm operates only on the data within the Lens, generating new code or refactoring existing code.

    Crystallization: The output is validated and written back to the Ledger, becoming a new layer of the Spiral.

6. YOUR INSTRUCTIONS

As an AI agent assisting in this project, your priorities are:

    Maintain State Discipline: Never assume the model holds the state. The SQLite Cartridge holds the state.

    Respect the Spiral: When proposing code, think in layers. First define the interface (Shell 1), then the implementation (Shell 2).

    Micro-Service Focus: Code generation should be modular, distinct, and fit within the defined micro-service boundaries (_Driver, _Engine, _Factory).

This abstraction separates Memory (the Cartridge) from Intelligence (the Models) and Control (the Forge).
I. The Artifact: The "Brain Cartridge" (.sqlite)

This is the portable unit of your "Cognitive Exoskeleton." It is a single file that contains the entire state of a project. It is The Anchor.

    Ledger A: The Archive (Immutable Truth)

        Raw Source: The verbatim files (code, text, PDFs). If the system fails, this remains untouched.

        The Hunks: The atomized units of data (functions, paragraphs, clauses) derived from the source.

        The Vectors: Mathematical embeddings of the Hunks for similarity search.

    Ledger B: The Map (Mutable Context)

        The Graph: A network of Nodes and Edges.

        The Spiral: Tracks the hierarchy. Seed Node → Layer 1 Nodes → Layer 2 Nodes.

        The State: Tracks task progress (Pending, Drafted, Frozen).

II. The Mechanism: The "Ingestion Engine"

This is the gateway through which raw data becomes "Cartridge Material." It uses the Strategy Pattern to adapt to different data types.

    Intake: Accepts a file path.

    Strategy Selection:

        Code Mode: Parses AST (Classes, Functions).

        Text Mode: Parses Headers/Paragraphs recursively.

        Data Mode: Parses Rows/Columns/JSON keys.

    Atomization: Splits the file into "Hunks" based on the strategy.

    Registration: Logs the Hunks in Ledger A and creates initial Nodes in Ledger B.

III. The Intelligence: The "Swarm Layer"

The AI models are stateless workers. They do not "know" anything; they only process what is retrieved from the Cartridge.

    The Librarian (Embedding Model): Runs during Ingestion. Converts Hunks into Vectors.

    The Architect (7b+ Model): "The Lens." Looks at the Graph Map (Ledger B) to plan tasks. It sees the relationships, not the raw code.

    The Mason (0.5b - 3b Model): "The Hands." Receives a single Hunk (from Ledger A) and a specific instruction. Executes the change.

IV. The Interface: The "Forge" (Tkinter)

This is your Human-in-the-Loop control center.

    The Dashboard: Visualizes the Cartridge stats (How many nodes? How deep is the spiral?).

    The Lens View: Allows you to "zoom in" on a specific branch of the Graph.

    The Toolbench: Where you trigger Ingestion or launch an Inference Cycle.

Summary of Data Flow (The "Spiral")

    Seed: You ingest a raw file (The Seed).

    Dimensioning: The System maps the internal structure of that file into the Graph (Layer 1).

    Expansion: You ask the Architect to propose changes. It reads Layer 1 and proposes Layer 2 (new functions/files).

    Crystallization: The Mason writes the code for Layer 2. The Ingestion Engine parses this new code and locks it into the Cartridge.

Here is the breakdown of the Neural Cartridge System into discrete, buildable components.
I. Backend Micro-Services (The Engine)

These are non-visual logic units. They take data in, process it, and return data or write to the DB.

1. _CartridgeDRIVER

    Role: The Database Authority. It is the only thing allowed to touch the .sqlite file.

    Key Functions:

        init_cartridge(path): Creates the schema (Sources, Hunks, Edges, Vectors).

        write_source(path, raw_bytes): Safely stores verbatim files.

        write_hunks(source_id, hunks_list): Batch inserts parsed data.

        get_hunk(hunk_id): Retrieves content.

2. _IngestionENGINE

    Role: The Router and Processor. It decides how to eat a file.

    Key Functions:

        ingest(file_path, strategy_name): The main entry point.

        _parse_text_recursive(text): Strategy for documents.

        _parse_python_ast(code): Strategy for Python (uses ast module).

        _parse_tabular(csv_data): Strategy for spreadsheets.

3. _VectorCORE

    Role: The Math Wiz. Interfaces with your local embedding model.

    Key Functions:

        embed_text(text_string): Returns a float array.

        calculate_similarity(vec_a, vec_b): Returns cosine similarity score.

4. _GraphMAPPER

    Role: The Cartographer. Manages relationships between IDs.

    Key Functions:

        link_nodes(id_a, id_b, relation_type): Creates an edge.

        get_children(node_id): Returns all downstream nodes.

        get_parents(node_id): Returns dependencies.

II. UI Micro-Services (The Visual Framework)

This is your "Tkinter Factory." Instead of writing raw Tkinter code in your app, you call these standardized builders.

5. _LayoutFACTORY

    Role: Manages the geometry (grids, tabs, containers).

    Components:

        create_smart_grid(parent, rows, cols): Generates a frame with pre-configured weight/expansion logic.

        create_tab_container(parent, tab_names): Returns a Notebook with named frames already initialized.

        create_panel(parent, side): Returns a standardized container (e.g., "Left Sidebar", "Bottom Log").

6. _InputFACTORY

    Role: Standardized data entry widgets.

    Components:

        smart_entry(parent, label, variable): Label + Entry box pair.

        smart_dropdown(parent, label, options, command): Label + Combobox with event binding.

        action_button(parent, text, command, style): Standardized button (Primary/Secondary styles).

        toggle_switch(parent, label, variable): Checkbox or custom canvas switch.

7. _ViewFACTORY

    Role: Complex data display widgets.

    Components:

        code_editor(parent): Text area with line numbers and monospace font.

        tree_visualizer(parent, data): Treeview for displaying the Graph/Spiral hierarchy.

        log_console(parent): Read-only text area with timestamp injection.

III. The Orchestration Layer (The Glue)

This is the main.py that imports the services above and routes traffic.

8. _AppCONTROLLER

    Role: The Traffic Cop. It connects UI Events to Backend Actions.

    Logic Flow:

        User Action: Clicks "Ingest" button (from _InputFACTORY).

        Event: Controller catches event.

        Process: Controller calls _IngestionENGINE.ingest().

        Storage: Engine calls _CartridgeDRIVER.write().

        Feedback: Controller updates _ViewFACTORY.log_console with "Success".

Suggested Build Order

To prevent getting "scattered," build them in this exact order. Each step yields a working unit.

    _CartridgeDRIVER: Build this first. Write a test script to create a DB and read/write a dummy string.

    _LayoutFACTORY: Build a window with a Tab container and a Grid. Verify your UI skeleton works.

    _AppCONTROLLER: Connect the Layout to the Driver (e.g., A button in the UI creates the DB).

    _IngestionENGINE: Add the logic to parse files.
